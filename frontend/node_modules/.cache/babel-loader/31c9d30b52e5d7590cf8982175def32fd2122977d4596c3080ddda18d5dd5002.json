{"ast":null,"code":"import { Store } from \"./store.js\";\nimport { __storeToDerived, __derivedToStore } from \"./scheduler.js\";\nclass Derived {\n  constructor(options) {\n    this.listeners = /* @__PURE__ */new Set();\n    this._subscriptions = [];\n    this.lastSeenDepValues = [];\n    this.getDepVals = () => {\n      const prevDepVals = [];\n      const currDepVals = [];\n      for (const dep of this.options.deps) {\n        prevDepVals.push(dep.prevState);\n        currDepVals.push(dep.state);\n      }\n      this.lastSeenDepValues = currDepVals;\n      return {\n        prevDepVals,\n        currDepVals,\n        prevVal: this.prevState ?? void 0\n      };\n    };\n    this.recompute = () => {\n      var _a, _b;\n      this.prevState = this.state;\n      const {\n        prevDepVals,\n        currDepVals,\n        prevVal\n      } = this.getDepVals();\n      this.state = this.options.fn({\n        prevDepVals,\n        currDepVals,\n        prevVal\n      });\n      (_b = (_a = this.options).onUpdate) == null ? void 0 : _b.call(_a);\n    };\n    this.checkIfRecalculationNeededDeeply = () => {\n      for (const dep of this.options.deps) {\n        if (dep instanceof Derived) {\n          dep.checkIfRecalculationNeededDeeply();\n        }\n      }\n      let shouldRecompute = false;\n      const lastSeenDepValues = this.lastSeenDepValues;\n      const {\n        currDepVals\n      } = this.getDepVals();\n      for (let i = 0; i < currDepVals.length; i++) {\n        if (currDepVals[i] !== lastSeenDepValues[i]) {\n          shouldRecompute = true;\n          break;\n        }\n      }\n      if (shouldRecompute) {\n        this.recompute();\n      }\n    };\n    this.mount = () => {\n      this.registerOnGraph();\n      this.checkIfRecalculationNeededDeeply();\n      return () => {\n        this.unregisterFromGraph();\n        for (const cleanup of this._subscriptions) {\n          cleanup();\n        }\n      };\n    };\n    this.subscribe = listener => {\n      var _a, _b;\n      this.listeners.add(listener);\n      const unsub = (_b = (_a = this.options).onSubscribe) == null ? void 0 : _b.call(_a, listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub == null ? void 0 : unsub();\n      };\n    };\n    this.options = options;\n    this.state = options.fn({\n      prevDepVals: void 0,\n      prevVal: void 0,\n      currDepVals: this.getDepVals().currDepVals\n    });\n  }\n  registerOnGraph(deps = this.options.deps) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        dep.registerOnGraph();\n        this.registerOnGraph(dep.options.deps);\n      } else if (dep instanceof Store) {\n        let relatedLinkedDerivedVals = __storeToDerived.get(dep);\n        if (!relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals = /* @__PURE__ */new Set();\n          __storeToDerived.set(dep, relatedLinkedDerivedVals);\n        }\n        relatedLinkedDerivedVals.add(this);\n        let relatedStores = __derivedToStore.get(this);\n        if (!relatedStores) {\n          relatedStores = /* @__PURE__ */new Set();\n          __derivedToStore.set(this, relatedStores);\n        }\n        relatedStores.add(dep);\n      }\n    }\n  }\n  unregisterFromGraph(deps = this.options.deps) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        this.unregisterFromGraph(dep.options.deps);\n      } else if (dep instanceof Store) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(dep);\n        if (relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals.delete(this);\n        }\n        const relatedStores = __derivedToStore.get(this);\n        if (relatedStores) {\n          relatedStores.delete(dep);\n        }\n      }\n    }\n  }\n}\nexport { Derived };","map":{"version":3,"names":["Derived","constructor","options","listeners","Set","_subscriptions","lastSeenDepValues","getDepVals","prevDepVals","currDepVals","dep","deps","push","prevState","state","prevVal","recompute","fn","_b","_a","onUpdate","call","checkIfRecalculationNeededDeeply","shouldRecompute","i","length","mount","registerOnGraph","unregisterFromGraph","cleanup","subscribe","listener","add","unsub","onSubscribe","delete","Store","relatedLinkedDerivedVals","__storeToDerived","get","set","relatedStores","__derivedToStore"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/store/src/derived.ts"],"sourcesContent":["import { Store } from './store'\nimport { __derivedToStore, __storeToDerived } from './scheduler'\nimport type { Listener } from './types'\n\nexport type UnwrapDerivedOrStore<T> =\n  T extends Derived<infer InnerD>\n    ? InnerD\n    : T extends Store<infer InnerS>\n      ? InnerS\n      : never\n\ntype UnwrapReadonlyDerivedOrStoreArray<\n  TArr extends ReadonlyArray<Derived<any> | Store<any>>,\n> = TArr extends readonly [infer Head, ...infer Tail]\n  ? Head extends Derived<any> | Store<any>\n    ? Tail extends ReadonlyArray<Derived<any> | Store<any>>\n      ? [UnwrapDerivedOrStore<Head>, ...UnwrapReadonlyDerivedOrStoreArray<Tail>]\n      : []\n    : []\n  : []\n\n// Can't have currVal, as it's being evaluated from the current derived fn\nexport interface DerivedFnProps<\n  TArr extends ReadonlyArray<Derived<any> | Store<any>> = ReadonlyArray<any>,\n  TUnwrappedArr extends\n    UnwrapReadonlyDerivedOrStoreArray<TArr> = UnwrapReadonlyDerivedOrStoreArray<TArr>,\n> {\n  // `undefined` if it's the first run\n  /**\n   * `undefined` if it's the first run\n   * @privateRemarks this also cannot be typed as TState, as it breaks the inferencing of the function's return type when an argument is used - even with `NoInfer` usage\n   */\n  prevVal: unknown | undefined\n  prevDepVals: TUnwrappedArr | undefined\n  currDepVals: TUnwrappedArr\n}\n\nexport interface DerivedOptions<\n  TState,\n  TArr extends ReadonlyArray<Derived<any> | Store<any>> = ReadonlyArray<any>,\n> {\n  onSubscribe?: (\n    listener: Listener<TState>,\n    derived: Derived<TState>,\n  ) => () => void\n  onUpdate?: () => void\n  deps: TArr\n  /**\n   * Values of the `deps` from before and after the current invocation of `fn`\n   */\n  fn: (props: DerivedFnProps<TArr>) => TState\n}\n\nexport class Derived<\n  TState,\n  const TArr extends ReadonlyArray<\n    Derived<any> | Store<any>\n  > = ReadonlyArray<any>,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  prevState: TState | undefined\n  options: DerivedOptions<TState, TArr>\n\n  /**\n   * Functions representing the subscriptions. Call a function to cleanup\n   * @private\n   */\n  _subscriptions: Array<() => void> = []\n\n  lastSeenDepValues: Array<unknown> = []\n  getDepVals = () => {\n    const prevDepVals = [] as Array<unknown>\n    const currDepVals = [] as Array<unknown>\n    for (const dep of this.options.deps) {\n      prevDepVals.push(dep.prevState)\n      currDepVals.push(dep.state)\n    }\n    this.lastSeenDepValues = currDepVals\n    return {\n      prevDepVals,\n      currDepVals,\n      prevVal: this.prevState ?? undefined,\n    }\n  }\n\n  constructor(options: DerivedOptions<TState, TArr>) {\n    this.options = options\n    this.state = options.fn({\n      prevDepVals: undefined,\n      prevVal: undefined,\n      currDepVals: this.getDepVals().currDepVals as never,\n    })\n  }\n\n  registerOnGraph(\n    deps: ReadonlyArray<Derived<any> | Store<any>> = this.options.deps,\n  ) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        // First register the intermediate derived value if it's not already registered\n        dep.registerOnGraph()\n        // Then register this derived with the dep's underlying stores\n        this.registerOnGraph(dep.options.deps)\n      } else if (dep instanceof Store) {\n        // Register the derived as related derived to the store\n        let relatedLinkedDerivedVals = __storeToDerived.get(dep)\n        if (!relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals = new Set()\n          __storeToDerived.set(dep, relatedLinkedDerivedVals)\n        }\n        relatedLinkedDerivedVals.add(this as never)\n\n        // Register the store as a related store to this derived\n        let relatedStores = __derivedToStore.get(this as never)\n        if (!relatedStores) {\n          relatedStores = new Set()\n          __derivedToStore.set(this as never, relatedStores)\n        }\n        relatedStores.add(dep)\n      }\n    }\n  }\n\n  unregisterFromGraph(\n    deps: ReadonlyArray<Derived<any> | Store<any>> = this.options.deps,\n  ) {\n    for (const dep of deps) {\n      if (dep instanceof Derived) {\n        this.unregisterFromGraph(dep.options.deps)\n      } else if (dep instanceof Store) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(dep)\n        if (relatedLinkedDerivedVals) {\n          relatedLinkedDerivedVals.delete(this as never)\n        }\n\n        const relatedStores = __derivedToStore.get(this as never)\n        if (relatedStores) {\n          relatedStores.delete(dep)\n        }\n      }\n    }\n  }\n\n  recompute = () => {\n    this.prevState = this.state\n    const { prevDepVals, currDepVals, prevVal } = this.getDepVals()\n    this.state = this.options.fn({\n      prevDepVals: prevDepVals as never,\n      currDepVals: currDepVals as never,\n      prevVal,\n    })\n\n    this.options.onUpdate?.()\n  }\n\n  checkIfRecalculationNeededDeeply = () => {\n    for (const dep of this.options.deps) {\n      if (dep instanceof Derived) {\n        dep.checkIfRecalculationNeededDeeply()\n      }\n    }\n    let shouldRecompute = false\n    const lastSeenDepValues = this.lastSeenDepValues\n    const { currDepVals } = this.getDepVals()\n    for (let i = 0; i < currDepVals.length; i++) {\n      if (currDepVals[i] !== lastSeenDepValues[i]) {\n        shouldRecompute = true\n        break\n      }\n    }\n\n    if (shouldRecompute) {\n      this.recompute()\n    }\n  }\n\n  mount = () => {\n    this.registerOnGraph()\n    this.checkIfRecalculationNeededDeeply()\n\n    return () => {\n      this.unregisterFromGraph()\n      for (const cleanup of this._subscriptions) {\n        cleanup()\n      }\n    }\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}