{"ast":null,"code":"import { jsxs, Fragment, jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport warning from \"tiny-warning\";\nimport { isNotFound, rootRouteId, pick, isRedirect, createControlledPromise, getLocationChangeInfo } from \"@tanstack/router-core\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { CatchNotFound } from \"./not-found.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nimport { renderRouteNotFound } from \"./renderRouteNotFound.js\";\nimport { ScrollRestoration } from \"./scroll-restoration.js\";\nconst Match = React.memo(function MatchImpl({\n  matchId\n}) {\n  var _a, _b;\n  const router = useRouter();\n  const routeId = useRouterState({\n    select: s => {\n      var _a2;\n      return (_a2 = s.matches.find(d => d.id === matchId)) == null ? void 0 : _a2.routeId;\n    }\n  });\n  invariant(routeId, `Could not find routeId for matchId \"${matchId}\". Please file an issue!`);\n  const route = router.routesById[routeId];\n  const PendingComponent = route.options.pendingComponent ?? router.options.defaultPendingComponent;\n  const pendingElement = PendingComponent ? /* @__PURE__ */jsx(PendingComponent, {}) : null;\n  const routeErrorComponent = route.options.errorComponent ?? router.options.defaultErrorComponent;\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch;\n  const routeNotFoundComponent = route.isRoot ?\n  // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n  route.options.notFoundComponent ?? ((_a = router.options.notFoundRoute) == null ? void 0 : _a.options.component) : route.options.notFoundComponent;\n  const ResolvedSuspenseBoundary =\n  // If we're on the root route, allow forcefully wrapping in suspense\n  (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? React.Suspense : SafeFragment;\n  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;\n  const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;\n  const resetKey = useRouterState({\n    select: s => s.loadedAt\n  });\n  const parentRouteId = useRouterState({\n    select: s => {\n      var _a2;\n      const index = s.matches.findIndex(d => d.id === matchId);\n      return (_a2 = s.matches[index - 1]) == null ? void 0 : _a2.routeId;\n    }\n  });\n  return /* @__PURE__ */jsxs(Fragment, {\n    children: [/* @__PURE__ */jsx(matchContext.Provider, {\n      value: matchId,\n      children: /* @__PURE__ */jsx(ResolvedSuspenseBoundary, {\n        fallback: pendingElement,\n        children: /* @__PURE__ */jsx(ResolvedCatchBoundary, {\n          getResetKey: () => resetKey,\n          errorComponent: routeErrorComponent || ErrorComponent,\n          onCatch: (error, errorInfo) => {\n            if (isNotFound(error)) throw error;\n            warning(false, `Error in route match: ${matchId}`);\n            routeOnCatch == null ? void 0 : routeOnCatch(error, errorInfo);\n          },\n          children: /* @__PURE__ */jsx(ResolvedNotFoundBoundary, {\n            fallback: error => {\n              if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot) throw error;\n              return React.createElement(routeNotFoundComponent, error);\n            },\n            children: /* @__PURE__ */jsx(MatchInner, {\n              matchId\n            })\n          })\n        })\n      })\n    }), parentRouteId === rootRouteId && router.options.scrollRestoration ? /* @__PURE__ */jsxs(Fragment, {\n      children: [/* @__PURE__ */jsx(OnRendered, {}), /* @__PURE__ */jsx(ScrollRestoration, {})]\n    }) : null]\n  });\n});\nfunction OnRendered() {\n  const router = useRouter();\n  const prevLocationRef = React.useRef(void 0);\n  return /* @__PURE__ */jsx(\"script\", {\n    suppressHydrationWarning: true,\n    ref: el => {\n      if (el && (prevLocationRef.current === void 0 || prevLocationRef.current.href !== router.latestLocation.href)) {\n        router.emit({\n          type: \"onRendered\",\n          ...getLocationChangeInfo(router.state)\n        });\n        prevLocationRef.current = router.latestLocation;\n      }\n    }\n  }, router.latestLocation.state.key);\n}\nconst MatchInner = React.memo(function MatchInnerImpl({\n  matchId\n}) {\n  var _a, _b, _c;\n  const router = useRouter();\n  const {\n    match,\n    key,\n    routeId\n  } = useRouterState({\n    select: s => {\n      const matchIndex = s.matches.findIndex(d => d.id === matchId);\n      const match2 = s.matches[matchIndex];\n      const routeId2 = match2.routeId;\n      const remountFn = router.routesById[routeId2].options.remountDeps ?? router.options.defaultRemountDeps;\n      const remountDeps = remountFn == null ? void 0 : remountFn({\n        routeId: routeId2,\n        loaderDeps: match2.loaderDeps,\n        params: match2._strictParams,\n        search: match2._strictSearch\n      });\n      const key2 = remountDeps ? JSON.stringify(remountDeps) : void 0;\n      return {\n        key: key2,\n        routeId: routeId2,\n        match: pick(match2, [\"id\", \"status\", \"error\"])\n      };\n    },\n    structuralSharing: true\n  });\n  const route = router.routesById[routeId];\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent;\n    if (Comp) {\n      return /* @__PURE__ */jsx(Comp, {}, key);\n    }\n    return /* @__PURE__ */jsx(Outlet, {});\n  }, [key, route.options.component, router.options.defaultComponent]);\n  const RouteErrorComponent = (route.options.errorComponent ?? router.options.defaultErrorComponent) || ErrorComponent;\n  if (match.status === \"notFound\") {\n    invariant(isNotFound(match.error), \"Expected a notFound error\");\n    return renderRouteNotFound(router, route, match.error);\n  }\n  if (match.status === \"redirected\") {\n    invariant(isRedirect(match.error), \"Expected a redirect error\");\n    throw (_a = router.getMatch(match.id)) == null ? void 0 : _a.loadPromise;\n  }\n  if (match.status === \"error\") {\n    if (router.isServer) {\n      return /* @__PURE__ */jsx(RouteErrorComponent, {\n        error: match.error,\n        reset: void 0,\n        info: {\n          componentStack: \"\"\n        }\n      });\n    }\n    throw match.error;\n  }\n  if (match.status === \"pending\") {\n    const pendingMinMs = route.options.pendingMinMs ?? router.options.defaultPendingMinMs;\n    if (pendingMinMs && !((_b = router.getMatch(match.id)) == null ? void 0 : _b.minPendingPromise)) {\n      if (!router.isServer) {\n        const minPendingPromise = createControlledPromise();\n        Promise.resolve().then(() => {\n          router.updateMatch(match.id, prev => ({\n            ...prev,\n            minPendingPromise\n          }));\n        });\n        setTimeout(() => {\n          minPendingPromise.resolve();\n          router.updateMatch(match.id, prev => ({\n            ...prev,\n            minPendingPromise: void 0\n          }));\n        }, pendingMinMs);\n      }\n    }\n    throw (_c = router.getMatch(match.id)) == null ? void 0 : _c.loadPromise;\n  }\n  return out;\n});\nconst Outlet = React.memo(function OutletImpl() {\n  const router = useRouter();\n  const matchId = React.useContext(matchContext);\n  const routeId = useRouterState({\n    select: s => {\n      var _a;\n      return (_a = s.matches.find(d => d.id === matchId)) == null ? void 0 : _a.routeId;\n    }\n  });\n  const route = router.routesById[routeId];\n  const parentGlobalNotFound = useRouterState({\n    select: s => {\n      const matches = s.matches;\n      const parentMatch = matches.find(d => d.id === matchId);\n      invariant(parentMatch, `Could not find parent match for matchId \"${matchId}\"`);\n      return parentMatch.globalNotFound;\n    }\n  });\n  const childMatchId = useRouterState({\n    select: s => {\n      var _a;\n      const matches = s.matches;\n      const index = matches.findIndex(d => d.id === matchId);\n      return (_a = matches[index + 1]) == null ? void 0 : _a.id;\n    }\n  });\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, void 0);\n  }\n  if (!childMatchId) {\n    return null;\n  }\n  const nextMatch = /* @__PURE__ */jsx(Match, {\n    matchId: childMatchId\n  });\n  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */jsx(router.options.defaultPendingComponent, {}) : null;\n  if (matchId === rootRouteId) {\n    return /* @__PURE__ */jsx(React.Suspense, {\n      fallback: pendingElement,\n      children: nextMatch\n    });\n  }\n  return nextMatch;\n});\nexport { Match, MatchInner, Outlet };","map":{"version":3,"names":["Match","React","memo","MatchImpl","matchId","router","useRouter","routeId","useRouterState","select","s","_a2","matches","find","d","id","invariant","route","routesById","PendingComponent","options","pendingComponent","defaultPendingComponent","pendingElement","jsx","routeErrorComponent","errorComponent","defaultErrorComponent","routeOnCatch","onCatch","defaultOnCatch","routeNotFoundComponent","isRoot","notFoundComponent","_a","notFoundRoute","component","ResolvedSuspenseBoundary","wrapInSuspense","_b","preload","Suspense","SafeFragment","ResolvedCatchBoundary","CatchBoundary","ResolvedNotFoundBoundary","CatchNotFound","resetKey","loadedAt","parentRouteId","index","findIndex","jsxs","Fragment","children","matchContext","Provider","value","fallback","getResetKey","ErrorComponent","error","errorInfo","isNotFound","warning","createElement","MatchInner","rootRouteId","scrollRestoration","OnRendered","ScrollRestoration","prevLocationRef","useRef","suppressHydrationWarning","ref","el","current","href","latestLocation","emit","type","getLocationChangeInfo","state","key","MatchInnerImpl","match","matchIndex","match2","routeId2","remountFn","remountDeps","defaultRemountDeps","loaderDeps","params","_strictParams","search","_strictSearch","key2","JSON","stringify","pick","structuralSharing","out","useMemo","Comp","defaultComponent","Outlet","RouteErrorComponent","status","renderRouteNotFound","isRedirect","getMatch","loadPromise","isServer","reset","info","componentStack","pendingMinMs","defaultPendingMinMs","minPendingPromise","createControlledPromise","Promise","resolve","then","updateMatch","prev","setTimeout","_c","OutletImpl","useContext","parentGlobalNotFound","parentMatch","globalNotFound","childMatchId","nextMatch"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/Match.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport warning from 'tiny-warning'\nimport {\n  createControlledPromise,\n  getLocationChangeInfo,\n  isNotFound,\n  isRedirect,\n  pick,\n  rootRouteId,\n} from '@tanstack/router-core'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { CatchNotFound } from './not-found'\nimport { matchContext } from './matchContext'\nimport { SafeFragment } from './SafeFragment'\nimport { renderRouteNotFound } from './renderRouteNotFound'\nimport { ScrollRestoration } from './scroll-restoration'\nimport type { AnyRoute, ParsedLocation } from '@tanstack/router-core'\n\nexport const Match = React.memo(function MatchImpl({\n  matchId,\n}: {\n  matchId: string\n}) {\n  const router = useRouter()\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  invariant(\n    routeId,\n    `Could not find routeId for matchId \"${matchId}\". Please file an issue!`,\n  )\n\n  const route: AnyRoute = router.routesById[routeId]\n\n  const PendingComponent =\n    route.options.pendingComponent ?? router.options.defaultPendingComponent\n\n  const pendingElement = PendingComponent ? <PendingComponent /> : null\n\n  const routeErrorComponent =\n    route.options.errorComponent ?? router.options.defaultErrorComponent\n\n  const routeOnCatch = route.options.onCatch ?? router.options.defaultOnCatch\n\n  const routeNotFoundComponent = route.isRoot\n    ? // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component\n      (route.options.notFoundComponent ??\n      router.options.notFoundRoute?.options.component)\n    : route.options.notFoundComponent\n\n  const ResolvedSuspenseBoundary =\n    // If we're on the root route, allow forcefully wrapping in suspense\n    (!route.isRoot || route.options.wrapInSuspense) &&\n    (route.options.wrapInSuspense ??\n      PendingComponent ??\n      (route.options.errorComponent as any)?.preload)\n      ? React.Suspense\n      : SafeFragment\n\n  const ResolvedCatchBoundary = routeErrorComponent\n    ? CatchBoundary\n    : SafeFragment\n\n  const ResolvedNotFoundBoundary = routeNotFoundComponent\n    ? CatchNotFound\n    : SafeFragment\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  const parentRouteId = useRouterState({\n    select: (s) => {\n      const index = s.matches.findIndex((d) => d.id === matchId)\n      return s.matches[index - 1]?.routeId as string\n    },\n  })\n\n  return (\n    <>\n      <matchContext.Provider value={matchId}>\n        <ResolvedSuspenseBoundary fallback={pendingElement}>\n          <ResolvedCatchBoundary\n            getResetKey={() => resetKey}\n            errorComponent={routeErrorComponent || ErrorComponent}\n            onCatch={(error, errorInfo) => {\n              // Forward not found errors (we don't want to show the error component for these)\n              if (isNotFound(error)) throw error\n              warning(false, `Error in route match: ${matchId}`)\n              routeOnCatch?.(error, errorInfo)\n            }}\n          >\n            <ResolvedNotFoundBoundary\n              fallback={(error) => {\n                // If the current not found handler doesn't exist or it has a\n                // route ID which doesn't match the current route, rethrow the error\n                if (\n                  !routeNotFoundComponent ||\n                  (error.routeId && error.routeId !== routeId) ||\n                  (!error.routeId && !route.isRoot)\n                )\n                  throw error\n\n                return React.createElement(routeNotFoundComponent, error as any)\n              }}\n            >\n              <MatchInner matchId={matchId} />\n            </ResolvedNotFoundBoundary>\n          </ResolvedCatchBoundary>\n        </ResolvedSuspenseBoundary>\n      </matchContext.Provider>\n      {parentRouteId === rootRouteId && router.options.scrollRestoration ? (\n        <>\n          <OnRendered />\n          <ScrollRestoration />\n        </>\n      ) : null}\n    </>\n  )\n})\n\n// On Rendered can't happen above the root layout because it actually\n// renders a dummy dom element to track the rendered state of the app.\n// We render a script tag with a key that changes based on the current\n// location state.key. Also, because it's below the root layout, it\n// allows us to fire onRendered events even after a hydration mismatch\n// error that occurred above the root layout (like bad head/link tags,\n// which is common).\nfunction OnRendered() {\n  const router = useRouter()\n\n  const prevLocationRef = React.useRef<undefined | ParsedLocation<{}>>(\n    undefined,\n  )\n\n  return (\n    <script\n      key={router.latestLocation.state.key}\n      suppressHydrationWarning\n      ref={(el) => {\n        if (\n          el &&\n          (prevLocationRef.current === undefined ||\n            prevLocationRef.current.href !== router.latestLocation.href)\n        ) {\n          router.emit({\n            type: 'onRendered',\n            ...getLocationChangeInfo(router.state),\n          })\n          prevLocationRef.current = router.latestLocation\n        }\n      }}\n    />\n  )\n}\n\nexport const MatchInner = React.memo(function MatchInnerImpl({\n  matchId,\n}: {\n  matchId: string\n}): any {\n  const router = useRouter()\n\n  const { match, key, routeId } = useRouterState({\n    select: (s) => {\n      const matchIndex = s.matches.findIndex((d) => d.id === matchId)\n      const match = s.matches[matchIndex]!\n      const routeId = match.routeId as string\n\n      const remountFn =\n        (router.routesById[routeId] as AnyRoute).options.remountDeps ??\n        router.options.defaultRemountDeps\n      const remountDeps = remountFn?.({\n        routeId,\n        loaderDeps: match.loaderDeps,\n        params: match._strictParams,\n        search: match._strictSearch,\n      })\n      const key = remountDeps ? JSON.stringify(remountDeps) : undefined\n\n      return {\n        key,\n        routeId,\n        match: pick(match, ['id', 'status', 'error']),\n      }\n    },\n    structuralSharing: true as any,\n  })\n\n  const route = router.routesById[routeId] as AnyRoute\n\n  const out = React.useMemo(() => {\n    const Comp = route.options.component ?? router.options.defaultComponent\n    if (Comp) {\n      return <Comp key={key} />\n    }\n    return <Outlet />\n  }, [key, route.options.component, router.options.defaultComponent])\n\n  const RouteErrorComponent =\n    (route.options.errorComponent ?? router.options.defaultErrorComponent) ||\n    ErrorComponent\n\n  if (match.status === 'notFound') {\n    invariant(isNotFound(match.error), 'Expected a notFound error')\n    return renderRouteNotFound(router, route, match.error)\n  }\n\n  if (match.status === 'redirected') {\n    // Redirects should be handled by the router transition. If we happen to\n    // encounter a redirect here, it's a bug. Let's warn, but render nothing.\n    invariant(isRedirect(match.error), 'Expected a redirect error')\n\n    // warning(\n    //   false,\n    //   'Tried to render a redirected route match! This is a weird circumstance, please file an issue!',\n    // )\n    throw router.getMatch(match.id)?.loadPromise\n  }\n\n  if (match.status === 'error') {\n    // If we're on the server, we need to use React's new and super\n    // wonky api for throwing errors from a server side render inside\n    // of a suspense boundary. This is the only way to get\n    // renderToPipeableStream to not hang indefinitely.\n    // We'll serialize the error and rethrow it on the client.\n    if (router.isServer) {\n      return (\n        <RouteErrorComponent\n          error={match.error as any}\n          reset={undefined as any}\n          info={{\n            componentStack: '',\n          }}\n        />\n      )\n    }\n\n    throw match.error\n  }\n\n  if (match.status === 'pending') {\n    // We're pending, and if we have a minPendingMs, we need to wait for it\n    const pendingMinMs =\n      route.options.pendingMinMs ?? router.options.defaultPendingMinMs\n\n    if (pendingMinMs && !router.getMatch(match.id)?.minPendingPromise) {\n      // Create a promise that will resolve after the minPendingMs\n      if (!router.isServer) {\n        const minPendingPromise = createControlledPromise<void>()\n\n        Promise.resolve().then(() => {\n          router.updateMatch(match.id, (prev) => ({\n            ...prev,\n            minPendingPromise,\n          }))\n        })\n\n        setTimeout(() => {\n          minPendingPromise.resolve()\n\n          // We've handled the minPendingPromise, so we can delete it\n          router.updateMatch(match.id, (prev) => ({\n            ...prev,\n            minPendingPromise: undefined,\n          }))\n        }, pendingMinMs)\n      }\n    }\n    throw router.getMatch(match.id)?.loadPromise\n  }\n\n  return out\n})\n\nexport const Outlet = React.memo(function OutletImpl() {\n  const router = useRouter()\n  const matchId = React.useContext(matchContext)\n  const routeId = useRouterState({\n    select: (s) => s.matches.find((d) => d.id === matchId)?.routeId as string,\n  })\n\n  const route = router.routesById[routeId]!\n\n  const parentGlobalNotFound = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const parentMatch = matches.find((d) => d.id === matchId)\n      invariant(\n        parentMatch,\n        `Could not find parent match for matchId \"${matchId}\"`,\n      )\n      return parentMatch.globalNotFound\n    },\n  })\n\n  const childMatchId = useRouterState({\n    select: (s) => {\n      const matches = s.matches\n      const index = matches.findIndex((d) => d.id === matchId)\n      return matches[index + 1]?.id\n    },\n  })\n\n  if (parentGlobalNotFound) {\n    return renderRouteNotFound(router, route, undefined)\n  }\n\n  if (!childMatchId) {\n    return null\n  }\n\n  const nextMatch = <Match matchId={childMatchId} />\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  if (matchId === rootRouteId) {\n    return (\n      <React.Suspense fallback={pendingElement}>{nextMatch}</React.Suspense>\n    )\n  }\n\n  return nextMatch\n})\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}