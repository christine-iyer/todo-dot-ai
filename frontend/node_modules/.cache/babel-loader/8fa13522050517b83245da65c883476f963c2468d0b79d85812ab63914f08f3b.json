{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport { Outlet } from \"./Match.js\";\nimport { ClientOnly } from \"./ClientOnly.js\";\nfunction isModuleNotFoundError(error) {\n  if (typeof (error == null ? void 0 : error.message) !== \"string\") return false;\n  return error.message.startsWith(\"Failed to fetch dynamically imported module\") || error.message.startsWith(\"error loading dynamically imported module\") || error.message.startsWith(\"Importing a module script failed\");\n}\nfunction lazyRouteComponent(importer, exportName, ssr) {\n  let loadPromise;\n  let comp;\n  let error;\n  let reload;\n  const load = () => {\n    if (typeof document === \"undefined\" && (ssr == null ? void 0 : ssr()) === false) {\n      comp = () => null;\n      return Promise.resolve();\n    }\n    if (!loadPromise) {\n      loadPromise = importer().then(res => {\n        loadPromise = void 0;\n        comp = res[exportName ?? \"default\"];\n      }).catch(err => {\n        error = err;\n        if (isModuleNotFoundError(error)) {\n          if (error instanceof Error && typeof window !== \"undefined\" && typeof sessionStorage !== \"undefined\") {\n            const storageKey = `tanstack_router_reload:${error.message}`;\n            if (!sessionStorage.getItem(storageKey)) {\n              sessionStorage.setItem(storageKey, \"1\");\n              reload = true;\n            }\n          }\n        }\n      });\n    }\n    return loadPromise;\n  };\n  const lazyComp = function Lazy(props) {\n    if (reload) {\n      window.location.reload();\n      throw new Promise(() => {});\n    }\n    if (error) {\n      throw error;\n    }\n    if (!comp) {\n      throw load();\n    }\n    if ((ssr == null ? void 0 : ssr()) === false) {\n      return /* @__PURE__ */jsx(ClientOnly, {\n        fallback: /* @__PURE__ */jsx(Outlet, {}),\n        children: React.createElement(comp, props)\n      });\n    }\n    return React.createElement(comp, props);\n  };\n  lazyComp.preload = load;\n  return lazyComp;\n}\nexport { lazyRouteComponent };","map":{"version":3,"names":["isModuleNotFoundError","error","message","startsWith","lazyRouteComponent","importer","exportName","ssr","loadPromise","comp","reload","load","document","Promise","resolve","then","res","catch","err","Error","window","sessionStorage","storageKey","getItem","setItem","lazyComp","Lazy","props","location","jsx","ClientOnly","fallback","Outlet","children","React","createElement","preload"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/lazyRouteComponent.tsx"],"sourcesContent":["import * as React from 'react'\nimport { Outlet } from './Match'\nimport { ClientOnly } from './ClientOnly'\nimport type { AsyncRouteComponent } from './route'\n\n// If the load fails due to module not found, it may mean a new version of\n// the build was deployed and the user's browser is still using an old version.\n// If this happens, the old version in the user's browser would have an outdated\n// URL to the lazy module.\n// In that case, we want to attempt one window refresh to get the latest.\nfunction isModuleNotFoundError(error: any): boolean {\n  // chrome: \"Failed to fetch dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // firefox: \"error loading dynamically imported module: http://localhost:5173/src/routes/posts.index.tsx?tsr-split\"\n  // safari: \"Importing a module script failed.\"\n  if (typeof error?.message !== 'string') return false\n  return (\n    error.message.startsWith('Failed to fetch dynamically imported module') ||\n    error.message.startsWith('error loading dynamically imported module') ||\n    error.message.startsWith('Importing a module script failed')\n  )\n}\n\nexport function lazyRouteComponent<\n  T extends Record<string, any>,\n  TKey extends keyof T = 'default',\n>(\n  importer: () => Promise<T>,\n  exportName?: TKey,\n  ssr?: () => boolean,\n): T[TKey] extends (props: infer TProps) => any\n  ? AsyncRouteComponent<TProps>\n  : never {\n  let loadPromise: Promise<any> | undefined\n  let comp: T[TKey] | T['default']\n  let error: any\n  let reload: boolean\n\n  const load = () => {\n    if (typeof document === 'undefined' && ssr?.() === false) {\n      comp = (() => null) as any\n      return Promise.resolve()\n    }\n    if (!loadPromise) {\n      loadPromise = importer()\n        .then((res) => {\n          loadPromise = undefined\n          comp = res[exportName ?? 'default']\n        })\n        .catch((err) => {\n          // We don't want an error thrown from preload in this case, because\n          // there's nothing we want to do about module not found during preload.\n          // Record the error, the rest is handled during the render path.\n          error = err\n          if (isModuleNotFoundError(error)) {\n            if (\n              error instanceof Error &&\n              typeof window !== 'undefined' &&\n              typeof sessionStorage !== 'undefined'\n            ) {\n              // Again, we want to reload one time on module not found error and not enter\n              // a reload loop if there is some other issue besides an old deploy.\n              // That's why we store our reload attempt in sessionStorage.\n              // Use error.message as key because it contains the module path that failed.\n              const storageKey = `tanstack_router_reload:${error.message}`\n              if (!sessionStorage.getItem(storageKey)) {\n                sessionStorage.setItem(storageKey, '1')\n                reload = true\n              }\n            }\n          }\n        })\n    }\n\n    return loadPromise\n  }\n\n  const lazyComp = function Lazy(props: any) {\n    // Now that we're out of preload and into actual render path,\n    if (reload) {\n      // If it was a module loading error,\n      // throw eternal suspense while we wait for window to reload\n      window.location.reload()\n      throw new Promise(() => {})\n    }\n    if (error) {\n      // Otherwise, just throw the error\n      throw error\n    }\n\n    if (!comp) {\n      throw load()\n    }\n\n    if (ssr?.() === false) {\n      return (\n        <ClientOnly fallback={<Outlet />}>\n          {React.createElement(comp, props)}\n        </ClientOnly>\n      )\n    }\n    return React.createElement(comp, props)\n  }\n\n  ;(lazyComp as any).preload = load\n\n  return lazyComp as any\n}\n"],"mappings":";;;;AAUA,SAASA,sBAAsBC,KAAA,EAAqB;EAIlD,IAAI,QAAOA,KAAA,oBAAAA,KAAA,CAAOC,OAAA,MAAY,UAAiB;EAC/C,OACED,KAAA,CAAMC,OAAA,CAAQC,UAAA,CAAW,6CAA6C,KACtEF,KAAA,CAAMC,OAAA,CAAQC,UAAA,CAAW,2CAA2C,KACpEF,KAAA,CAAMC,OAAA,CAAQC,UAAA,CAAW,kCAAkC;AAE/D;AAEgB,SAAAC,mBAIdC,QAAA,EACAC,UAAA,EACAC,GAAA,EAGQ;EACJ,IAAAC,WAAA;EACA,IAAAC,IAAA;EACA,IAAAR,KAAA;EACA,IAAAS,MAAA;EAEJ,MAAMC,IAAA,GAAOA,CAAA,KAAM;IACjB,IAAI,OAAOC,QAAA,KAAa,gBAAeL,GAAA,oBAAAA,GAAA,QAAY,OAAO;MACxDE,IAAA,GAAQA,CAAA,KAAM;MACd,OAAOI,OAAA,CAAQC,OAAA,CAAQ;IAAA;IAEzB,IAAI,CAACN,WAAA,EAAa;MAChBA,WAAA,GAAcH,QAAA,CAAS,EACpBU,IAAA,CAAMC,GAAA,IAAQ;QACCR,WAAA;QACPC,IAAA,GAAAO,GAAA,CAAIV,UAAA,IAAc,SAAS;MAAA,CACnC,EACAW,KAAA,CAAOC,GAAA,IAAQ;QAINjB,KAAA,GAAAiB,GAAA;QACJ,IAAAlB,qBAAA,CAAsBC,KAAK,GAAG;UAChC,IACEA,KAAA,YAAiBkB,KAAA,IACjB,OAAOC,MAAA,KAAW,eAClB,OAAOC,cAAA,KAAmB,aAC1B;YAKM,MAAAC,UAAA,GAAa,0BAA0BrB,KAAA,CAAMC,OAAO;YAC1D,IAAI,CAACmB,cAAA,CAAeE,OAAA,CAAQD,UAAU,GAAG;cACxBD,cAAA,CAAAG,OAAA,CAAQF,UAAA,EAAY,GAAG;cAC7BZ,MAAA;YAAA;UACX;QACF;MACF,CACD;IAAA;IAGE,OAAAF,WAAA;EACT;EAEM,MAAAiB,QAAA,GAAW,SAASC,KAAKC,KAAA,EAAY;IAEzC,IAAIjB,MAAA,EAAQ;MAGVU,MAAA,CAAOQ,QAAA,CAASlB,MAAA,CAAO;MACjB,UAAIG,OAAA,CAAQ,MAAM,EAAE;IAAA;IAE5B,IAAIZ,KAAA,EAAO;MAEH,MAAAA,KAAA;IAAA;IAGR,IAAI,CAACQ,IAAA,EAAM;MACT,MAAME,IAAA,CAAK;IAAA;IAGT,KAAAJ,GAAA,oBAAAA,GAAA,QAAY,OAAO;MAEnB,sBAAAsB,GAAA,CAACC,UAAA,EAAW;QAAAC,QAAA,EAAW,eAAAF,GAAA,CAAAG,MAAA,IAAO;QAC3BC,QAAA,EAAMC,KAAA,CAAAC,aAAA,CAAc1B,IAAA,EAAMkB,KAAK;MAClC;IAAA;IAGG,OAAAO,KAAA,CAAMC,aAAA,CAAc1B,IAAA,EAAMkB,KAAK;EACxC;EAEEF,QAAA,CAAiBW,OAAA,GAAUzB,IAAA;EAEtB,OAAAc,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}