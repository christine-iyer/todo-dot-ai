{"ast":null,"code":"import { Derived } from \"./derived.js\";\nconst __storeToDerived = /* @__PURE__ */new WeakMap();\nconst __derivedToStore = /* @__PURE__ */new WeakMap();\nconst __depsThatHaveWrittenThisTick = {\n  current: []\n};\nlet __isFlushing = false;\nlet __batchDepth = 0;\nconst __pendingUpdates = /* @__PURE__ */new Set();\nconst __initialBatchValues = /* @__PURE__ */new Map();\nfunction __flush_internals(relatedVals) {\n  const sorted = Array.from(relatedVals).sort((a, b) => {\n    if (a instanceof Derived && a.options.deps.includes(b)) return 1;\n    if (b instanceof Derived && b.options.deps.includes(a)) return -1;\n    return 0;\n  });\n  for (const derived of sorted) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue;\n    }\n    __depsThatHaveWrittenThisTick.current.push(derived);\n    derived.recompute();\n    const stores = __derivedToStore.get(derived);\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store);\n        if (!relatedLinkedDerivedVals) continue;\n        __flush_internals(relatedLinkedDerivedVals);\n      }\n    }\n  }\n}\nfunction __notifyListeners(store) {\n  store.listeners.forEach(listener => listener({\n    prevVal: store.prevState,\n    currentVal: store.state\n  }));\n}\nfunction __notifyDerivedListeners(derived) {\n  derived.listeners.forEach(listener => listener({\n    prevVal: derived.prevState,\n    currentVal: derived.state\n  }));\n}\nfunction __flush(store) {\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState);\n  }\n  __pendingUpdates.add(store);\n  if (__batchDepth > 0) return;\n  if (__isFlushing) return;\n  try {\n    __isFlushing = true;\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates);\n      __pendingUpdates.clear();\n      for (const store2 of stores) {\n        const prevState = __initialBatchValues.get(store2) ?? store2.prevState;\n        store2.prevState = prevState;\n        __notifyListeners(store2);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        __depsThatHaveWrittenThisTick.current.push(store2);\n        __flush_internals(derivedVals);\n      }\n      for (const store2 of stores) {\n        const derivedVals = __storeToDerived.get(store2);\n        if (!derivedVals) continue;\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived);\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false;\n    __depsThatHaveWrittenThisTick.current = [];\n    __initialBatchValues.clear();\n  }\n}\nfunction batch(fn) {\n  __batchDepth++;\n  try {\n    fn();\n  } finally {\n    __batchDepth--;\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = Array.from(__pendingUpdates)[0];\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush);\n      }\n    }\n  }\n}\nexport { __depsThatHaveWrittenThisTick, __derivedToStore, __flush, __storeToDerived, batch };","map":{"version":3,"names":["__storeToDerived","WeakMap","__derivedToStore","__depsThatHaveWrittenThisTick","current","__isFlushing","__batchDepth","__pendingUpdates","Set","__initialBatchValues","Map","__flush_internals","relatedVals","sorted","Array","from","sort","a","b","Derived","options","deps","includes","derived","push","recompute","stores","get","store","relatedLinkedDerivedVals","__notifyListeners","listeners","forEach","listener","prevVal","prevState","currentVal","state","__notifyDerivedListeners","__flush","has","set","add","size","clear","store2","derivedVals","batch","fn","pendingUpdateToFlush"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/store/src/scheduler.ts"],"sourcesContent":["import { Derived } from './derived'\nimport type { Store } from './store'\n\n/**\n * This is here to solve the pyramid dependency problem where:\n *       A\n *      / \\\n *     B   C\n *      \\ /\n *       D\n *\n * Where we deeply traverse this tree, how do we avoid D being recomputed twice; once when B is updated, once when C is.\n *\n * To solve this, we create linkedDeps that allows us to sync avoid writes to the state until all of the deps have been\n * resolved.\n *\n * This is a record of stores, because derived stores are not able to write values to, but stores are\n */\nexport const __storeToDerived = new WeakMap<\n  Store<unknown>,\n  Set<Derived<unknown>>\n>()\nexport const __derivedToStore = new WeakMap<\n  Derived<unknown>,\n  Set<Store<unknown>>\n>()\n\nexport const __depsThatHaveWrittenThisTick = {\n  current: [] as Array<Derived<unknown> | Store<unknown>>,\n}\n\nlet __isFlushing = false\nlet __batchDepth = 0\nconst __pendingUpdates = new Set<Store<unknown>>()\n// Add a map to store initial values before batch\nconst __initialBatchValues = new Map<Store<unknown>, unknown>()\n\nfunction __flush_internals(relatedVals: Set<Derived<unknown>>) {\n  // First sort deriveds by dependency order\n  const sorted = Array.from(relatedVals).sort((a, b) => {\n    // If a depends on b, b should go first\n    if (a instanceof Derived && a.options.deps.includes(b)) return 1\n    // If b depends on a, a should go first\n    if (b instanceof Derived && b.options.deps.includes(a)) return -1\n    return 0\n  })\n\n  for (const derived of sorted) {\n    if (__depsThatHaveWrittenThisTick.current.includes(derived)) {\n      continue\n    }\n\n    __depsThatHaveWrittenThisTick.current.push(derived)\n    derived.recompute()\n\n    const stores = __derivedToStore.get(derived)\n    if (stores) {\n      for (const store of stores) {\n        const relatedLinkedDerivedVals = __storeToDerived.get(store)\n        if (!relatedLinkedDerivedVals) continue\n        __flush_internals(relatedLinkedDerivedVals)\n      }\n    }\n  }\n}\n\nfunction __notifyListeners(store: Store<unknown>) {\n  store.listeners.forEach((listener) =>\n    listener({\n      prevVal: store.prevState as never,\n      currentVal: store.state as never,\n    }),\n  )\n}\n\nfunction __notifyDerivedListeners(derived: Derived<unknown>) {\n  derived.listeners.forEach((listener) =>\n    listener({\n      prevVal: derived.prevState as never,\n      currentVal: derived.state as never,\n    }),\n  )\n}\n\n/**\n * @private only to be called from `Store` on write\n */\nexport function __flush(store: Store<unknown>) {\n  // If we're starting a batch, store the initial values\n  if (__batchDepth > 0 && !__initialBatchValues.has(store)) {\n    __initialBatchValues.set(store, store.prevState)\n  }\n\n  __pendingUpdates.add(store)\n\n  if (__batchDepth > 0) return\n  if (__isFlushing) return\n\n  try {\n    __isFlushing = true\n\n    while (__pendingUpdates.size > 0) {\n      const stores = Array.from(__pendingUpdates)\n      __pendingUpdates.clear()\n\n      // First notify listeners with updated values\n      for (const store of stores) {\n        // Use initial batch values for prevState if we have them\n        const prevState = __initialBatchValues.get(store) ?? store.prevState\n        store.prevState = prevState\n        __notifyListeners(store)\n      }\n\n      // Then update all derived values\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        __depsThatHaveWrittenThisTick.current.push(store)\n        __flush_internals(derivedVals)\n      }\n\n      // Notify derived listeners after recomputing\n      for (const store of stores) {\n        const derivedVals = __storeToDerived.get(store)\n        if (!derivedVals) continue\n\n        for (const derived of derivedVals) {\n          __notifyDerivedListeners(derived)\n        }\n      }\n    }\n  } finally {\n    __isFlushing = false\n    __depsThatHaveWrittenThisTick.current = []\n    __initialBatchValues.clear()\n  }\n}\n\nexport function batch(fn: () => void) {\n  __batchDepth++\n  try {\n    fn()\n  } finally {\n    __batchDepth--\n    if (__batchDepth === 0) {\n      const pendingUpdateToFlush = Array.from(__pendingUpdates)[0] as\n        | Store<unknown>\n        | undefined\n      if (pendingUpdateToFlush) {\n        __flush(pendingUpdateToFlush) // Trigger flush of all pending updates\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}