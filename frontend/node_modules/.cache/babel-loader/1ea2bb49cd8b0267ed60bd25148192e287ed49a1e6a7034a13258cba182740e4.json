{"ast":null,"code":"import { last } from \"./utils.js\";\nfunction joinPaths(paths) {\n  return cleanPath(paths.filter(val => {\n    return val !== void 0;\n  }).join(\"/\"));\n}\nfunction cleanPath(path) {\n  return path.replace(/\\/{2,}/g, \"/\");\n}\nfunction trimPathLeft(path) {\n  return path === \"/\" ? path : path.replace(/^\\/{1,}/, \"\");\n}\nfunction trimPathRight(path) {\n  return path === \"/\" ? path : path.replace(/\\/{1,}$/, \"\");\n}\nfunction trimPath(path) {\n  return trimPathRight(trimPathLeft(path));\n}\nfunction removeTrailingSlash(value, basepath) {\n  if ((value == null ? void 0 : value.endsWith(\"/\")) && value !== \"/\" && value !== `${basepath}/`) {\n    return value.slice(0, -1);\n  }\n  return value;\n}\nfunction exactPathTest(pathName1, pathName2, basepath) {\n  return removeTrailingSlash(pathName1, basepath) === removeTrailingSlash(pathName2, basepath);\n}\nfunction resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = \"never\",\n  caseSensitive\n}) {\n  var _a, _b;\n  base = removeBasepath(basepath, base, caseSensitive);\n  to = removeBasepath(basepath, to, caseSensitive);\n  let baseSegments = parsePathname(base);\n  const toSegments = parsePathname(to);\n  if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === \"/\") {\n    baseSegments.pop();\n  }\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === \"/\") {\n      if (!index) {\n        baseSegments = [toSegment];\n      } else if (index === toSegments.length - 1) {\n        baseSegments.push(toSegment);\n      } else ;\n    } else if (toSegment.value === \"..\") {\n      baseSegments.pop();\n    } else if (toSegment.value === \".\") ;else {\n      baseSegments.push(toSegment);\n    }\n  });\n  if (baseSegments.length > 1) {\n    if (((_b = last(baseSegments)) == null ? void 0 : _b.value) === \"/\") {\n      if (trailingSlash === \"never\") {\n        baseSegments.pop();\n      }\n    } else if (trailingSlash === \"always\") {\n      baseSegments.push({\n        type: \"pathname\",\n        value: \"/\"\n      });\n    }\n  }\n  const joined = joinPaths([basepath, ...baseSegments.map(d => d.value)]);\n  return cleanPath(joined);\n}\nfunction parsePathname(pathname) {\n  if (!pathname) {\n    return [];\n  }\n  pathname = cleanPath(pathname);\n  const segments = [];\n  if (pathname.slice(0, 1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  if (!pathname) {\n    return segments;\n  }\n  const split = pathname.split(\"/\").filter(Boolean);\n  segments.push(...split.map(part => {\n    if (part === \"$\" || part === \"*\") {\n      return {\n        type: \"wildcard\",\n        value: part\n      };\n    }\n    if (part.charAt(0) === \"$\") {\n      return {\n        type: \"param\",\n        value: part\n      };\n    }\n    return {\n      type: \"pathname\",\n      value: part.includes(\"%25\") ? part.split(\"%25\").map(segment => decodeURI(segment)).join(\"%25\") : decodeURI(part)\n    };\n  }));\n  if (pathname.slice(-1) === \"/\") {\n    pathname = pathname.substring(1);\n    segments.push({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  return segments;\n}\nfunction interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap\n}) {\n  const interpolatedPathSegments = parsePathname(path);\n  function encodeParam(key) {\n    const value = params[key];\n    const isValueString = typeof value === \"string\";\n    if ([\"*\", \"_splat\"].includes(key)) {\n      return isValueString ? encodeURI(value) : value;\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value;\n    }\n  }\n  let isMissingParams = false;\n  const usedParams = {};\n  const interpolatedPath = joinPaths(interpolatedPathSegments.map(segment => {\n    if (segment.type === \"wildcard\") {\n      usedParams._splat = params._splat;\n      const value = encodeParam(\"_splat\");\n      if (leaveWildcards) return `${segment.value}${value ?? \"\"}`;\n      return value;\n    }\n    if (segment.type === \"param\") {\n      const key = segment.value.substring(1);\n      if (!isMissingParams && !(key in params)) {\n        isMissingParams = true;\n      }\n      usedParams[key] = params[key];\n      if (leaveParams) {\n        const value = encodeParam(segment.value);\n        return `${segment.value}${value ?? \"\"}`;\n      }\n      return encodeParam(key) ?? \"undefined\";\n    }\n    return segment.value;\n  }));\n  return {\n    usedParams,\n    interpolatedPath,\n    isMissingParams\n  };\n}\nfunction encodePathParam(value, decodeCharMap) {\n  let encoded = encodeURIComponent(value);\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char);\n    }\n  }\n  return encoded;\n}\nfunction matchPathname(basepath, currentPathname, matchLocation) {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation);\n  if (matchLocation.to && !pathParams) {\n    return;\n  }\n  return pathParams ?? {};\n}\nfunction removeBasepath(basepath, pathname, caseSensitive = false) {\n  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase();\n  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase();\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case normalizedBasepath === \"/\":\n      return pathname;\n    // shortcut for removing the basepath if it matches the pathname\n    case normalizedPathname === normalizedBasepath:\n      return \"\";\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname;\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case normalizedPathname[normalizedBasepath.length] !== \"/\":\n      return pathname;\n    // remove the basepath from the pathname if it starts with it\n    case normalizedPathname.startsWith(normalizedBasepath):\n      return pathname.slice(basepath.length);\n    // otherwise, return the pathname as is\n    default:\n      return pathname;\n  }\n}\nfunction matchByPath(basepath, from, matchLocation) {\n  if (basepath !== \"/\" && !from.startsWith(basepath)) {\n    return void 0;\n  }\n  from = removeBasepath(basepath, from, matchLocation.caseSensitive);\n  const to = removeBasepath(basepath, `${matchLocation.to ?? \"$\"}`, matchLocation.caseSensitive);\n  const baseSegments = parsePathname(from);\n  const routeSegments = parsePathname(to);\n  if (!from.startsWith(\"/\")) {\n    baseSegments.unshift({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  if (!to.startsWith(\"/\")) {\n    routeSegments.unshift({\n      type: \"pathname\",\n      value: \"/\"\n    });\n  }\n  const params = {};\n  const isMatch = (() => {\n    for (let i = 0; i < Math.max(baseSegments.length, routeSegments.length); i++) {\n      const baseSegment = baseSegments[i];\n      const routeSegment = routeSegments[i];\n      const isLastBaseSegment = i >= baseSegments.length - 1;\n      const isLastRouteSegment = i >= routeSegments.length - 1;\n      if (routeSegment) {\n        if (routeSegment.type === \"wildcard\") {\n          const _splat = decodeURI(joinPaths(baseSegments.slice(i).map(d => d.value)));\n          params[\"*\"] = _splat;\n          params[\"_splat\"] = _splat;\n          return true;\n        }\n        if (routeSegment.type === \"pathname\") {\n          if (routeSegment.value === \"/\" && !(baseSegment == null ? void 0 : baseSegment.value)) {\n            return true;\n          }\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false;\n              }\n            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {\n              return false;\n            }\n          }\n        }\n        if (!baseSegment) {\n          return false;\n        }\n        if (routeSegment.type === \"param\") {\n          if (baseSegment.value === \"/\") {\n            return false;\n          }\n          if (baseSegment.value.charAt(0) !== \"$\") {\n            params[routeSegment.value.substring(1)] = decodeURIComponent(baseSegment.value);\n          }\n        }\n      }\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params[\"**\"] = joinPaths(baseSegments.slice(i + 1).map(d => d.value));\n        return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== \"/\";\n      }\n    }\n    return true;\n  })();\n  return isMatch ? params : void 0;\n}\nexport { cleanPath, exactPathTest, interpolatePath, joinPaths, matchByPath, matchPathname, parsePathname, removeBasepath, removeTrailingSlash, resolvePath, trimPath, trimPathLeft, trimPathRight };","map":{"version":3,"names":["joinPaths","paths","cleanPath","filter","val","join","path","replace","trimPathLeft","trimPathRight","trimPath","removeTrailingSlash","value","basepath","endsWith","slice","exactPathTest","pathName1","pathName2","resolvePath","base","to","trailingSlash","caseSensitive","removeBasepath","baseSegments","parsePathname","toSegments","length","_a","last","pop","forEach","toSegment","index","push","_b","type","joined","map","d","pathname","segments","substring","split","Boolean","part","charAt","includes","segment","decodeURI","interpolatePath","params","leaveWildcards","leaveParams","decodeCharMap","interpolatedPathSegments","encodeParam","key","isValueString","encodeURI","encodePathParam","isMissingParams","usedParams","interpolatedPath","_splat","encoded","encodeURIComponent","encodedChar","char","replaceAll","matchPathname","currentPathname","matchLocation","pathParams","matchByPath","normalizedBasepath","toLowerCase","normalizedPathname","startsWith","from","routeSegments","unshift","isMatch","i","Math","max","baseSegment","routeSegment","isLastBaseSegment","isLastRouteSegment","decodeURIComponent","fuzzy"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/router-core/src/path.ts"],"sourcesContent":["import { last } from './utils'\nimport type { MatchLocation } from './RouterProvider'\nimport type { AnyPathParams } from './route'\n\nexport interface Segment {\n  type: 'pathname' | 'param' | 'wildcard'\n  value: string\n}\n\nexport function joinPaths(paths: Array<string | undefined>) {\n  return cleanPath(\n    paths\n      .filter((val) => {\n        return val !== undefined\n      })\n      .join('/'),\n  )\n}\n\nexport function cleanPath(path: string) {\n  // remove double slashes\n  return path.replace(/\\/{2,}/g, '/')\n}\n\nexport function trimPathLeft(path: string) {\n  return path === '/' ? path : path.replace(/^\\/{1,}/, '')\n}\n\nexport function trimPathRight(path: string) {\n  return path === '/' ? path : path.replace(/\\/{1,}$/, '')\n}\n\nexport function trimPath(path: string) {\n  return trimPathRight(trimPathLeft(path))\n}\n\nexport function removeTrailingSlash(value: string, basepath: string): string {\n  if (value?.endsWith('/') && value !== '/' && value !== `${basepath}/`) {\n    return value.slice(0, -1)\n  }\n  return value\n}\n\n// intended to only compare path name\n// see the usage in the isActive under useLinkProps\n// /sample/path1 = /sample/path1/\n// /sample/path1/some <> /sample/path1\nexport function exactPathTest(\n  pathName1: string,\n  pathName2: string,\n  basepath: string,\n): boolean {\n  return (\n    removeTrailingSlash(pathName1, basepath) ===\n    removeTrailingSlash(pathName2, basepath)\n  )\n}\n\n// When resolving relative paths, we treat all paths as if they are trailing slash\n// documents. All trailing slashes are removed after the path is resolved.\n// Here are a few examples:\n//\n// /a/b/c + ./d = /a/b/c/d\n// /a/b/c + ../d = /a/b/d\n// /a/b/c + ./d/ = /a/b/c/d\n// /a/b/c + ../d/ = /a/b/d\n// /a/b/c + ./ = /a/b/c\n//\n// Absolute paths that start with `/` short circuit the resolution process to the root\n// path.\n//\n// Here are some examples:\n//\n// /a/b/c + /d = /d\n// /a/b/c + /d/ = /d\n// /a/b/c + / = /\n//\n// Non-.-prefixed paths are still treated as relative paths, resolved like `./`\n//\n// Here are some examples:\n//\n// /a/b/c + d = /a/b/c/d\n// /a/b/c + d/ = /a/b/c/d\n// /a/b/c + d/e = /a/b/c/d/e\ninterface ResolvePathOptions {\n  basepath: string\n  base: string\n  to: string\n  trailingSlash?: 'always' | 'never' | 'preserve'\n  caseSensitive?: boolean\n}\n\nexport function resolvePath({\n  basepath,\n  base,\n  to,\n  trailingSlash = 'never',\n  caseSensitive,\n}: ResolvePathOptions) {\n  base = removeBasepath(basepath, base, caseSensitive)\n  to = removeBasepath(basepath, to, caseSensitive)\n\n  let baseSegments = parsePathname(base)\n  const toSegments = parsePathname(to)\n\n  if (baseSegments.length > 1 && last(baseSegments)?.value === '/') {\n    baseSegments.pop()\n  }\n\n  toSegments.forEach((toSegment, index) => {\n    if (toSegment.value === '/') {\n      if (!index) {\n        // Leading slash\n        baseSegments = [toSegment]\n      } else if (index === toSegments.length - 1) {\n        // Trailing Slash\n        baseSegments.push(toSegment)\n      } else {\n        // ignore inter-slashes\n      }\n    } else if (toSegment.value === '..') {\n      baseSegments.pop()\n    } else if (toSegment.value === '.') {\n      // ignore\n    } else {\n      baseSegments.push(toSegment)\n    }\n  })\n\n  if (baseSegments.length > 1) {\n    if (last(baseSegments)?.value === '/') {\n      if (trailingSlash === 'never') {\n        baseSegments.pop()\n      }\n    } else if (trailingSlash === 'always') {\n      baseSegments.push({ type: 'pathname', value: '/' })\n    }\n  }\n\n  const joined = joinPaths([basepath, ...baseSegments.map((d) => d.value)])\n  return cleanPath(joined)\n}\n\nexport function parsePathname(pathname?: string): Array<Segment> {\n  if (!pathname) {\n    return []\n  }\n\n  pathname = cleanPath(pathname)\n\n  const segments: Array<Segment> = []\n\n  if (pathname.slice(0, 1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!pathname) {\n    return segments\n  }\n\n  // Remove empty segments and '.' segments\n  const split = pathname.split('/').filter(Boolean)\n\n  segments.push(\n    ...split.map((part): Segment => {\n      if (part === '$' || part === '*') {\n        return {\n          type: 'wildcard',\n          value: part,\n        }\n      }\n\n      if (part.charAt(0) === '$') {\n        return {\n          type: 'param',\n          value: part,\n        }\n      }\n\n      return {\n        type: 'pathname',\n        value: part.includes('%25')\n          ? part\n              .split('%25')\n              .map((segment) => decodeURI(segment))\n              .join('%25')\n          : decodeURI(part),\n      }\n    }),\n  )\n\n  if (pathname.slice(-1) === '/') {\n    pathname = pathname.substring(1)\n    segments.push({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  return segments\n}\n\ninterface InterpolatePathOptions {\n  path?: string\n  params: Record<string, unknown>\n  leaveWildcards?: boolean\n  leaveParams?: boolean\n  // Map of encoded chars to decoded chars (e.g. '%40' -> '@') that should remain decoded in path params\n  decodeCharMap?: Map<string, string>\n}\n\ntype InterPolatePathResult = {\n  interpolatedPath: string\n  usedParams: Record<string, unknown>\n  isMissingParams: boolean // true if any params were not available when being looked up in the params object\n}\nexport function interpolatePath({\n  path,\n  params,\n  leaveWildcards,\n  leaveParams,\n  decodeCharMap,\n}: InterpolatePathOptions): InterPolatePathResult {\n  const interpolatedPathSegments = parsePathname(path)\n\n  function encodeParam(key: string): any {\n    const value = params[key]\n    const isValueString = typeof value === 'string'\n\n    if (['*', '_splat'].includes(key)) {\n      // the splat/catch-all routes shouldn't have the '/' encoded out\n      return isValueString ? encodeURI(value) : value\n    } else {\n      return isValueString ? encodePathParam(value, decodeCharMap) : value\n    }\n  }\n\n  // Tracking if any params are missing in the `params` object\n  // when interpolating the path\n  let isMissingParams = false\n\n  const usedParams: Record<string, unknown> = {}\n  const interpolatedPath = joinPaths(\n    interpolatedPathSegments.map((segment) => {\n      if (segment.type === 'wildcard') {\n        usedParams._splat = params._splat\n        const value = encodeParam('_splat')\n        if (leaveWildcards) return `${segment.value}${value ?? ''}`\n        return value\n      }\n\n      if (segment.type === 'param') {\n        const key = segment.value.substring(1)\n        if (!isMissingParams && !(key in params)) {\n          isMissingParams = true\n        }\n        usedParams[key] = params[key]\n        if (leaveParams) {\n          const value = encodeParam(segment.value)\n          return `${segment.value}${value ?? ''}`\n        }\n        return encodeParam(key) ?? 'undefined'\n      }\n\n      return segment.value\n    }),\n  )\n  return { usedParams, interpolatedPath, isMissingParams }\n}\n\nfunction encodePathParam(value: string, decodeCharMap?: Map<string, string>) {\n  let encoded = encodeURIComponent(value)\n  if (decodeCharMap) {\n    for (const [encodedChar, char] of decodeCharMap) {\n      encoded = encoded.replaceAll(encodedChar, char)\n    }\n  }\n  return encoded\n}\n\nexport function matchPathname(\n  basepath: string,\n  currentPathname: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'fuzzy' | 'caseSensitive'>,\n): AnyPathParams | undefined {\n  const pathParams = matchByPath(basepath, currentPathname, matchLocation)\n  // const searchMatched = matchBySearch(location.search, matchLocation)\n\n  if (matchLocation.to && !pathParams) {\n    return\n  }\n\n  return pathParams ?? {}\n}\n\nexport function removeBasepath(\n  basepath: string,\n  pathname: string,\n  caseSensitive: boolean = false,\n) {\n  // normalize basepath and pathname for case-insensitive comparison if needed\n  const normalizedBasepath = caseSensitive ? basepath : basepath.toLowerCase()\n  const normalizedPathname = caseSensitive ? pathname : pathname.toLowerCase()\n\n  switch (true) {\n    // default behaviour is to serve app from the root - pathname\n    // left untouched\n    case normalizedBasepath === '/':\n      return pathname\n\n    // shortcut for removing the basepath if it matches the pathname\n    case normalizedPathname === normalizedBasepath:\n      return ''\n\n    // in case pathname is shorter than basepath - there is\n    // nothing to remove\n    case pathname.length < basepath.length:\n      return pathname\n\n    // avoid matching partial segments - strict equality handled\n    // earlier, otherwise, basepath separated from pathname with\n    // separator, therefore lack of separator means partial\n    // segment match (`/app` should not match `/application`)\n    case normalizedPathname[normalizedBasepath.length] !== '/':\n      return pathname\n\n    // remove the basepath from the pathname if it starts with it\n    case normalizedPathname.startsWith(normalizedBasepath):\n      return pathname.slice(basepath.length)\n\n    // otherwise, return the pathname as is\n    default:\n      return pathname\n  }\n}\n\nexport function matchByPath(\n  basepath: string,\n  from: string,\n  matchLocation: Pick<MatchLocation, 'to' | 'caseSensitive' | 'fuzzy'>,\n): Record<string, string> | undefined {\n  // check basepath first\n  if (basepath !== '/' && !from.startsWith(basepath)) {\n    return undefined\n  }\n  // Remove the base path from the pathname\n  from = removeBasepath(basepath, from, matchLocation.caseSensitive)\n  // Default to to $ (wildcard)\n  const to = removeBasepath(\n    basepath,\n    `${matchLocation.to ?? '$'}`,\n    matchLocation.caseSensitive,\n  )\n\n  // Parse the from and to\n  const baseSegments = parsePathname(from)\n  const routeSegments = parsePathname(to)\n\n  if (!from.startsWith('/')) {\n    baseSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  if (!to.startsWith('/')) {\n    routeSegments.unshift({\n      type: 'pathname',\n      value: '/',\n    })\n  }\n\n  const params: Record<string, string> = {}\n\n  const isMatch = (() => {\n    for (\n      let i = 0;\n      i < Math.max(baseSegments.length, routeSegments.length);\n      i++\n    ) {\n      const baseSegment = baseSegments[i]\n      const routeSegment = routeSegments[i]\n\n      const isLastBaseSegment = i >= baseSegments.length - 1\n      const isLastRouteSegment = i >= routeSegments.length - 1\n\n      if (routeSegment) {\n        if (routeSegment.type === 'wildcard') {\n          const _splat = decodeURI(\n            joinPaths(baseSegments.slice(i).map((d) => d.value)),\n          )\n          // TODO: Deprecate *\n          params['*'] = _splat\n          params['_splat'] = _splat\n          return true\n        }\n\n        if (routeSegment.type === 'pathname') {\n          if (routeSegment.value === '/' && !baseSegment?.value) {\n            return true\n          }\n\n          if (baseSegment) {\n            if (matchLocation.caseSensitive) {\n              if (routeSegment.value !== baseSegment.value) {\n                return false\n              }\n            } else if (\n              routeSegment.value.toLowerCase() !==\n              baseSegment.value.toLowerCase()\n            ) {\n              return false\n            }\n          }\n        }\n\n        if (!baseSegment) {\n          return false\n        }\n\n        if (routeSegment.type === 'param') {\n          if (baseSegment.value === '/') {\n            return false\n          }\n          if (baseSegment.value.charAt(0) !== '$') {\n            params[routeSegment.value.substring(1)] = decodeURIComponent(\n              baseSegment.value,\n            )\n          }\n        }\n      }\n\n      if (!isLastBaseSegment && isLastRouteSegment) {\n        params['**'] = joinPaths(baseSegments.slice(i + 1).map((d) => d.value))\n        return !!matchLocation.fuzzy && routeSegment?.value !== '/'\n      }\n    }\n\n    return true\n  })()\n\n  return isMatch ? params : undefined\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}