{"ast":null,"code":"import * as React from \"react\";\nfunction useStableCallback(fn) {\n  const fnRef = React.useRef(fn);\n  fnRef.current = fn;\n  const ref = React.useRef((...args) => fnRef.current(...args));\n  return ref.current;\n}\nconst useLayoutEffect = typeof window !== \"undefined\" ? React.useLayoutEffect : React.useEffect;\nfunction usePrevious(value) {\n  const ref = React.useRef({\n    value,\n    prev: null\n  });\n  const current = ref.current.value;\n  if (value !== current) {\n    ref.current = {\n      value,\n      prev: current\n    };\n  }\n  return ref.current.prev;\n}\nfunction useIntersectionObserver(ref, callback, intersectionObserverOptions = {}, options = {}) {\n  const isIntersectionObserverAvailable = React.useRef(typeof IntersectionObserver === \"function\");\n  const observerRef = React.useRef(null);\n  React.useEffect(() => {\n    if (!ref.current || !isIntersectionObserverAvailable.current || options.disabled) {\n      return;\n    }\n    observerRef.current = new IntersectionObserver(([entry]) => {\n      callback(entry);\n    }, intersectionObserverOptions);\n    observerRef.current.observe(ref.current);\n    return () => {\n      var _a;\n      (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n    };\n  }, [callback, intersectionObserverOptions, options.disabled, ref]);\n  return observerRef.current;\n}\nfunction useForwardedRef(ref) {\n  const innerRef = React.useRef(null);\n  React.useImperativeHandle(ref, () => innerRef.current, []);\n  return innerRef;\n}\nexport { useForwardedRef, useIntersectionObserver, useLayoutEffect, usePrevious, useStableCallback };","map":{"version":3,"names":["useStableCallback","fn","fnRef","React","useRef","current","ref","args","useLayoutEffect","window","useEffect","usePrevious","value","prev","useIntersectionObserver","callback","intersectionObserverOptions","options","isIntersectionObserverAvailable","IntersectionObserver","observerRef","disabled","entry","observe","_a","disconnect","useForwardedRef","innerRef","useImperativeHandle"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/utils.ts"],"sourcesContent":["import * as React from 'react'\n\nexport function useStableCallback<T extends (...args: Array<any>) => any>(\n  fn: T,\n): T {\n  const fnRef = React.useRef(fn)\n  fnRef.current = fn\n\n  const ref = React.useRef((...args: Array<any>) => fnRef.current(...args))\n  return ref.current as T\n}\n\nexport const useLayoutEffect =\n  typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect\n\n/**\n * Taken from https://www.developerway.com/posts/implementing-advanced-use-previous-hook#part3\n */\nexport function usePrevious<T>(value: T): T | null {\n  // initialise the ref with previous and current values\n  const ref = React.useRef<{ value: T; prev: T | null }>({\n    value: value,\n    prev: null,\n  })\n\n  const current = ref.current.value\n\n  // if the value passed into hook doesn't match what we store as \"current\"\n  // move the \"current\" to the \"previous\"\n  // and store the passed value as \"current\"\n  if (value !== current) {\n    ref.current = {\n      value: value,\n      prev: current,\n    }\n  }\n\n  // return the previous value only\n  return ref.current.prev\n}\n\n/**\n * React hook to wrap `IntersectionObserver`.\n *\n * This hook will create an `IntersectionObserver` and observe the ref passed to it.\n *\n * When the intersection changes, the callback will be called with the `IntersectionObserverEntry`.\n *\n * @param ref - The ref to observe\n * @param intersectionObserverOptions - The options to pass to the IntersectionObserver\n * @param options - The options to pass to the hook\n * @param callback - The callback to call when the intersection changes\n * @returns The IntersectionObserver instance\n * @example\n * ```tsx\n * const MyComponent = () => {\n * const ref = React.useRef<HTMLDivElement>(null)\n * useIntersectionObserver(\n *  ref,\n *  (entry) => { doSomething(entry) },\n *  { rootMargin: '10px' },\n *  { disabled: false }\n * )\n * return <div ref={ref} />\n * ```\n */\nexport function useIntersectionObserver<T extends Element>(\n  ref: React.RefObject<T | null>,\n  callback: (entry: IntersectionObserverEntry | undefined) => void,\n  intersectionObserverOptions: IntersectionObserverInit = {},\n  options: { disabled?: boolean } = {},\n): IntersectionObserver | null {\n  const isIntersectionObserverAvailable = React.useRef(\n    typeof IntersectionObserver === 'function',\n  )\n\n  const observerRef = React.useRef<IntersectionObserver | null>(null)\n\n  React.useEffect(() => {\n    if (\n      !ref.current ||\n      !isIntersectionObserverAvailable.current ||\n      options.disabled\n    ) {\n      return\n    }\n\n    observerRef.current = new IntersectionObserver(([entry]) => {\n      callback(entry)\n    }, intersectionObserverOptions)\n\n    observerRef.current.observe(ref.current)\n\n    return () => {\n      observerRef.current?.disconnect()\n    }\n  }, [callback, intersectionObserverOptions, options.disabled, ref])\n\n  return observerRef.current\n}\n\n/**\n * React hook to take a `React.ForwardedRef` and returns a `ref` that can be used on a DOM element.\n *\n * @param ref - The forwarded ref\n * @returns The inner ref returned by `useRef`\n * @example\n * ```tsx\n * const MyComponent = React.forwardRef((props, ref) => {\n *  const innerRef = useForwardedRef(ref)\n *  return <div ref={innerRef} />\n * })\n * ```\n */\nexport function useForwardedRef<T>(ref?: React.ForwardedRef<T>) {\n  const innerRef = React.useRef<T>(null)\n  React.useImperativeHandle(ref, () => innerRef.current!, [])\n  return innerRef\n}\n"],"mappings":";AAEO,SAASA,kBACdC,EAAA,EACG;EACG,MAAAC,KAAA,GAAQC,KAAA,CAAMC,MAAA,CAAOH,EAAE;EAC7BC,KAAA,CAAMG,OAAA,GAAUJ,EAAA;EAEV,MAAAK,GAAA,GAAMH,KAAA,CAAMC,MAAA,CAAO,IAAIG,IAAA,KAAqBL,KAAA,CAAMG,OAAA,CAAQ,GAAGE,IAAI,CAAC;EACxE,OAAOD,GAAA,CAAID,OAAA;AACb;AAEO,MAAMG,eAAA,GACX,OAAOC,MAAA,KAAW,cAAcN,KAAA,CAAMK,eAAA,GAAkBL,KAAA,CAAMO,SAAA;AAKzD,SAASC,YAAeC,KAAA,EAAoB;EAE3C,MAAAN,GAAA,GAAMH,KAAA,CAAMC,MAAA,CAAqC;IACrDQ,KAAA;IACAC,IAAA,EAAM;EAAA,CACP;EAEK,MAAAR,OAAA,GAAUC,GAAA,CAAID,OAAA,CAAQO,KAAA;EAK5B,IAAIA,KAAA,KAAUP,OAAA,EAAS;IACrBC,GAAA,CAAID,OAAA,GAAU;MACZO,KAAA;MACAC,IAAA,EAAMR;IACR;EAAA;EAIF,OAAOC,GAAA,CAAID,OAAA,CAAQQ,IAAA;AACrB;AA2BgB,SAAAC,wBACdR,GAAA,EACAS,QAAA,EACAC,2BAAA,GAAwD,CACxD,GAAAC,OAAA,GAAkC,IACL;EAC7B,MAAMC,+BAAA,GAAkCf,KAAA,CAAMC,MAAA,CAC5C,OAAOe,oBAAA,KAAyB,UAClC;EAEM,MAAAC,WAAA,GAAcjB,KAAA,CAAMC,MAAA,CAAoC,IAAI;EAElED,KAAA,CAAMO,SAAA,CAAU,MAAM;IACpB,IACE,CAACJ,GAAA,CAAID,OAAA,IACL,CAACa,+BAAA,CAAgCb,OAAA,IACjCY,OAAA,CAAQI,QAAA,EACR;MACA;IAAA;IAGFD,WAAA,CAAYf,OAAA,GAAU,IAAIc,oBAAA,CAAqB,CAAC,CAACG,KAAK,MAAM;MAC1DP,QAAA,CAASO,KAAK;IAAA,GACbN,2BAA2B;IAElBI,WAAA,CAAAf,OAAA,CAAQkB,OAAA,CAAQjB,GAAA,CAAID,OAAO;IAEvC,OAAO,MAAM;;MACX,CAAAmB,EAAA,GAAAJ,WAAA,CAAYf,OAAA,KAAZ,gBAAAmB,EAAA,CAAqBC,UAAA;IACvB;EAAA,GACC,CAACV,QAAA,EAAUC,2BAAA,EAA6BC,OAAA,CAAQI,QAAA,EAAUf,GAAG,CAAC;EAEjE,OAAOc,WAAA,CAAYf,OAAA;AACrB;AAeO,SAASqB,gBAAmBpB,GAAA,EAA6B;EACxD,MAAAqB,QAAA,GAAWxB,KAAA,CAAMC,MAAA,CAAU,IAAI;EACrCD,KAAA,CAAMyB,mBAAA,CAAoBtB,GAAA,EAAK,MAAMqB,QAAA,CAAStB,OAAA,EAAU,EAAE;EACnD,OAAAsB,QAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}