{"ast":null,"code":"import { __flush } from \"./scheduler.js\";\nclass Store {\n  constructor(initialState, options) {\n    this.listeners = /* @__PURE__ */new Set();\n    this.subscribe = listener => {\n      var _a, _b;\n      this.listeners.add(listener);\n      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);\n      return () => {\n        this.listeners.delete(listener);\n        unsub == null ? void 0 : unsub();\n      };\n    };\n    this.setState = updater => {\n      var _a, _b, _c;\n      this.prevState = this.state;\n      this.state = ((_a = this.options) == null ? void 0 : _a.updateFn) ? this.options.updateFn(this.prevState)(updater) : updater(this.prevState);\n      (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);\n      __flush(this);\n    };\n    this.prevState = initialState;\n    this.state = initialState;\n    this.options = options;\n  }\n}\nexport { Store };","map":{"version":3,"names":["Store","constructor","initialState","options","listeners","Set","subscribe","listener","add","unsub","_b","_a","onSubscribe","call","delete","setState","updater","prevState","state","updateFn","_c","onUpdate","__flush"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/store/src/store.ts"],"sourcesContent":["import { __flush } from './scheduler'\nimport type { AnyUpdater, Listener } from './types'\n\nexport interface StoreOptions<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  /**\n   * Replace the default update function with a custom one.\n   */\n  updateFn?: (previous: TState) => (updater: TUpdater) => TState\n  /**\n   * Called when a listener subscribes to the store.\n   *\n   * @return a function to unsubscribe the listener\n   */\n  onSubscribe?: (\n    listener: Listener<TState>,\n    store: Store<TState, TUpdater>,\n  ) => () => void\n  /**\n   * Called after the state has been updated, used to derive other state.\n   */\n  onUpdate?: () => void\n}\n\nexport class Store<\n  TState,\n  TUpdater extends AnyUpdater = (cb: TState) => TState,\n> {\n  listeners = new Set<Listener<TState>>()\n  state: TState\n  prevState: TState\n  options?: StoreOptions<TState, TUpdater>\n\n  constructor(initialState: TState, options?: StoreOptions<TState, TUpdater>) {\n    this.prevState = initialState\n    this.state = initialState\n    this.options = options\n  }\n\n  subscribe = (listener: Listener<TState>) => {\n    this.listeners.add(listener)\n    const unsub = this.options?.onSubscribe?.(listener, this)\n    return () => {\n      this.listeners.delete(listener)\n      unsub?.()\n    }\n  }\n\n  setState = (updater: TUpdater) => {\n    this.prevState = this.state\n    this.state = this.options?.updateFn\n      ? this.options.updateFn(this.prevState)(updater)\n      : (updater as any)(this.prevState)\n\n    // Always run onUpdate, regardless of batching\n    this.options?.onUpdate?.()\n\n    // Attempt to flush\n    __flush(this as never)\n  }\n}\n"],"mappings":";AA0BO,MAAMA,KAAA,CAGX;EAMAC,YAAYC,YAAA,EAAsBC,OAAA,EAA0C;IAL5E,KAAAC,SAAA,sBAAgBC,GAAA,CAAsB;IAWtC,KAAAC,SAAA,GAAaC,QAAA,IAA+B;;MACrC,KAAAH,SAAA,CAAUI,GAAA,CAAID,QAAQ;MAC3B,MAAME,KAAA,IAAQC,EAAA,IAAAC,EAAA,QAAKR,OAAA,KAAL,gBAAAQ,EAAA,CAAcC,WAAA,KAAd,gBAAAF,EAAA,CAAAG,IAAA,CAAAF,EAAA,EAA4BJ,QAAA,EAAU;MACpD,OAAO,MAAM;QACN,KAAAH,SAAA,CAAUU,MAAA,CAAOP,QAAQ;QACtBE,KAAA,oBAAAA,KAAA;MACV;IACF;IAEA,KAAAM,QAAA,GAAYC,OAAA,IAAsB;;MAChC,KAAKC,SAAA,GAAY,KAAKC,KAAA;MACtB,KAAKA,KAAA,KAAQP,EAAA,QAAKR,OAAA,KAAL,gBAAAQ,EAAA,CAAcQ,QAAA,IACvB,KAAKhB,OAAA,CAAQgB,QAAA,CAAS,KAAKF,SAAS,EAAED,OAAO,IAC5CA,OAAA,CAAgB,KAAKC,SAAS;MAGnC,CAAAG,EAAA,IAAAV,EAAA,QAAKP,OAAA,KAAL,gBAAAO,EAAA,CAAcW,QAAA,KAAd,gBAAAD,EAAA,CAAAP,IAAA,CAAAH,EAAA;MAGAY,OAAA,CAAQ,IAAa;IACvB;IAzBE,KAAKL,SAAA,GAAYf,YAAA;IACjB,KAAKgB,KAAA,GAAQhB,YAAA;IACb,KAAKC,OAAA,GAAUA,OAAA;EAAA;AAwBnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}