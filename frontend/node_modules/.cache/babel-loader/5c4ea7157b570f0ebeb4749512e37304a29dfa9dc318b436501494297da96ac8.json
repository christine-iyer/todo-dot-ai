{"ast":null,"code":"import { Store, batch } from \"@tanstack/store\";\nimport { createMemoryHistory, createBrowserHistory, parseHref } from \"@tanstack/history\";\nimport invariant from \"tiny-invariant\";\nimport { pick, createControlledPromise, deepEqual, replaceEqualDeep, last, functionalUpdate } from \"./utils.js\";\nimport { trimPath, trimPathLeft, parsePathname, resolvePath, cleanPath, trimPathRight, matchPathname, interpolatePath, joinPaths } from \"./path.js\";\nimport { isNotFound } from \"./not-found.js\";\nimport { setupScrollRestoration } from \"./scroll-restoration.js\";\nimport { defaultParseSearch, defaultStringifySearch } from \"./searchParams.js\";\nimport { rootRouteId } from \"./root.js\";\nimport { isResolvedRedirect, isRedirect } from \"./redirect.js\";\nfunction defaultSerializeError(err) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message\n    };\n    if (process.env.NODE_ENV === \"development\") {\n      obj.stack = err.stack;\n    }\n    return obj;\n  }\n  return {\n    data: err\n  };\n}\nfunction getLocationChangeInfo(routerState) {\n  const fromLocation = routerState.resolvedLocation;\n  const toLocation = routerState.location;\n  const pathChanged = (fromLocation == null ? void 0 : fromLocation.pathname) !== toLocation.pathname;\n  const hrefChanged = (fromLocation == null ? void 0 : fromLocation.href) !== toLocation.href;\n  const hashChanged = (fromLocation == null ? void 0 : fromLocation.hash) !== toLocation.hash;\n  return {\n    fromLocation,\n    toLocation,\n    pathChanged,\n    hrefChanged,\n    hashChanged\n  };\n}\nclass RouterCore {\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(options) {\n    this.tempLocationKey = `${Math.round(Math.random() * 1e7)}`;\n    this.resetNextScroll = true;\n    this.shouldViewTransition = void 0;\n    this.isViewTransitionTypesSupported = void 0;\n    this.subscribers = /* @__PURE__ */new Set();\n    this.isScrollRestoring = false;\n    this.isScrollRestorationSetup = false;\n    this.startTransition = fn => fn();\n    this.update = newOptions => {\n      var _a;\n      if (newOptions.notFoundRoute) {\n        console.warn(\"The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.\");\n      }\n      const previousOptions = this.options;\n      this.options = {\n        ...this.options,\n        ...newOptions\n      };\n      this.isServer = this.options.isServer ?? typeof document === \"undefined\";\n      this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(this.options.pathParamsAllowedCharacters.map(char => [encodeURIComponent(char), char])) : void 0;\n      if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {\n        if (newOptions.basepath === void 0 || newOptions.basepath === \"\" || newOptions.basepath === \"/\") {\n          this.basepath = \"/\";\n        } else {\n          this.basepath = `/${trimPath(newOptions.basepath)}`;\n        }\n      }\n      if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      !this.history || this.options.history && this.options.history !== this.history) {\n        this.history = this.options.history ?? (this.isServer ? createMemoryHistory({\n          initialEntries: [this.basepath || \"/\"]\n        }) : createBrowserHistory());\n        this.latestLocation = this.parseLocation();\n      }\n      if (this.options.routeTree !== this.routeTree) {\n        this.routeTree = this.options.routeTree;\n        this.buildRouteTree();\n      }\n      if (!this.__store) {\n        this.__store = new Store(getInitialRouterState(this.latestLocation), {\n          onUpdate: () => {\n            this.__store.state = {\n              ...this.state,\n              cachedMatches: this.state.cachedMatches.filter(d => ![\"redirected\"].includes(d.status))\n            };\n          }\n        });\n        setupScrollRestoration(this);\n      }\n      if (typeof window !== \"undefined\" && \"CSS\" in window &&\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      typeof ((_a = window.CSS) == null ? void 0 : _a.supports) === \"function\") {\n        this.isViewTransitionTypesSupported = window.CSS.supports(\"selector(:active-view-transition-type(a)\");\n      }\n    };\n    this.buildRouteTree = () => {\n      this.routesById = {};\n      this.routesByPath = {};\n      const notFoundRoute = this.options.notFoundRoute;\n      if (notFoundRoute) {\n        notFoundRoute.init({\n          originalIndex: 99999999999,\n          defaultSsr: this.options.defaultSsr\n        });\n        this.routesById[notFoundRoute.id] = notFoundRoute;\n      }\n      const recurseRoutes = childRoutes => {\n        childRoutes.forEach((childRoute, i) => {\n          childRoute.init({\n            originalIndex: i,\n            defaultSsr: this.options.defaultSsr\n          });\n          const existingRoute = this.routesById[childRoute.id];\n          invariant(!existingRoute, `Duplicate routes found with id: ${String(childRoute.id)}`);\n          this.routesById[childRoute.id] = childRoute;\n          if (!childRoute.isRoot && childRoute.path) {\n            const trimmedFullPath = trimPathRight(childRoute.fullPath);\n            if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith(\"/\")) {\n              this.routesByPath[trimmedFullPath] = childRoute;\n            }\n          }\n          const children = childRoute.children;\n          if (children == null ? void 0 : children.length) {\n            recurseRoutes(children);\n          }\n        });\n      };\n      recurseRoutes([this.routeTree]);\n      const scoredRoutes = [];\n      const routes = Object.values(this.routesById);\n      routes.forEach((d, i) => {\n        var _a;\n        if (d.isRoot || !d.path) {\n          return;\n        }\n        const trimmed = trimPathLeft(d.fullPath);\n        const parsed = parsePathname(trimmed);\n        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === \"/\") {\n          parsed.shift();\n        }\n        const scores = parsed.map(segment => {\n          if (segment.value === \"/\") {\n            return 0.75;\n          }\n          if (segment.type === \"param\") {\n            return 0.5;\n          }\n          if (segment.type === \"wildcard\") {\n            return 0.25;\n          }\n          return 1;\n        });\n        scoredRoutes.push({\n          child: d,\n          trimmed,\n          parsed,\n          index: i,\n          scores\n        });\n      });\n      this.flatRoutes = scoredRoutes.sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length);\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i] - a.scores[i];\n          }\n        }\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length;\n        }\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i].value !== b.parsed[i].value) {\n            return a.parsed[i].value > b.parsed[i].value ? 1 : -1;\n          }\n        }\n        return a.index - b.index;\n      }).map((d, i) => {\n        d.child.rank = i;\n        return d.child;\n      });\n    };\n    this.subscribe = (eventType, fn) => {\n      const listener = {\n        eventType,\n        fn\n      };\n      this.subscribers.add(listener);\n      return () => {\n        this.subscribers.delete(listener);\n      };\n    };\n    this.emit = routerEvent => {\n      this.subscribers.forEach(listener => {\n        if (listener.eventType === routerEvent.type) {\n          listener.fn(routerEvent);\n        }\n      });\n    };\n    this.parseLocation = (previousLocation, locationToParse) => {\n      const parse = ({\n        pathname,\n        search,\n        hash,\n        state\n      }) => {\n        const parsedSearch = this.options.parseSearch(search);\n        const searchStr = this.options.stringifySearch(parsedSearch);\n        return {\n          pathname,\n          searchStr,\n          search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),\n          hash: hash.split(\"#\").reverse()[0] ?? \"\",\n          href: `${pathname}${searchStr}${hash}`,\n          state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)\n        };\n      };\n      const location = parse(locationToParse ?? this.history.location);\n      const {\n        __tempLocation,\n        __tempKey\n      } = location.state;\n      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n        const parsedTempLocation = parse(__tempLocation);\n        parsedTempLocation.state.key = location.state.key;\n        delete parsedTempLocation.state.__tempLocation;\n        return {\n          ...parsedTempLocation,\n          maskedLocation: location\n        };\n      }\n      return location;\n    };\n    this.resolvePathWithBase = (from, path) => {\n      const resolvedPath = resolvePath({\n        basepath: this.basepath,\n        base: from,\n        to: cleanPath(path),\n        trailingSlash: this.options.trailingSlash,\n        caseSensitive: this.options.caseSensitive\n      });\n      return resolvedPath;\n    };\n    this.matchRoutes = (pathnameOrNext, locationSearchOrOpts, opts) => {\n      if (typeof pathnameOrNext === \"string\") {\n        return this.matchRoutesInternal({\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts\n        }, opts);\n      } else {\n        return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);\n      }\n    };\n    this.getMatchedRoutes = (next, dest) => {\n      let routeParams = {};\n      const trimmedPath = trimPathRight(next.pathname);\n      const getMatchedParams = route => {\n        const result = matchPathname(this.basepath, trimmedPath, {\n          to: route.fullPath,\n          caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,\n          fuzzy: true\n        });\n        return result;\n      };\n      let foundRoute = (dest == null ? void 0 : dest.to) !== void 0 ? this.routesByPath[dest.to] : void 0;\n      if (foundRoute) {\n        routeParams = getMatchedParams(foundRoute);\n      } else {\n        foundRoute = this.flatRoutes.find(route => {\n          const matchedParams = getMatchedParams(route);\n          if (matchedParams) {\n            routeParams = matchedParams;\n            return true;\n          }\n          return false;\n        });\n      }\n      let routeCursor = foundRoute || this.routesById[rootRouteId];\n      const matchedRoutes = [routeCursor];\n      while (routeCursor.parentRoute) {\n        routeCursor = routeCursor.parentRoute;\n        matchedRoutes.unshift(routeCursor);\n      }\n      return {\n        matchedRoutes,\n        routeParams,\n        foundRoute\n      };\n    };\n    this.cancelMatch = id => {\n      const match = this.getMatch(id);\n      if (!match) return;\n      match.abortController.abort();\n      clearTimeout(match.pendingTimeout);\n    };\n    this.cancelMatches = () => {\n      var _a;\n      (_a = this.state.pendingMatches) == null ? void 0 : _a.forEach(match => {\n        this.cancelMatch(match.id);\n      });\n    };\n    this.buildLocation = opts => {\n      const build = (dest = {}, matchedRoutesResult) => {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const fromMatches = dest._fromLocation ? this.matchRoutes(dest._fromLocation, {\n          _buildLocation: true\n        }) : this.state.matches;\n        const fromMatch = dest.from != null ? fromMatches.find(d => matchPathname(this.basepath, trimPathRight(d.pathname), {\n          to: dest.from,\n          caseSensitive: false,\n          fuzzy: false\n        })) : void 0;\n        const fromPath = (fromMatch == null ? void 0 : fromMatch.pathname) || this.latestLocation.pathname;\n        invariant(dest.from == null || fromMatch != null, \"Could not find match for from: \" + dest.from);\n        const fromSearch = ((_a = this.state.pendingMatches) == null ? void 0 : _a.length) ? (_b = last(this.state.pendingMatches)) == null ? void 0 : _b.search : ((_c = last(fromMatches)) == null ? void 0 : _c.search) || this.latestLocation.search;\n        const stayingMatches = matchedRoutesResult == null ? void 0 : matchedRoutesResult.matchedRoutes.filter(d => fromMatches.find(e => e.routeId === d.id));\n        let pathname;\n        if (dest.to) {\n          const resolvePathTo = (fromMatch == null ? void 0 : fromMatch.fullPath) || ((_d = last(fromMatches)) == null ? void 0 : _d.fullPath) || this.latestLocation.pathname;\n          pathname = this.resolvePathWithBase(resolvePathTo, `${dest.to}`);\n        } else {\n          const fromRouteByFromPathRouteId = this.routesById[(_e = stayingMatches == null ? void 0 : stayingMatches.find(route => {\n            const interpolatedPath = interpolatePath({\n              path: route.fullPath,\n              params: (matchedRoutesResult == null ? void 0 : matchedRoutesResult.routeParams) ?? {},\n              decodeCharMap: this.pathParamsDecodeCharMap\n            }).interpolatedPath;\n            const pathname2 = joinPaths([this.basepath, interpolatedPath]);\n            return pathname2 === fromPath;\n          })) == null ? void 0 : _e.id];\n          pathname = this.resolvePathWithBase(fromPath, (fromRouteByFromPathRouteId == null ? void 0 : fromRouteByFromPathRouteId.to) ?? fromPath);\n        }\n        const prevParams = {\n          ...((_f = last(fromMatches)) == null ? void 0 : _f.params)\n        };\n        let nextParams = (dest.params ?? true) === true ? prevParams : {\n          ...prevParams,\n          ...functionalUpdate(dest.params, prevParams)\n        };\n        if (Object.keys(nextParams).length > 0) {\n          matchedRoutesResult == null ? void 0 : matchedRoutesResult.matchedRoutes.map(route => {\n            var _a2;\n            return ((_a2 = route.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;\n          }).filter(Boolean).forEach(fn => {\n            nextParams = {\n              ...nextParams,\n              ...fn(nextParams)\n            };\n          });\n        }\n        pathname = interpolatePath({\n          path: pathname,\n          params: nextParams ?? {},\n          leaveWildcards: false,\n          leaveParams: opts.leaveParams,\n          decodeCharMap: this.pathParamsDecodeCharMap\n        }).interpolatedPath;\n        let search = fromSearch;\n        if (opts._includeValidateSearch && ((_g = this.options.search) == null ? void 0 : _g.strict)) {\n          let validatedSearch = {};\n          matchedRoutesResult == null ? void 0 : matchedRoutesResult.matchedRoutes.forEach(route => {\n            try {\n              if (route.options.validateSearch) {\n                validatedSearch = {\n                  ...validatedSearch,\n                  ...(validateSearch(route.options.validateSearch, {\n                    ...validatedSearch,\n                    ...search\n                  }) ?? {})\n                };\n              }\n            } catch {}\n          });\n          search = validatedSearch;\n        }\n        const applyMiddlewares = search2 => {\n          const allMiddlewares = (matchedRoutesResult == null ? void 0 : matchedRoutesResult.matchedRoutes.reduce((acc, route) => {\n            var _a2;\n            const middlewares = [];\n            if (\"search\" in route.options) {\n              if ((_a2 = route.options.search) == null ? void 0 : _a2.middlewares) {\n                middlewares.push(...route.options.search.middlewares);\n              }\n            } else if (route.options.preSearchFilters || route.options.postSearchFilters) {\n              const legacyMiddleware = ({\n                search: search3,\n                next\n              }) => {\n                let nextSearch = search3;\n                if (\"preSearchFilters\" in route.options && route.options.preSearchFilters) {\n                  nextSearch = route.options.preSearchFilters.reduce((prev, next2) => next2(prev), search3);\n                }\n                const result = next(nextSearch);\n                if (\"postSearchFilters\" in route.options && route.options.postSearchFilters) {\n                  return route.options.postSearchFilters.reduce((prev, next2) => next2(prev), result);\n                }\n                return result;\n              };\n              middlewares.push(legacyMiddleware);\n            }\n            if (opts._includeValidateSearch && route.options.validateSearch) {\n              const validate = ({\n                search: search3,\n                next\n              }) => {\n                const result = next(search3);\n                try {\n                  const validatedSearch = {\n                    ...result,\n                    ...(validateSearch(route.options.validateSearch, result) ?? {})\n                  };\n                  return validatedSearch;\n                } catch {\n                  return result;\n                }\n              };\n              middlewares.push(validate);\n            }\n            return acc.concat(middlewares);\n          }, [])) ?? [];\n          const final = ({\n            search: search3\n          }) => {\n            if (!dest.search) {\n              return {};\n            }\n            if (dest.search === true) {\n              return search3;\n            }\n            return functionalUpdate(dest.search, search3);\n          };\n          allMiddlewares.push(final);\n          const applyNext = (index, currentSearch) => {\n            if (index >= allMiddlewares.length) {\n              return currentSearch;\n            }\n            const middleware = allMiddlewares[index];\n            const next = newSearch => {\n              return applyNext(index + 1, newSearch);\n            };\n            return middleware({\n              search: currentSearch,\n              next\n            });\n          };\n          return applyNext(0, search2);\n        };\n        search = applyMiddlewares(search);\n        search = replaceEqualDeep(fromSearch, search);\n        const searchStr = this.options.stringifySearch(search);\n        const hash = dest.hash === true ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0;\n        const hashStr = hash ? `#${hash}` : \"\";\n        let nextState = dest.state === true ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};\n        nextState = replaceEqualDeep(this.latestLocation.state, nextState);\n        return {\n          pathname,\n          search,\n          searchStr,\n          state: nextState,\n          hash: hash ?? \"\",\n          href: `${pathname}${searchStr}${hashStr}`,\n          unmaskOnReload: dest.unmaskOnReload\n        };\n      };\n      const buildWithMatches = (dest = {}, maskedDest) => {\n        var _a;\n        const next = build(dest);\n        let maskedNext = maskedDest ? build(maskedDest) : void 0;\n        if (!maskedNext) {\n          let params = {};\n          const foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find(d => {\n            const match = matchPathname(this.basepath, next.pathname, {\n              to: d.from,\n              caseSensitive: false,\n              fuzzy: false\n            });\n            if (match) {\n              params = match;\n              return true;\n            }\n            return false;\n          });\n          if (foundMask) {\n            const {\n              from: _from,\n              ...maskProps\n            } = foundMask;\n            maskedDest = {\n              ...pick(opts, [\"from\"]),\n              ...maskProps,\n              params\n            };\n            maskedNext = build(maskedDest);\n          }\n        }\n        const nextMatches = this.getMatchedRoutes(next, dest);\n        const final = build(dest, nextMatches);\n        if (maskedNext) {\n          const maskedMatches = this.getMatchedRoutes(maskedNext, maskedDest);\n          const maskedFinal = build(maskedDest, maskedMatches);\n          final.maskedLocation = maskedFinal;\n        }\n        return final;\n      };\n      if (opts.mask) {\n        return buildWithMatches(opts, {\n          ...pick(opts, [\"from\"]),\n          ...opts.mask\n        });\n      }\n      return buildWithMatches(opts);\n    };\n    this.commitLocation = ({\n      viewTransition,\n      ignoreBlocker,\n      ...next\n    }) => {\n      const isSameState = () => {\n        const ignoredProps = [\"key\", \"__TSR_index\", \"__hashScrollIntoViewOptions\"];\n        ignoredProps.forEach(prop => {\n          next.state[prop] = this.latestLocation.state[prop];\n        });\n        const isEqual = deepEqual(next.state, this.latestLocation.state);\n        ignoredProps.forEach(prop => {\n          delete next.state[prop];\n        });\n        return isEqual;\n      };\n      const isSameUrl = this.latestLocation.href === next.href;\n      const previousCommitPromise = this.commitLocationPromise;\n      this.commitLocationPromise = createControlledPromise(() => {\n        previousCommitPromise == null ? void 0 : previousCommitPromise.resolve();\n      });\n      if (isSameUrl && isSameState()) {\n        this.load();\n      } else {\n        let {\n          maskedLocation,\n          hashScrollIntoView,\n          ...nextHistory\n        } = next;\n        if (maskedLocation) {\n          nextHistory = {\n            ...maskedLocation,\n            state: {\n              ...maskedLocation.state,\n              __tempKey: void 0,\n              __tempLocation: {\n                ...nextHistory,\n                search: nextHistory.searchStr,\n                state: {\n                  ...nextHistory.state,\n                  __tempKey: void 0,\n                  __tempLocation: void 0,\n                  key: void 0\n                }\n              }\n            }\n          };\n          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {\n            nextHistory.state.__tempKey = this.tempLocationKey;\n          }\n        }\n        nextHistory.state.__hashScrollIntoViewOptions = hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true;\n        this.shouldViewTransition = viewTransition;\n        this.history[next.replace ? \"replace\" : \"push\"](nextHistory.href, nextHistory.state, {\n          ignoreBlocker\n        });\n      }\n      this.resetNextScroll = next.resetScroll ?? true;\n      if (!this.history.subscribers.size) {\n        this.load();\n      }\n      return this.commitLocationPromise;\n    };\n    this.buildAndCommitLocation = ({\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      viewTransition,\n      ignoreBlocker,\n      href,\n      ...rest\n    } = {}) => {\n      if (href) {\n        const currentIndex = this.history.location.state.__TSR_index;\n        const parsed = parseHref(href, {\n          __TSR_index: replace ? currentIndex : currentIndex + 1\n        });\n        rest.to = parsed.pathname;\n        rest.search = this.options.parseSearch(parsed.search);\n        rest.hash = parsed.hash.slice(1);\n      }\n      const location = this.buildLocation({\n        ...rest,\n        _includeValidateSearch: true\n      });\n      return this.commitLocation({\n        ...location,\n        viewTransition,\n        replace,\n        resetScroll,\n        hashScrollIntoView,\n        ignoreBlocker\n      });\n    };\n    this.navigate = ({\n      to,\n      reloadDocument,\n      href,\n      ...rest\n    }) => {\n      if (reloadDocument) {\n        if (!href) {\n          const location = this.buildLocation({\n            to,\n            ...rest\n          });\n          href = this.history.createHref(location.href);\n        }\n        if (rest.replace) {\n          window.location.replace(href);\n        } else {\n          window.location.href = href;\n        }\n        return;\n      }\n      return this.buildAndCommitLocation({\n        ...rest,\n        href,\n        to\n      });\n    };\n    this.load = async opts => {\n      this.latestLocation = this.parseLocation(this.latestLocation);\n      let redirect;\n      let notFound;\n      let loadPromise;\n      loadPromise = new Promise(resolve => {\n        this.startTransition(async () => {\n          var _a;\n          try {\n            const next = this.latestLocation;\n            const prevLocation = this.state.resolvedLocation;\n            this.cancelMatches();\n            let pendingMatches;\n            batch(() => {\n              pendingMatches = this.matchRoutes(next);\n              this.__store.setState(s => ({\n                ...s,\n                status: \"pending\",\n                isLoading: true,\n                location: next,\n                pendingMatches,\n                // If a cached moved to pendingMatches, remove it from cachedMatches\n                cachedMatches: s.cachedMatches.filter(d => {\n                  return !pendingMatches.find(e => e.id === d.id);\n                })\n              }));\n            });\n            if (!this.state.redirect) {\n              this.emit({\n                type: \"onBeforeNavigate\",\n                ...getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next\n                })\n              });\n            }\n            this.emit({\n              type: \"onBeforeLoad\",\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next\n              })\n            });\n            await this.loadMatches({\n              sync: opts == null ? void 0 : opts.sync,\n              matches: pendingMatches,\n              location: next,\n              // eslint-disable-next-line @typescript-eslint/require-await\n              onReady: async () => {\n                this.startViewTransition(async () => {\n                  let exitingMatches;\n                  let enteringMatches;\n                  let stayingMatches;\n                  batch(() => {\n                    this.__store.setState(s => {\n                      const previousMatches = s.matches;\n                      const newMatches = s.pendingMatches || s.matches;\n                      exitingMatches = previousMatches.filter(match => !newMatches.find(d => d.id === match.id));\n                      enteringMatches = newMatches.filter(match => !previousMatches.find(d => d.id === match.id));\n                      stayingMatches = previousMatches.filter(match => newMatches.find(d => d.id === match.id));\n                      return {\n                        ...s,\n                        isLoading: false,\n                        loadedAt: Date.now(),\n                        matches: newMatches,\n                        pendingMatches: void 0,\n                        cachedMatches: [...s.cachedMatches, ...exitingMatches.filter(d => d.status !== \"error\")]\n                      };\n                    });\n                    this.clearExpiredCache();\n                  });\n                  [[exitingMatches, \"onLeave\"], [enteringMatches, \"onEnter\"], [stayingMatches, \"onStay\"]].forEach(([matches, hook]) => {\n                    matches.forEach(match => {\n                      var _a2, _b;\n                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b.call(_a2, match);\n                    });\n                  });\n                });\n              }\n            });\n          } catch (err) {\n            if (isResolvedRedirect(err)) {\n              redirect = err;\n              if (!this.isServer) {\n                this.navigate({\n                  ...redirect,\n                  replace: true,\n                  ignoreBlocker: true\n                });\n              }\n            } else if (isNotFound(err)) {\n              notFound = err;\n            }\n            this.__store.setState(s => ({\n              ...s,\n              statusCode: redirect ? redirect.statusCode : notFound ? 404 : s.matches.some(d => d.status === \"error\") ? 500 : 200,\n              redirect\n            }));\n          }\n          if (this.latestLoadPromise === loadPromise) {\n            (_a = this.commitLocationPromise) == null ? void 0 : _a.resolve();\n            this.latestLoadPromise = void 0;\n            this.commitLocationPromise = void 0;\n          }\n          resolve();\n        });\n      });\n      this.latestLoadPromise = loadPromise;\n      await loadPromise;\n      while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {\n        await this.latestLoadPromise;\n      }\n      if (this.hasNotFoundMatch()) {\n        this.__store.setState(s => ({\n          ...s,\n          statusCode: 404\n        }));\n      }\n    };\n    this.startViewTransition = fn => {\n      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;\n      delete this.shouldViewTransition;\n      if (shouldViewTransition && typeof document !== \"undefined\" && \"startViewTransition\" in document && typeof document.startViewTransition === \"function\") {\n        let startViewTransitionParams;\n        if (typeof shouldViewTransition === \"object\" && this.isViewTransitionTypesSupported) {\n          const next = this.latestLocation;\n          const prevLocation = this.state.resolvedLocation;\n          const resolvedViewTransitionTypes = typeof shouldViewTransition.types === \"function\" ? shouldViewTransition.types(getLocationChangeInfo({\n            resolvedLocation: prevLocation,\n            location: next\n          })) : shouldViewTransition.types;\n          startViewTransitionParams = {\n            update: fn,\n            types: resolvedViewTransitionTypes\n          };\n        } else {\n          startViewTransitionParams = fn;\n        }\n        document.startViewTransition(startViewTransitionParams);\n      } else {\n        fn();\n      }\n    };\n    this.updateMatch = (id, updater) => {\n      var _a;\n      let updated;\n      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find(d => d.id === id);\n      const isMatched = this.state.matches.find(d => d.id === id);\n      const isCached = this.state.cachedMatches.find(d => d.id === id);\n      const matchesKey = isPending ? \"pendingMatches\" : isMatched ? \"matches\" : isCached ? \"cachedMatches\" : \"\";\n      if (matchesKey) {\n        this.__store.setState(s => {\n          var _a2;\n          return {\n            ...s,\n            [matchesKey]: (_a2 = s[matchesKey]) == null ? void 0 : _a2.map(d => d.id === id ? updated = updater(d) : d)\n          };\n        });\n      }\n      return updated;\n    };\n    this.getMatch = matchId => {\n      return [...this.state.cachedMatches, ...(this.state.pendingMatches ?? []), ...this.state.matches].find(d => d.id === matchId);\n    };\n    this.loadMatches = async ({\n      location,\n      matches,\n      preload: allPreload,\n      onReady,\n      updateMatch = this.updateMatch,\n      sync\n    }) => {\n      let firstBadMatchIndex;\n      let rendered = false;\n      const triggerOnReady = async () => {\n        if (!rendered) {\n          rendered = true;\n          await (onReady == null ? void 0 : onReady());\n        }\n      };\n      const resolvePreload = matchId => {\n        return !!(allPreload && !this.state.matches.find(d => d.id === matchId));\n      };\n      const handleRedirectAndNotFound = (match, err) => {\n        var _a, _b, _c, _d;\n        if (isResolvedRedirect(err)) {\n          if (!err.reloadDocument) {\n            throw err;\n          }\n        }\n        if (isRedirect(err) || isNotFound(err)) {\n          updateMatch(match.id, prev => ({\n            ...prev,\n            status: isRedirect(err) ? \"redirected\" : isNotFound(err) ? \"notFound\" : \"error\",\n            isFetching: false,\n            error: err,\n            beforeLoadPromise: void 0,\n            loaderPromise: void 0\n          }));\n          if (!err.routeId) {\n            err.routeId = match.routeId;\n          }\n          (_a = match.beforeLoadPromise) == null ? void 0 : _a.resolve();\n          (_b = match.loaderPromise) == null ? void 0 : _b.resolve();\n          (_c = match.loadPromise) == null ? void 0 : _c.resolve();\n          if (isRedirect(err)) {\n            rendered = true;\n            err = this.resolveRedirect({\n              ...err,\n              _fromLocation: location\n            });\n            throw err;\n          } else if (isNotFound(err)) {\n            this._handleNotFound(matches, err, {\n              updateMatch\n            });\n            (_d = this.serverSsr) == null ? void 0 : _d.onMatchSettled({\n              router: this,\n              match: this.getMatch(match.id)\n            });\n            throw err;\n          }\n        }\n      };\n      try {\n        await new Promise((resolveAll, rejectAll) => {\n          ;\n          (async () => {\n            var _a, _b, _c, _d;\n            try {\n              const handleSerialError = (index, err, routerCode) => {\n                var _a2, _b2;\n                const {\n                  id: matchId,\n                  routeId\n                } = matches[index];\n                const route = this.looseRoutesById[routeId];\n                if (err instanceof Promise) {\n                  throw err;\n                }\n                err.routerCode = routerCode;\n                firstBadMatchIndex = firstBadMatchIndex ?? index;\n                handleRedirectAndNotFound(this.getMatch(matchId), err);\n                try {\n                  (_b2 = (_a2 = route.options).onError) == null ? void 0 : _b2.call(_a2, err);\n                } catch (errorHandlerErr) {\n                  err = errorHandlerErr;\n                  handleRedirectAndNotFound(this.getMatch(matchId), err);\n                }\n                updateMatch(matchId, prev => {\n                  var _a3, _b3;\n                  (_a3 = prev.beforeLoadPromise) == null ? void 0 : _a3.resolve();\n                  (_b3 = prev.loadPromise) == null ? void 0 : _b3.resolve();\n                  return {\n                    ...prev,\n                    error: err,\n                    status: \"error\",\n                    isFetching: false,\n                    updatedAt: Date.now(),\n                    abortController: new AbortController(),\n                    beforeLoadPromise: void 0\n                  };\n                });\n              };\n              for (const [index, {\n                id: matchId,\n                routeId\n              }] of matches.entries()) {\n                const existingMatch = this.getMatch(matchId);\n                const parentMatchId = (_a = matches[index - 1]) == null ? void 0 : _a.id;\n                const route = this.looseRoutesById[routeId];\n                const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;\n                const shouldPending = !!(onReady && !this.isServer && !resolvePreload(matchId) && (route.options.loader || route.options.beforeLoad || routeNeedsPreload(route)) && typeof pendingMs === \"number\" && pendingMs !== Infinity && (route.options.pendingComponent ?? ((_b = this.options) == null ? void 0 : _b.defaultPendingComponent)));\n                let executeBeforeLoad = true;\n                if (\n                // If we are in the middle of a load, either of these will be present\n                // (not to be confused with `loadPromise`, which is always defined)\n                existingMatch.beforeLoadPromise || existingMatch.loaderPromise) {\n                  if (shouldPending) {\n                    setTimeout(() => {\n                      try {\n                        triggerOnReady();\n                      } catch {}\n                    }, pendingMs);\n                  }\n                  await existingMatch.beforeLoadPromise;\n                  executeBeforeLoad = this.getMatch(matchId).status !== \"success\";\n                }\n                if (executeBeforeLoad) {\n                  try {\n                    updateMatch(matchId, prev => {\n                      const prevLoadPromise = prev.loadPromise;\n                      return {\n                        ...prev,\n                        loadPromise: createControlledPromise(() => {\n                          prevLoadPromise == null ? void 0 : prevLoadPromise.resolve();\n                        }),\n                        beforeLoadPromise: createControlledPromise()\n                      };\n                    });\n                    const abortController = new AbortController();\n                    let pendingTimeout;\n                    if (shouldPending) {\n                      pendingTimeout = setTimeout(() => {\n                        try {\n                          triggerOnReady();\n                        } catch {}\n                      }, pendingMs);\n                    }\n                    const {\n                      paramsError,\n                      searchError\n                    } = this.getMatch(matchId);\n                    if (paramsError) {\n                      handleSerialError(index, paramsError, \"PARSE_PARAMS\");\n                    }\n                    if (searchError) {\n                      handleSerialError(index, searchError, \"VALIDATE_SEARCH\");\n                    }\n                    const getParentMatchContext = () => parentMatchId ? this.getMatch(parentMatchId).context : this.options.context ?? {};\n                    updateMatch(matchId, prev => ({\n                      ...prev,\n                      isFetching: \"beforeLoad\",\n                      fetchCount: prev.fetchCount + 1,\n                      abortController,\n                      pendingTimeout,\n                      context: {\n                        ...getParentMatchContext(),\n                        ...prev.__routeContext\n                      }\n                    }));\n                    const {\n                      search,\n                      params,\n                      context,\n                      cause\n                    } = this.getMatch(matchId);\n                    const preload = resolvePreload(matchId);\n                    const beforeLoadFnContext = {\n                      search,\n                      abortController,\n                      params,\n                      preload,\n                      context,\n                      location,\n                      navigate: opts => this.navigate({\n                        ...opts,\n                        _fromLocation: location\n                      }),\n                      buildLocation: this.buildLocation,\n                      cause: preload ? \"preload\" : cause,\n                      matches\n                    };\n                    const beforeLoadContext = (await ((_d = (_c = route.options).beforeLoad) == null ? void 0 : _d.call(_c, beforeLoadFnContext))) ?? {};\n                    if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {\n                      handleSerialError(index, beforeLoadContext, \"BEFORE_LOAD\");\n                    }\n                    updateMatch(matchId, prev => {\n                      return {\n                        ...prev,\n                        __beforeLoadContext: beforeLoadContext,\n                        context: {\n                          ...getParentMatchContext(),\n                          ...prev.__routeContext,\n                          ...beforeLoadContext\n                        },\n                        abortController\n                      };\n                    });\n                  } catch (err) {\n                    handleSerialError(index, err, \"BEFORE_LOAD\");\n                  }\n                  updateMatch(matchId, prev => {\n                    var _a2;\n                    (_a2 = prev.beforeLoadPromise) == null ? void 0 : _a2.resolve();\n                    return {\n                      ...prev,\n                      beforeLoadPromise: void 0,\n                      isFetching: false\n                    };\n                  });\n                }\n              }\n              const validResolvedMatches = matches.slice(0, firstBadMatchIndex);\n              const matchPromises = [];\n              validResolvedMatches.forEach(({\n                id: matchId,\n                routeId\n              }, index) => {\n                matchPromises.push((async () => {\n                  const {\n                    loaderPromise: prevLoaderPromise\n                  } = this.getMatch(matchId);\n                  let loaderShouldRunAsync = false;\n                  let loaderIsRunningAsync = false;\n                  if (prevLoaderPromise) {\n                    await prevLoaderPromise;\n                    const match = this.getMatch(matchId);\n                    if (match.error) {\n                      handleRedirectAndNotFound(match, match.error);\n                    }\n                  } else {\n                    const parentMatchPromise = matchPromises[index - 1];\n                    const route = this.looseRoutesById[routeId];\n                    const getLoaderContext = () => {\n                      const {\n                        params,\n                        loaderDeps,\n                        abortController,\n                        context,\n                        cause\n                      } = this.getMatch(matchId);\n                      const preload2 = resolvePreload(matchId);\n                      return {\n                        params,\n                        deps: loaderDeps,\n                        preload: !!preload2,\n                        parentMatchPromise,\n                        abortController,\n                        context,\n                        location,\n                        navigate: opts => this.navigate({\n                          ...opts,\n                          _fromLocation: location\n                        }),\n                        cause: preload2 ? \"preload\" : cause,\n                        route\n                      };\n                    };\n                    const age = Date.now() - this.getMatch(matchId).updatedAt;\n                    const preload = resolvePreload(matchId);\n                    const staleAge = preload ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;\n                    const shouldReloadOption = route.options.shouldReload;\n                    const shouldReload = typeof shouldReloadOption === \"function\" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;\n                    updateMatch(matchId, prev => ({\n                      ...prev,\n                      loaderPromise: createControlledPromise(),\n                      preload: !!preload && !this.state.matches.find(d => d.id === matchId)\n                    }));\n                    const runLoader = async () => {\n                      var _a2, _b2, _c2, _d2, _e, _f, _g, _h, _i, _j, _k;\n                      try {\n                        const potentialPendingMinPromise = async () => {\n                          const latestMatch = this.getMatch(matchId);\n                          if (latestMatch.minPendingPromise) {\n                            await latestMatch.minPendingPromise;\n                          }\n                        };\n                        try {\n                          this.loadRouteChunk(route);\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            isFetching: \"loader\"\n                          }));\n                          const loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));\n                          handleRedirectAndNotFound(this.getMatch(matchId), loaderData);\n                          await route._lazyPromise;\n                          await potentialPendingMinPromise();\n                          const assetContext = {\n                            matches,\n                            match: this.getMatch(matchId),\n                            params: this.getMatch(matchId).params,\n                            loaderData\n                          };\n                          const headFnContent = (_d2 = (_c2 = route.options).head) == null ? void 0 : _d2.call(_c2, assetContext);\n                          const meta = headFnContent == null ? void 0 : headFnContent.meta;\n                          const links = headFnContent == null ? void 0 : headFnContent.links;\n                          const headScripts = headFnContent == null ? void 0 : headFnContent.scripts;\n                          const scripts = (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e, assetContext);\n                          const headers = (_h = (_g = route.options).headers) == null ? void 0 : _h.call(_g, {\n                            loaderData\n                          });\n                          await route._componentsPromise;\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            error: void 0,\n                            status: \"success\",\n                            isFetching: false,\n                            updatedAt: Date.now(),\n                            loaderData,\n                            meta,\n                            links,\n                            headScripts,\n                            headers,\n                            scripts\n                          }));\n                        } catch (e) {\n                          let error = e;\n                          await potentialPendingMinPromise();\n                          handleRedirectAndNotFound(this.getMatch(matchId), e);\n                          try {\n                            (_j = (_i = route.options).onError) == null ? void 0 : _j.call(_i, e);\n                          } catch (onErrorError) {\n                            error = onErrorError;\n                            handleRedirectAndNotFound(this.getMatch(matchId), onErrorError);\n                          }\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            error,\n                            status: \"error\",\n                            isFetching: false\n                          }));\n                        }\n                        (_k = this.serverSsr) == null ? void 0 : _k.onMatchSettled({\n                          router: this,\n                          match: this.getMatch(matchId)\n                        });\n                      } catch (err) {\n                        updateMatch(matchId, prev => ({\n                          ...prev,\n                          loaderPromise: void 0\n                        }));\n                        handleRedirectAndNotFound(this.getMatch(matchId), err);\n                      }\n                    };\n                    const {\n                      status,\n                      invalid\n                    } = this.getMatch(matchId);\n                    loaderShouldRunAsync = status === \"success\" && (invalid || (shouldReload ?? age > staleAge));\n                    if (preload && route.options.preload === false) {} else if (loaderShouldRunAsync && !sync) {\n                      loaderIsRunningAsync = true;\n                      (async () => {\n                        try {\n                          await runLoader();\n                          const {\n                            loaderPromise,\n                            loadPromise\n                          } = this.getMatch(matchId);\n                          loaderPromise == null ? void 0 : loaderPromise.resolve();\n                          loadPromise == null ? void 0 : loadPromise.resolve();\n                          updateMatch(matchId, prev => ({\n                            ...prev,\n                            loaderPromise: void 0\n                          }));\n                        } catch (err) {\n                          if (isResolvedRedirect(err)) {\n                            await this.navigate(err);\n                          }\n                        }\n                      })();\n                    } else if (status !== \"success\" || loaderShouldRunAsync && sync) {\n                      await runLoader();\n                    }\n                  }\n                  if (!loaderIsRunningAsync) {\n                    const {\n                      loaderPromise,\n                      loadPromise\n                    } = this.getMatch(matchId);\n                    loaderPromise == null ? void 0 : loaderPromise.resolve();\n                    loadPromise == null ? void 0 : loadPromise.resolve();\n                  }\n                  updateMatch(matchId, prev => ({\n                    ...prev,\n                    isFetching: loaderIsRunningAsync ? prev.isFetching : false,\n                    loaderPromise: loaderIsRunningAsync ? prev.loaderPromise : void 0,\n                    invalid: false\n                  }));\n                  return this.getMatch(matchId);\n                })());\n              });\n              await Promise.all(matchPromises);\n              resolveAll();\n            } catch (err) {\n              rejectAll(err);\n            }\n          })();\n        });\n        await triggerOnReady();\n      } catch (err) {\n        if (isRedirect(err) || isNotFound(err)) {\n          if (isNotFound(err) && !allPreload) {\n            await triggerOnReady();\n          }\n          throw err;\n        }\n      }\n      return matches;\n    };\n    this.invalidate = opts => {\n      const invalidate = d => {\n        var _a;\n        if (((_a = opts == null ? void 0 : opts.filter) == null ? void 0 : _a.call(opts, d)) ?? true) {\n          return {\n            ...d,\n            invalid: true,\n            ...(d.status === \"error\" ? {\n              status: \"pending\",\n              error: void 0\n            } : {})\n          };\n        }\n        return d;\n      };\n      this.__store.setState(s => {\n        var _a;\n        return {\n          ...s,\n          matches: s.matches.map(invalidate),\n          cachedMatches: s.cachedMatches.map(invalidate),\n          pendingMatches: (_a = s.pendingMatches) == null ? void 0 : _a.map(invalidate)\n        };\n      });\n      return this.load({\n        sync: opts == null ? void 0 : opts.sync\n      });\n    };\n    this.resolveRedirect = err => {\n      const redirect = err;\n      if (!redirect.href) {\n        redirect.href = this.buildLocation(redirect).href;\n      }\n      return redirect;\n    };\n    this.clearCache = opts => {\n      const filter = opts == null ? void 0 : opts.filter;\n      if (filter !== void 0) {\n        this.__store.setState(s => {\n          return {\n            ...s,\n            cachedMatches: s.cachedMatches.filter(m => !filter(m))\n          };\n        });\n      } else {\n        this.__store.setState(s => {\n          return {\n            ...s,\n            cachedMatches: []\n          };\n        });\n      }\n    };\n    this.clearExpiredCache = () => {\n      const filter = d => {\n        const route = this.looseRoutesById[d.routeId];\n        if (!route.options.loader) {\n          return true;\n        }\n        const gcTime = (d.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;\n        return !(d.status !== \"error\" && Date.now() - d.updatedAt < gcTime);\n      };\n      this.clearCache({\n        filter\n      });\n    };\n    this.loadRouteChunk = route => {\n      if (route._lazyPromise === void 0) {\n        if (route.lazyFn) {\n          route._lazyPromise = route.lazyFn().then(lazyRoute => {\n            const {\n              id: _id,\n              ...options2\n            } = lazyRoute.options;\n            Object.assign(route.options, options2);\n          });\n        } else {\n          route._lazyPromise = Promise.resolve();\n        }\n      }\n      if (route._componentsPromise === void 0) {\n        route._componentsPromise = route._lazyPromise.then(() => Promise.all(componentTypes.map(async type => {\n          const component = route.options[type];\n          if (component == null ? void 0 : component.preload) {\n            await component.preload();\n          }\n        })));\n      }\n      return route._componentsPromise;\n    };\n    this.preloadRoute = async opts => {\n      const next = this.buildLocation(opts);\n      let matches = this.matchRoutes(next, {\n        throwOnError: true,\n        preload: true,\n        dest: opts\n      });\n      const activeMatchIds = new Set([...this.state.matches, ...(this.state.pendingMatches ?? [])].map(d => d.id));\n      const loadedMatchIds = /* @__PURE__ */new Set([...activeMatchIds, ...this.state.cachedMatches.map(d => d.id)]);\n      batch(() => {\n        matches.forEach(match => {\n          if (!loadedMatchIds.has(match.id)) {\n            this.__store.setState(s => ({\n              ...s,\n              cachedMatches: [...s.cachedMatches, match]\n            }));\n          }\n        });\n      });\n      try {\n        matches = await this.loadMatches({\n          matches,\n          location: next,\n          preload: true,\n          updateMatch: (id, updater) => {\n            if (activeMatchIds.has(id)) {\n              matches = matches.map(d => d.id === id ? updater(d) : d);\n            } else {\n              this.updateMatch(id, updater);\n            }\n          }\n        });\n        return matches;\n      } catch (err) {\n        if (isRedirect(err)) {\n          if (err.reloadDocument) {\n            return void 0;\n          }\n          return await this.preloadRoute({\n            ...err,\n            _fromLocation: next\n          });\n        }\n        if (!isNotFound(err)) {\n          console.error(err);\n        }\n        return void 0;\n      }\n    };\n    this.matchRoute = (location, opts) => {\n      const matchLocation = {\n        ...location,\n        to: location.to ? this.resolvePathWithBase(location.from || \"\", location.to) : void 0,\n        params: location.params || {},\n        leaveParams: true\n      };\n      const next = this.buildLocation(matchLocation);\n      if ((opts == null ? void 0 : opts.pending) && this.state.status !== \"pending\") {\n        return false;\n      }\n      const pending = (opts == null ? void 0 : opts.pending) === void 0 ? !this.state.isLoading : opts.pending;\n      const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation || this.state.location;\n      const match = matchPathname(this.basepath, baseLocation.pathname, {\n        ...opts,\n        to: next.pathname\n      });\n      if (!match) {\n        return false;\n      }\n      if (location.params) {\n        if (!deepEqual(match, location.params, {\n          partial: true\n        })) {\n          return false;\n        }\n      }\n      if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {\n        return deepEqual(baseLocation.search, next.search, {\n          partial: true\n        }) ? match : false;\n      }\n      return match;\n    };\n    this._handleNotFound = (matches, err, {\n      updateMatch = this.updateMatch\n    } = {}) => {\n      var _a;\n      const routeCursor = this.routesById[err.routeId ?? \"\"] ?? this.routeTree;\n      const matchesByRouteId = {};\n      for (const match of matches) {\n        matchesByRouteId[match.routeId] = match;\n      }\n      if (!routeCursor.options.notFoundComponent && ((_a = this.options) == null ? void 0 : _a.defaultNotFoundComponent)) {\n        routeCursor.options.notFoundComponent = this.options.defaultNotFoundComponent;\n      }\n      invariant(routeCursor.options.notFoundComponent, \"No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.\");\n      const matchForRoute = matchesByRouteId[routeCursor.id];\n      invariant(matchForRoute, \"Could not find match for route: \" + routeCursor.id);\n      updateMatch(matchForRoute.id, prev => ({\n        ...prev,\n        status: \"notFound\",\n        error: err,\n        isFetching: false\n      }));\n      if (err.routerCode === \"BEFORE_LOAD\" && routeCursor.parentRoute) {\n        err.routeId = routeCursor.parentRoute.id;\n        this._handleNotFound(matches, err, {\n          updateMatch\n        });\n      }\n    };\n    this.hasNotFoundMatch = () => {\n      return this.__store.state.matches.some(d => d.status === \"notFound\" || d.globalNotFound);\n    };\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1e3,\n      defaultPendingMinMs: 500,\n      context: void 0,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? \"fuzzy\",\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch\n    });\n    if (typeof document !== \"undefined\") {\n      window.__TSR_ROUTER__ = this;\n    }\n  }\n  get state() {\n    return this.__store.state;\n  }\n  get looseRoutesById() {\n    return this.routesById;\n  }\n  matchRoutesInternal(next, opts) {\n    const {\n      foundRoute,\n      matchedRoutes,\n      routeParams\n    } = this.getMatchedRoutes(next, opts == null ? void 0 : opts.dest);\n    let isGlobalNotFound = false;\n    if (\n    // If we found a route, and it's not an index route and we have left over path\n    foundRoute ? foundRoute.path !== \"/\" && routeParams[\"**\"] :\n    // Or if we didn't find a route and we have left over path\n    trimPathRight(next.pathname)) {\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute);\n      } else {\n        isGlobalNotFound = true;\n      }\n    }\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return void 0;\n      }\n      if (this.options.notFoundMode !== \"root\") {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i];\n          if (route.children) {\n            return route.id;\n          }\n        }\n      }\n      return rootRouteId;\n    })();\n    const parseErrors = matchedRoutes.map(route => {\n      var _a;\n      let parsedParamsError;\n      const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;\n      if (parseParams) {\n        try {\n          const parsedParams = parseParams(routeParams);\n          Object.assign(routeParams, parsedParams);\n        } catch (err) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err\n          });\n          if (opts == null ? void 0 : opts.throwOnError) {\n            throw parsedParamsError;\n          }\n          return parsedParamsError;\n        }\n      }\n      return;\n    });\n    const matches = [];\n    const getParentContext = parentMatch => {\n      const parentMatchId = parentMatch == null ? void 0 : parentMatch.id;\n      const parentContext = !parentMatchId ? this.options.context ?? {} : parentMatch.context ?? this.options.context ?? {};\n      return parentContext;\n    };\n    matchedRoutes.forEach((route, index) => {\n      var _a, _b;\n      const parentMatch = matches[index - 1];\n      const [preMatchSearch, strictMatchSearch, searchError] = (() => {\n        const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? next.search;\n        const parentStrictSearch = (parentMatch == null ? void 0 : parentMatch._strictSearch) ?? {};\n        try {\n          const strictSearch = validateSearch(route.options.validateSearch, {\n            ...parentSearch\n          }) ?? {};\n          return [{\n            ...parentSearch,\n            ...strictSearch\n          }, {\n            ...parentStrictSearch,\n            ...strictSearch\n          }, void 0];\n        } catch (err) {\n          let searchParamError = err;\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err\n            });\n          }\n          if (opts == null ? void 0 : opts.throwOnError) {\n            throw searchParamError;\n          }\n          return [parentSearch, {}, searchParamError];\n        }\n      })();\n      const loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {\n        search: preMatchSearch\n      })) ?? \"\";\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : \"\";\n      const {\n        usedParams,\n        interpolatedPath\n      } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap\n      });\n      const matchId = interpolatePath({\n        path: route.id,\n        params: routeParams,\n        leaveWildcards: true,\n        decodeCharMap: this.pathParamsDecodeCharMap\n      }).interpolatedPath + loaderDepsHash;\n      const existingMatch = this.getMatch(matchId);\n      const previousMatch = this.state.matches.find(d => d.routeId === route.id);\n      const cause = previousMatch ? \"stay\" : \"enter\";\n      let match;\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: usedParams,\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch\n        };\n      } else {\n        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? \"pending\" : \"success\";\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch ? replaceEqualDeep(previousMatch.params, routeParams) : routeParams,\n          _strictParams: usedParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: previousMatch ? replaceEqualDeep(previousMatch.search, preMatchSearch) : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: void 0,\n          status,\n          isFetching: false,\n          error: void 0,\n          paramsError: parseErrors[index],\n          __routeContext: {},\n          __beforeLoadContext: {},\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps) : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: void 0,\n          scripts: void 0,\n          headScripts: void 0,\n          meta: void 0,\n          staticData: route.options.staticData || {},\n          loadPromise: createControlledPromise(),\n          fullPath: route.fullPath\n        };\n      }\n      if (!(opts == null ? void 0 : opts.preload)) {\n        match.globalNotFound = globalNotFoundRouteId === route.id;\n      }\n      match.searchError = searchError;\n      const parentContext = getParentContext(parentMatch);\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext\n      };\n      matches.push(match);\n    });\n    matches.forEach((match, index) => {\n      var _a, _b, _c, _d, _e, _f, _g, _h;\n      const route = this.looseRoutesById[match.routeId];\n      const existingMatch = this.getMatch(match.id);\n      if (!existingMatch && (opts == null ? void 0 : opts._buildLocation) !== true) {\n        const parentMatch = matches[index - 1];\n        const parentContext = getParentContext(parentMatch);\n        const contextFnContext = {\n          deps: match.loaderDeps,\n          params: match.params,\n          context: parentContext,\n          location: next,\n          navigate: opts2 => this.navigate({\n            ...opts2,\n            _fromLocation: next\n          }),\n          buildLocation: this.buildLocation,\n          cause: match.cause,\n          abortController: match.abortController,\n          preload: !!match.preload,\n          matches\n        };\n        match.__routeContext = ((_b = (_a = route.options).context) == null ? void 0 : _b.call(_a, contextFnContext)) ?? {};\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext\n        };\n      }\n      if (match.status === \"success\") {\n        match.headers = (_d = (_c = route.options).headers) == null ? void 0 : _d.call(_c, {\n          loaderData: match.loaderData\n        });\n        const assetContext = {\n          matches,\n          match,\n          params: match.params,\n          loaderData: match.loaderData\n        };\n        const headFnContent = (_f = (_e = route.options).head) == null ? void 0 : _f.call(_e, assetContext);\n        match.links = headFnContent == null ? void 0 : headFnContent.links;\n        match.headScripts = headFnContent == null ? void 0 : headFnContent.scripts;\n        match.meta = headFnContent == null ? void 0 : headFnContent.meta;\n        match.scripts = (_h = (_g = route.options).scripts) == null ? void 0 : _h.call(_g, assetContext);\n      }\n    });\n    return matches;\n  }\n}\nclass SearchParamError extends Error {}\nclass PathParamError extends Error {}\nfunction lazyFn(fn, key) {\n  return async (...args) => {\n    const imported = await fn();\n    return imported[key || \"default\"](...args);\n  };\n}\nfunction getInitialRouterState(location) {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: \"idle\",\n    resolvedLocation: void 0,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200\n  };\n}\nfunction validateSearch(validateSearch2, input) {\n  if (validateSearch2 == null) return {};\n  if (\"~standard\" in validateSearch2) {\n    const result = validateSearch2[\"~standard\"].validate(input);\n    if (result instanceof Promise) throw new SearchParamError(\"Async validation not supported\");\n    if (result.issues) throw new SearchParamError(JSON.stringify(result.issues, void 0, 2), {\n      cause: result\n    });\n    return result.value;\n  }\n  if (\"parse\" in validateSearch2) {\n    return validateSearch2.parse(input);\n  }\n  if (typeof validateSearch2 === \"function\") {\n    return validateSearch2(input);\n  }\n  return {};\n}\nconst componentTypes = [\"component\", \"errorComponent\", \"pendingComponent\", \"notFoundComponent\"];\nfunction routeNeedsPreload(route) {\n  var _a;\n  for (const componentType of componentTypes) {\n    if ((_a = route.options[componentType]) == null ? void 0 : _a.preload) {\n      return true;\n    }\n  }\n  return false;\n}\nexport { PathParamError, RouterCore, SearchParamError, componentTypes, defaultSerializeError, getInitialRouterState, getLocationChangeInfo, lazyFn };","map":{"version":3,"names":["defaultSerializeError","err","Error","obj","name","message","process","env","NODE_ENV","stack","data","getLocationChangeInfo","routerState","fromLocation","resolvedLocation","toLocation","location","pathChanged","pathname","hrefChanged","href","hashChanged","hash","RouterCore","constructor","options","tempLocationKey","Math","round","random","resetNextScroll","shouldViewTransition","isViewTransitionTypesSupported","subscribers","Set","isScrollRestoring","isScrollRestorationSetup","startTransition","fn","update","newOptions","notFoundRoute","console","warn","previousOptions","isServer","document","pathParamsDecodeCharMap","pathParamsAllowedCharacters","Map","map","char","encodeURIComponent","basepath","trimPath","history","createMemoryHistory","initialEntries","createBrowserHistory","latestLocation","parseLocation","routeTree","buildRouteTree","__store","Store","getInitialRouterState","onUpdate","state","cachedMatches","filter","d","includes","status","setupScrollRestoration","window","_a","CSS","supports","routesById","routesByPath","init","originalIndex","defaultSsr","id","recurseRoutes","childRoutes","forEach","childRoute","i","existingRoute","invariant","String","isRoot","path","trimmedFullPath","trimPathRight","fullPath","endsWith","children","length","scoredRoutes","routes","Object","values","trimmed","trimPathLeft","parsed","parsePathname","value","shift","scores","segment","type","push","child","index","flatRoutes","sort","a","b","minLength","min","rank","subscribe","eventType","listener","add","delete","emit","routerEvent","previousLocation","locationToParse","parse","search","parsedSearch","parseSearch","searchStr","stringifySearch","replaceEqualDeep","split","reverse","__tempLocation","__tempKey","parsedTempLocation","key","maskedLocation","resolvePathWithBase","from","resolvedPath","resolvePath","base","to","cleanPath","trailingSlash","caseSensitive","matchRoutes","pathnameOrNext","locationSearchOrOpts","opts","matchRoutesInternal","getMatchedRoutes","next","dest","routeParams","trimmedPath","getMatchedParams","route","result","matchPathname","fuzzy","foundRoute","find","matchedParams","routeCursor","rootRouteId","matchedRoutes","parentRoute","unshift","cancelMatch","match","getMatch","abortController","abort","clearTimeout","pendingTimeout","cancelMatches","pendingMatches","buildLocation","build","matchedRoutesResult","fromMatches","_fromLocation","_buildLocation","matches","fromMatch","fromPath","fromSearch","_b","last","_c","stayingMatches","e","routeId","resolvePathTo","_d","fromRouteByFromPathRouteId","_e","interpolatedPath","interpolatePath","params","decodeCharMap","pathname2","joinPaths","prevParams","_f","nextParams","functionalUpdate","keys","_a2","stringify","stringifyParams","Boolean","leaveWildcards","leaveParams","_includeValidateSearch","_g","strict","validatedSearch","validateSearch","applyMiddlewares","search2","allMiddlewares","reduce","acc","middlewares","preSearchFilters","postSearchFilters","legacyMiddleware","search3","nextSearch","prev","next2","validate","concat","final","applyNext","currentSearch","middleware","newSearch","hashStr","nextState","unmaskOnReload","buildWithMatches","maskedDest","maskedNext","foundMask","routeMasks","_from","maskProps","pick","nextMatches","maskedMatches","maskedFinal","mask","commitLocation","viewTransition","ignoreBlocker","isSameState","ignoredProps","prop","isEqual","deepEqual","isSameUrl","previousCommitPromise","commitLocationPromise","createControlledPromise","resolve","load","hashScrollIntoView","nextHistory","__hashScrollIntoViewOptions","defaultHashScrollIntoView","replace","resetScroll","size","buildAndCommitLocation","rest","currentIndex","__TSR_index","parseHref","slice","navigate","reloadDocument","createHref","redirect","notFound","loadPromise","Promise","prevLocation","batch","setState","s","isLoading","loadMatches","sync","onReady","startViewTransition","exitingMatches","enteringMatches","previousMatches","newMatches","loadedAt","Date","now","clearExpiredCache","hook","looseRoutesById","call","isResolvedRedirect","isNotFound","statusCode","some","latestLoadPromise","hasNotFoundMatch","defaultViewTransition","startViewTransitionParams","resolvedViewTransitionTypes","types","updateMatch","updater","updated","isPending","isMatched","isCached","matchesKey","matchId","preload","allPreload","firstBadMatchIndex","rendered","triggerOnReady","resolvePreload","handleRedirectAndNotFound","isRedirect","isFetching","error","beforeLoadPromise","loaderPromise","resolveRedirect","_handleNotFound","serverSsr","onMatchSettled","router","resolveAll","rejectAll","handleSerialError","routerCode","_b2","onError","errorHandlerErr","_a3","_b3","updatedAt","AbortController","entries","existingMatch","parentMatchId","pendingMs","defaultPendingMs","shouldPending","loader","beforeLoad","routeNeedsPreload","Infinity","pendingComponent","defaultPendingComponent","executeBeforeLoad","setTimeout","prevLoadPromise","paramsError","searchError","getParentMatchContext","context","fetchCount","__routeContext","cause","beforeLoadFnContext","beforeLoadContext","__beforeLoadContext","validResolvedMatches","matchPromises","prevLoaderPromise","loaderShouldRunAsync","loaderIsRunningAsync","parentMatchPromise","getLoaderContext","loaderDeps","preload2","deps","age","staleAge","preloadStaleTime","defaultPreloadStaleTime","staleTime","defaultStaleTime","shouldReloadOption","shouldReload","runLoader","potentialPendingMinPromise","latestMatch","minPendingPromise","loadRouteChunk","loaderData","_lazyPromise","assetContext","headFnContent","_d2","_c2","head","meta","links","headScripts","scripts","headers","_h","_componentsPromise","_j","_i","onErrorError","_k","invalid","all","invalidate","clearCache","m","gcTime","preloadGcTime","defaultPreloadGcTime","defaultGcTime","lazyFn","then","lazyRoute","_id","options2","assign","componentTypes","component","preloadRoute","throwOnError","activeMatchIds","loadedMatchIds","has","matchRoute","matchLocation","pending","baseLocation","partial","includeSearch","matchesByRouteId","notFoundComponent","defaultNotFoundComponent","matchForRoute","globalNotFound","defaultPreloadDelay","defaultPendingMinMs","notFoundMode","defaultStringifySearch","defaultParseSearch","__TSR_ROUTER__","isGlobalNotFound","globalNotFoundRouteId","parseErrors","parsedParamsError","parseParams","parsedParams","PathParamError","getParentContext","parentMatch","parentContext","preMatchSearch","strictMatchSearch","parentSearch","parentStrictSearch","_strictSearch","strictSearch","searchParamError","SearchParamError","loaderDepsHash","JSON","usedParams","previousMatch","_strictParams","staticData","contextFnContext","opts2","args","imported","isTransitioning","validateSearch2","input","issues","componentType"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/router-core/src/router.ts"],"sourcesContent":["import { Store, batch } from '@tanstack/store'\nimport {\n  createBrowserHistory,\n  createMemoryHistory,\n  parseHref,\n} from '@tanstack/history'\nimport invariant from 'tiny-invariant'\nimport {\n  createControlledPromise,\n  deepEqual,\n  functionalUpdate,\n  last,\n  pick,\n  replaceEqualDeep,\n} from './utils'\nimport {\n  cleanPath,\n  interpolatePath,\n  joinPaths,\n  matchPathname,\n  parsePathname,\n  resolvePath,\n  trimPath,\n  trimPathLeft,\n  trimPathRight,\n} from './path'\nimport { isNotFound } from './not-found'\nimport { setupScrollRestoration } from './scroll-restoration'\nimport { defaultParseSearch, defaultStringifySearch } from './searchParams'\nimport { rootRouteId } from './root'\nimport { isRedirect, isResolvedRedirect } from './redirect'\nimport type { SearchParser, SearchSerializer } from './searchParams'\nimport type { AnyRedirect, ResolvedRedirect } from './redirect'\nimport type {\n  HistoryLocation,\n  HistoryState,\n  ParsedHistoryState,\n  RouterHistory,\n} from '@tanstack/history'\nimport type {\n  ControlledPromise,\n  NoInfer,\n  NonNullableUpdater,\n  PickAsRequired,\n  Updater,\n} from './utils'\nimport type { ParsedLocation } from './location'\nimport type { DeferredPromiseState } from './defer'\nimport type {\n  AnyContext,\n  AnyRoute,\n  AnyRouteWithContext,\n  BeforeLoadContextOptions,\n  LoaderFnContext,\n  MakeRemountDepsOptionsUnion,\n  RouteContextOptions,\n  RouteMask,\n  SearchMiddleware,\n} from './route'\nimport type {\n  FullSearchSchema,\n  RouteById,\n  RoutePaths,\n  RoutesById,\n  RoutesByPath,\n} from './routeInfo'\nimport type {\n  AnyRouteMatch,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  MatchRouteOptions,\n} from './Matches'\nimport type {\n  BuildLocationFn,\n  CommitLocationOptions,\n  NavigateFn,\n} from './RouterProvider'\nimport type { Manifest } from './manifest'\nimport type { StartSerializer } from './serializer'\nimport type { AnySchema, AnyValidator } from './validators'\nimport type { NavigateOptions, ResolveRelativePath, ToOptions } from './link'\nimport type { NotFoundError } from './not-found'\n\ndeclare global {\n  interface Window {\n    __TSR_ROUTER__?: AnyRouter\n  }\n}\n\nexport type ControllablePromise<T = any> = Promise<T> & {\n  resolve: (value: T) => void\n  reject: (value?: any) => void\n}\n\nexport type InjectedHtmlEntry = Promise<string>\n\nexport interface DefaultRegister {\n  router: AnyRouter\n}\n\nexport interface Register extends DefaultRegister {\n  // router: Router\n}\n\nexport type RegisteredRouter = Register['router']\n\nexport type DefaultRemountDepsFn<TRouteTree extends AnyRoute> = (\n  opts: MakeRemountDepsOptionsUnion<TRouteTree>,\n) => any\n\nexport interface DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptionsExtensions\n  extends DefaultRouterOptionsExtensions {}\n\nexport interface RouterOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n> extends RouterOptionsExtensions {\n  /**\n   * The history object that will be used to manage the browser history.\n   *\n   * If not provided, a new createBrowserHistory instance will be created and used.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#history-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/history-types)\n   */\n  history?: TRouterHistory\n  /**\n   * A function that will be used to stringify search params when generating links.\n   *\n   * @default defaultStringifySearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#stringifysearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  stringifySearch?: SearchSerializer\n  /**\n   * A function that will be used to parse search params when parsing the current location.\n   *\n   * @default defaultParseSearch\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#parsesearch-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/custom-search-param-serialization)\n   */\n  parseSearch?: SearchParser\n  /**\n   * If `false`, routes will not be preloaded by default in any way.\n   *\n   * If `'intent'`, routes will be preloaded by default when the user hovers over a link or a `touchstart` event is detected on a `<Link>`.\n   *\n   * If `'viewport'`, routes will be preloaded by default when they are within the viewport.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreload?: false | 'intent' | 'viewport' | 'render'\n  /**\n   * The delay in milliseconds that a route must be hovered over or touched before it is preloaded.\n   *\n   * @default 50\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloaddelay-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading#preload-delay)\n   */\n  defaultPreloadDelay?: number\n  /**\n   * The default `pendingMs` a route should use if no pendingMs is provided.\n   *\n   * @default 1000\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMs?: number\n  /**\n   * The default `pendingMinMs` a route should use if no pendingMinMs is provided.\n   *\n   * @default 500\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpendingminms-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#avoiding-pending-component-flash)\n   */\n  defaultPendingMinMs?: number\n  /**\n   * The default `staleTime` a route should use if no staleTime is provided. This is the time in milliseconds that a route will be considered fresh.\n   *\n   * @default 0\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultStaleTime?: number\n  /**\n   * The default `preloadStaleTime` a route should use if no preloadStaleTime is provided.\n   *\n   * @default 30_000 `(30 seconds)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadstaletime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadStaleTime?: number\n  /**\n   * The default `defaultPreloadGcTime` a route should use if no preloadGcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultpreloadgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/preloading)\n   */\n  defaultPreloadGcTime?: number\n  /**\n   * If `true`, route navigations will called using `document.startViewTransition()`.\n   *\n   * If the browser does not support this api, this option will be ignored.\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Document/startViewTransition) for more information on how this function works.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultviewtransition-property)\n   */\n  defaultViewTransition?: boolean | ViewTransitionOptions\n  /**\n   * The default `hashScrollIntoView` a route should use if no hashScrollIntoView is provided while navigating\n   *\n   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollIntoView) for more information on `ScrollIntoViewOptions`.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaulthashscrollintoview-property)\n   */\n  defaultHashScrollIntoView?: boolean | ScrollIntoViewOptions\n  /**\n   * @default 'fuzzy'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundmode-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/not-found-errors#the-notfoundmode-option)\n   */\n  notFoundMode?: 'root' | 'fuzzy'\n  /**\n   * The default `gcTime` a route should use if no gcTime is provided.\n   *\n   * @default 1_800_000 `(30 minutes)`\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultgctime-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/data-loading#key-options)\n   */\n  defaultGcTime?: number\n  /**\n   * If `true`, all routes will be matched as case-sensitive.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#casesensitive-property)\n   */\n  caseSensitive?: boolean\n  /**\n   *\n   * The route tree that will be used to configure the router instance.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routetree-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/routing/route-trees)\n   */\n  routeTree?: TRouteTree\n  /**\n   * The basepath for then entire router. This is useful for mounting a router instance at a subpath.\n   *\n   * @default '/'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#basepath-property)\n   */\n  basepath?: string\n  /**\n   * The root context that will be provided to all routes in the route tree.\n   *\n   * This can be used to provide a context to all routes in the tree without having to provide it to each route individually.\n   *\n   * Optional or required if the root route was created with [`createRootRouteWithContext()`](https://tanstack.com/router/latest/docs/framework/react/api/router/createRootRouteWithContextFunction).\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#context-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/router-context)\n   */\n  context?: InferRouterContext<TRouteTree>\n  /**\n   * A function that will be called when the router is dehydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#dehydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  dehydrate?: () => TDehydrated\n  /**\n   * A function that will be called when the router is hydrated.\n   *\n   * The return value of this function will be serialized and stored in the router's dehydrated state.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#hydrate-method)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/external-data-loading#critical-dehydrationhydration)\n   */\n  hydrate?: (dehydrated: TDehydrated) => void\n  /**\n   * An array of route masks that will be used to mask routes in the route tree.\n   *\n   * Route masking is when you display a route at a different path than the one it is configured to match, like a modal popup that when shared will unmask to the modal's content instead of the modal's context.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#routemasks-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking)\n   */\n  routeMasks?: Array<RouteMask<TRouteTree>>\n  /**\n   * If `true`, route masks will, by default, be removed when the page is reloaded.\n   *\n   * This can be overridden on a per-mask basis by setting the `unmaskOnReload` option on the mask, or on a per-navigation basis by setting the `unmaskOnReload` option in the `Navigate` options.\n   *\n   * @default false\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#unmaskonreload-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/route-masking#unmasking-on-page-reload)\n   */\n  unmaskOnReload?: boolean\n\n  /**\n   * Use `notFoundComponent` instead.\n   *\n   * @deprecated\n   * See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info.\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#notfoundroute-property)\n   */\n  notFoundRoute?: AnyRoute\n  /**\n   * Configures how trailing slashes are treated.\n   *\n   * - `'always'` will add a trailing slash if not present\n   * - `'never'` will remove the trailing slash if present\n   * - `'preserve'` will not modify the trailing slash.\n   *\n   * @default 'never'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#trailingslash-property)\n   */\n  trailingSlash?: TTrailingSlashOption\n  /**\n   * While usually automatic, sometimes it can be useful to force the router into a server-side state, e.g. when using the router in a non-browser environment that has access to a global.document object.\n   *\n   * @default typeof document !== 'undefined'\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#isserver-property)\n   */\n  isServer?: boolean\n\n  defaultSsr?: boolean\n\n  search?: {\n    /**\n     * Configures how unknown search params (= not returned by any `validateSearch`) are treated.\n     *\n     * @default false\n     * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#search.strict-property)\n     */\n    strict?: boolean\n  }\n\n  /**\n   * Configures whether structural sharing is enabled by default for fine-grained selectors.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#defaultstructuralsharing-property)\n   */\n  defaultStructuralSharing?: TDefaultStructuralSharingOption\n\n  /**\n   * Configures which URI characters are allowed in path params that would ordinarily be escaped by encodeURIComponent.\n   *\n   * @link [API Docs](https://tanstack.com/router/latest/docs/framework/react/api/router/RouterOptionsType#pathparamsallowedcharacters-property)\n   * @link [Guide](https://tanstack.com/router/latest/docs/framework/react/guide/path-params#allowed-characters)\n   */\n  pathParamsAllowedCharacters?: Array<\n    ';' | ':' | '@' | '&' | '=' | '+' | '$' | ','\n  >\n\n  defaultRemountDeps?: DefaultRemountDepsFn<TRouteTree>\n\n  /**\n   * If `true`, scroll restoration will be enabled\n   *\n   * @default false\n   */\n  scrollRestoration?: boolean\n\n  /**\n   * A function that will be called to get the key for the scroll restoration cache.\n   *\n   * @default (location) => location.href\n   */\n  getScrollRestorationKey?: (location: ParsedLocation) => string\n  /**\n   * The default behavior for scroll restoration.\n   *\n   * @default 'auto'\n   */\n  scrollRestorationBehavior?: ScrollBehavior\n  /**\n   * An array of selectors that will be used to scroll to the top of the page in addition to `window`\n   *\n   * @default ['window']\n   */\n  scrollToTopSelectors?: Array<string>\n}\n\nexport interface RouterState<\n  in out TRouteTree extends AnyRoute = AnyRoute,\n  in out TRouteMatch = MakeRouteMatchUnion,\n> {\n  status: 'pending' | 'idle'\n  loadedAt: number\n  isLoading: boolean\n  isTransitioning: boolean\n  matches: Array<TRouteMatch>\n  pendingMatches?: Array<TRouteMatch>\n  cachedMatches: Array<TRouteMatch>\n  location: ParsedLocation<FullSearchSchema<TRouteTree>>\n  resolvedLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>\n  statusCode: number\n  redirect?: ResolvedRedirect\n}\n\nexport interface BuildNextOptions {\n  to?: string | number | null\n  params?: true | Updater<unknown>\n  search?: true | Updater<unknown>\n  hash?: true | Updater<string>\n  state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n  mask?: {\n    to?: string | number | null\n    params?: true | Updater<unknown>\n    search?: true | Updater<unknown>\n    hash?: true | Updater<string>\n    state?: true | NonNullableUpdater<ParsedHistoryState, HistoryState>\n    unmaskOnReload?: boolean\n  }\n  from?: string\n  _fromLocation?: ParsedLocation\n  href?: string\n}\n\ntype NavigationEventInfo = {\n  fromLocation?: ParsedLocation\n  toLocation: ParsedLocation\n  pathChanged: boolean\n  hrefChanged: boolean\n  hashChanged: boolean\n}\n\nexport type RouterEvents = {\n  onBeforeNavigate: {\n    type: 'onBeforeNavigate'\n  } & NavigationEventInfo\n  onBeforeLoad: {\n    type: 'onBeforeLoad'\n  } & NavigationEventInfo\n  onLoad: {\n    type: 'onLoad'\n  } & NavigationEventInfo\n  onResolved: {\n    type: 'onResolved'\n  } & NavigationEventInfo\n  onBeforeRouteMount: {\n    type: 'onBeforeRouteMount'\n  } & NavigationEventInfo\n  onInjectedHtml: {\n    type: 'onInjectedHtml'\n    promise: Promise<string>\n  }\n  onRendered: {\n    type: 'onRendered'\n  } & NavigationEventInfo\n}\n\nexport type RouterEvent = RouterEvents[keyof RouterEvents]\n\nexport type ListenerFn<TEvent extends RouterEvent> = (event: TEvent) => void\n\nexport type RouterListener<TRouterEvent extends RouterEvent> = {\n  eventType: TRouterEvent['type']\n  fn: ListenerFn<TRouterEvent>\n}\n\nexport interface MatchRoutesOpts {\n  preload?: boolean\n  throwOnError?: boolean\n  _buildLocation?: boolean\n  dest?: BuildNextOptions\n}\n\nexport type InferRouterContext<TRouteTree extends AnyRoute> =\n  TRouteTree['types']['routerContext']\n\nexport type RouterContextOptions<TRouteTree extends AnyRoute> =\n  AnyContext extends InferRouterContext<TRouteTree>\n    ? {\n        context?: InferRouterContext<TRouteTree>\n      }\n    : {\n        context: InferRouterContext<TRouteTree>\n      }\n\nexport type RouterConstructorOptions<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = Omit<\n  RouterOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n  'context'\n> &\n  RouterContextOptions<TRouteTree>\n\nexport interface RouterErrorSerializer<TSerializedError> {\n  serialize: (err: unknown) => TSerializedError\n  deserialize: (err: TSerializedError) => unknown\n}\n\nexport interface MatchedRoutesResult {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n}\n\nexport type PreloadRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> | string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends RoutePaths<TRouteTree> | string = TFrom,\n  TMaskTo extends string = '',\n>(\n  opts: NavigateOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo,\n    TMaskFrom,\n    TMaskTo\n  >,\n) => Promise<Array<AnyRouteMatch> | undefined>\n\nexport type MatchRouteFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n> = <\n  TFrom extends RoutePaths<TRouteTree> = '/',\n  TTo extends string | undefined = undefined,\n  TResolved = ResolveRelativePath<TFrom, NoInfer<TTo>>,\n>(\n  location: ToOptions<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory\n    >,\n    TFrom,\n    TTo\n  >,\n  opts?: MatchRouteOptions,\n) => false | RouteById<TRouteTree, TResolved>['types']['allParams']\n\nexport type UpdateFn<\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption,\n  TDefaultStructuralSharingOption extends boolean,\n  TRouterHistory extends RouterHistory,\n  TDehydrated extends Record<string, any>,\n> = (\n  newOptions: RouterConstructorOptions<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  >,\n) => void\n\nexport type InvalidateFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n  sync?: boolean\n}) => Promise<void>\n\nexport type ParseLocationFn<TRouteTree extends AnyRoute> = (\n  previousLocation?: ParsedLocation<FullSearchSchema<TRouteTree>>,\n  locationToParse?: HistoryLocation,\n) => ParsedLocation<FullSearchSchema<TRouteTree>>\n\nexport type GetMatchRoutesFn = (\n  next: ParsedLocation,\n  dest?: BuildNextOptions,\n) => {\n  matchedRoutes: Array<AnyRoute>\n  routeParams: Record<string, string>\n  foundRoute: AnyRoute | undefined\n}\n\nexport type EmitFn = (routerEvent: RouterEvent) => void\n\nexport type LoadFn = (opts?: { sync?: boolean }) => Promise<void>\n\nexport type CommitLocationFn = ({\n  viewTransition,\n  ignoreBlocker,\n  ...next\n}: ParsedLocation & CommitLocationOptions) => Promise<void>\n\nexport type StartTransitionFn = (fn: () => void) => void\n\nexport type SubscribeFn = <TType extends keyof RouterEvents>(\n  eventType: TType,\n  fn: ListenerFn<RouterEvents[TType]>,\n) => () => void\n\nexport interface MatchRoutesFn {\n  (\n    pathname: string,\n    locationSearch: AnySchema,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n  (next: ParsedLocation, opts?: MatchRoutesOpts): Array<AnyRouteMatch>\n  (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch>\n}\n\nexport type GetMatchFn = (matchId: string) => AnyRouteMatch | undefined\n\nexport type UpdateMatchFn = (\n  id: string,\n  updater: (match: AnyRouteMatch) => AnyRouteMatch,\n) => AnyRouteMatch\n\nexport type LoadRouteChunkFn = (route: AnyRoute) => Promise<Array<void>>\n\nexport type ResolveRedirect = (err: AnyRedirect) => ResolvedRedirect\n\nexport type ClearCacheFn<TRouter extends AnyRouter> = (opts?: {\n  filter?: (d: MakeRouteMatchUnion<TRouter>) => boolean\n}) => void\n\nexport interface ServerSrr {\n  injectedHtml: Array<InjectedHtmlEntry>\n  injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n  injectScript: (\n    getScript: () => string | Promise<string>,\n    opts?: { logScript?: boolean },\n  ) => Promise<void>\n  streamValue: (key: string, value: any) => void\n  streamedKeys: Set<string>\n  onMatchSettled: (opts: { router: AnyRouter; match: AnyRouteMatch }) => any\n}\n\nexport type AnyRouterWithContext<TContext> = RouterCore<\n  AnyRouteWithContext<TContext>,\n  any,\n  any,\n  any,\n  any\n>\n\nexport type AnyRouter = RouterCore<any, any, any, any, any>\n\nexport interface ViewTransitionOptions {\n  types:\n    | Array<string>\n    | ((locationChangeInfo: {\n        fromLocation?: ParsedLocation\n        toLocation: ParsedLocation\n        pathChanged: boolean\n        hrefChanged: boolean\n        hashChanged: boolean\n      }) => Array<string>)\n}\n\nexport function defaultSerializeError(err: unknown) {\n  if (err instanceof Error) {\n    const obj = {\n      name: err.name,\n      message: err.message,\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      ;(obj as any).stack = err.stack\n    }\n\n    return obj\n  }\n\n  return {\n    data: err,\n  }\n}\nexport interface ExtractedBaseEntry {\n  dataType: '__beforeLoadContext' | 'loaderData'\n  type: string\n  path: Array<string>\n  id: number\n  matchIndex: number\n}\n\nexport interface ExtractedStream extends ExtractedBaseEntry {\n  type: 'stream'\n  streamState: StreamState\n}\n\nexport interface ExtractedPromise extends ExtractedBaseEntry {\n  type: 'promise'\n  promiseState: DeferredPromiseState<any>\n}\n\nexport type ExtractedEntry = ExtractedStream | ExtractedPromise\n\nexport type StreamState = {\n  promises: Array<ControlledPromise<string | null>>\n}\n\nexport type TrailingSlashOption = 'always' | 'never' | 'preserve'\n\nexport function getLocationChangeInfo(routerState: {\n  resolvedLocation?: ParsedLocation\n  location: ParsedLocation\n}) {\n  const fromLocation = routerState.resolvedLocation\n  const toLocation = routerState.location\n  const pathChanged = fromLocation?.pathname !== toLocation.pathname\n  const hrefChanged = fromLocation?.href !== toLocation.href\n  const hashChanged = fromLocation?.hash !== toLocation.hash\n  return { fromLocation, toLocation, pathChanged, hrefChanged, hashChanged }\n}\n\nexport type CreateRouterFn = <\n  TRouteTree extends AnyRoute,\n  TTrailingSlashOption extends TrailingSlashOption = 'never',\n  TDefaultStructuralSharingOption extends boolean = false,\n  TRouterHistory extends RouterHistory = RouterHistory,\n  TDehydrated extends Record<string, any> = Record<string, any>,\n>(\n  options: undefined extends number\n    ? 'strictNullChecks must be enabled in tsconfig.json'\n    : RouterConstructorOptions<\n        TRouteTree,\n        TTrailingSlashOption,\n        TDefaultStructuralSharingOption,\n        TRouterHistory,\n        TDehydrated\n      >,\n) => RouterCore<\n  TRouteTree,\n  TTrailingSlashOption,\n  TDefaultStructuralSharingOption,\n  TRouterHistory,\n  TDehydrated\n>\n\nexport class RouterCore<\n  in out TRouteTree extends AnyRoute,\n  in out TTrailingSlashOption extends TrailingSlashOption,\n  in out TDefaultStructuralSharingOption extends boolean,\n  in out TRouterHistory extends RouterHistory = RouterHistory,\n  in out TDehydrated extends Record<string, any> = Record<string, any>,\n> {\n  // Option-independent properties\n  tempLocationKey: string | undefined = `${Math.round(\n    Math.random() * 10000000,\n  )}`\n  resetNextScroll = true\n  shouldViewTransition?: boolean | ViewTransitionOptions = undefined\n  isViewTransitionTypesSupported?: boolean = undefined\n  subscribers = new Set<RouterListener<RouterEvent>>()\n  viewTransitionPromise?: ControlledPromise<true>\n  isScrollRestoring = false\n  isScrollRestorationSetup = false\n\n  // Must build in constructor\n  __store!: Store<RouterState<TRouteTree>>\n  options!: PickAsRequired<\n    RouterOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n    'stringifySearch' | 'parseSearch' | 'context'\n  >\n  history!: TRouterHistory\n  latestLocation!: ParsedLocation<FullSearchSchema<TRouteTree>>\n  basepath!: string\n  routeTree!: TRouteTree\n  routesById!: RoutesById<TRouteTree>\n  routesByPath!: RoutesByPath<TRouteTree>\n  flatRoutes!: Array<AnyRoute>\n  isServer!: boolean\n  pathParamsDecodeCharMap?: Map<string, string>\n\n  /**\n   * @deprecated Use the `createRouter` function instead\n   */\n  constructor(\n    options: RouterConstructorOptions<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >,\n  ) {\n    this.update({\n      defaultPreloadDelay: 50,\n      defaultPendingMs: 1000,\n      defaultPendingMinMs: 500,\n      context: undefined!,\n      ...options,\n      caseSensitive: options.caseSensitive ?? false,\n      notFoundMode: options.notFoundMode ?? 'fuzzy',\n      stringifySearch: options.stringifySearch ?? defaultStringifySearch,\n      parseSearch: options.parseSearch ?? defaultParseSearch,\n    })\n\n    if (typeof document !== 'undefined') {\n      ;(window as any).__TSR_ROUTER__ = this\n    }\n  }\n\n  // These are default implementations that can optionally be overridden\n  // by the router provider once rendered. We provide these so that the\n  // router can be used in a non-react environment if necessary\n  startTransition: StartTransitionFn = (fn) => fn()\n\n  update: UpdateFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory,\n    TDehydrated\n  > = (newOptions) => {\n    if (newOptions.notFoundRoute) {\n      console.warn(\n        'The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/framework/react/guide/not-found-errors#migrating-from-notfoundroute for more info.',\n      )\n    }\n\n    const previousOptions = this.options\n    this.options = {\n      ...this.options,\n      ...newOptions,\n    }\n\n    this.isServer = this.options.isServer ?? typeof document === 'undefined'\n\n    this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters\n      ? new Map(\n          this.options.pathParamsAllowedCharacters.map((char) => [\n            encodeURIComponent(char),\n            char,\n          ]),\n        )\n      : undefined\n\n    if (\n      !this.basepath ||\n      (newOptions.basepath && newOptions.basepath !== previousOptions.basepath)\n    ) {\n      if (\n        newOptions.basepath === undefined ||\n        newOptions.basepath === '' ||\n        newOptions.basepath === '/'\n      ) {\n        this.basepath = '/'\n      } else {\n        this.basepath = `/${trimPath(newOptions.basepath)}`\n      }\n    }\n\n    if (\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      !this.history ||\n      (this.options.history && this.options.history !== this.history)\n    ) {\n      this.history =\n        this.options.history ??\n        ((this.isServer\n          ? createMemoryHistory({\n              initialEntries: [this.basepath || '/'],\n            })\n          : createBrowserHistory()) as TRouterHistory)\n      this.latestLocation = this.parseLocation()\n    }\n\n    if (this.options.routeTree !== this.routeTree) {\n      this.routeTree = this.options.routeTree as TRouteTree\n      this.buildRouteTree()\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!this.__store) {\n      this.__store = new Store(getInitialRouterState(this.latestLocation), {\n        onUpdate: () => {\n          this.__store.state = {\n            ...this.state,\n            cachedMatches: this.state.cachedMatches.filter(\n              (d) => !['redirected'].includes(d.status),\n            ),\n          }\n        },\n      })\n\n      setupScrollRestoration(this)\n    }\n\n    if (\n      typeof window !== 'undefined' &&\n      'CSS' in window &&\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      typeof window.CSS?.supports === 'function'\n    ) {\n      this.isViewTransitionTypesSupported = window.CSS.supports(\n        'selector(:active-view-transition-type(a)',\n      )\n    }\n  }\n\n  get state() {\n    return this.__store.state\n  }\n\n  buildRouteTree = () => {\n    this.routesById = {} as RoutesById<TRouteTree>\n    this.routesByPath = {} as RoutesByPath<TRouteTree>\n\n    const notFoundRoute = this.options.notFoundRoute\n    if (notFoundRoute) {\n      notFoundRoute.init({\n        originalIndex: 99999999999,\n        defaultSsr: this.options.defaultSsr,\n      })\n      ;(this.routesById as any)[notFoundRoute.id] = notFoundRoute\n    }\n\n    const recurseRoutes = (childRoutes: Array<AnyRoute>) => {\n      childRoutes.forEach((childRoute, i) => {\n        childRoute.init({\n          originalIndex: i,\n          defaultSsr: this.options.defaultSsr,\n        })\n\n        const existingRoute = (this.routesById as any)[childRoute.id]\n\n        invariant(\n          !existingRoute,\n          `Duplicate routes found with id: ${String(childRoute.id)}`,\n        )\n        ;(this.routesById as any)[childRoute.id] = childRoute\n\n        if (!childRoute.isRoot && childRoute.path) {\n          const trimmedFullPath = trimPathRight(childRoute.fullPath)\n          if (\n            !(this.routesByPath as any)[trimmedFullPath] ||\n            childRoute.fullPath.endsWith('/')\n          ) {\n            ;(this.routesByPath as any)[trimmedFullPath] = childRoute\n          }\n        }\n\n        const children = childRoute.children\n\n        if (children?.length) {\n          recurseRoutes(children)\n        }\n      })\n    }\n\n    recurseRoutes([this.routeTree])\n\n    const scoredRoutes: Array<{\n      child: AnyRoute\n      trimmed: string\n      parsed: ReturnType<typeof parsePathname>\n      index: number\n      scores: Array<number>\n    }> = []\n\n    const routes: Array<AnyRoute> = Object.values(this.routesById)\n\n    routes.forEach((d, i) => {\n      if (d.isRoot || !d.path) {\n        return\n      }\n\n      const trimmed = trimPathLeft(d.fullPath)\n      const parsed = parsePathname(trimmed)\n\n      while (parsed.length > 1 && parsed[0]?.value === '/') {\n        parsed.shift()\n      }\n\n      const scores = parsed.map((segment) => {\n        if (segment.value === '/') {\n          return 0.75\n        }\n\n        if (segment.type === 'param') {\n          return 0.5\n        }\n\n        if (segment.type === 'wildcard') {\n          return 0.25\n        }\n\n        return 1\n      })\n\n      scoredRoutes.push({ child: d, trimmed, parsed, index: i, scores })\n    })\n\n    this.flatRoutes = scoredRoutes\n      .sort((a, b) => {\n        const minLength = Math.min(a.scores.length, b.scores.length)\n\n        // Sort by min available score\n        for (let i = 0; i < minLength; i++) {\n          if (a.scores[i] !== b.scores[i]) {\n            return b.scores[i]! - a.scores[i]!\n          }\n        }\n\n        // Sort by length of score\n        if (a.scores.length !== b.scores.length) {\n          return b.scores.length - a.scores.length\n        }\n\n        // Sort by min available parsed value\n        for (let i = 0; i < minLength; i++) {\n          if (a.parsed[i]!.value !== b.parsed[i]!.value) {\n            return a.parsed[i]!.value > b.parsed[i]!.value ? 1 : -1\n          }\n        }\n\n        // Sort by original index\n        return a.index - b.index\n      })\n      .map((d, i) => {\n        d.child.rank = i\n        return d.child\n      })\n  }\n\n  subscribe: SubscribeFn = (eventType, fn) => {\n    const listener: RouterListener<any> = {\n      eventType,\n      fn,\n    }\n\n    this.subscribers.add(listener)\n\n    return () => {\n      this.subscribers.delete(listener)\n    }\n  }\n\n  emit: EmitFn = (routerEvent) => {\n    this.subscribers.forEach((listener) => {\n      if (listener.eventType === routerEvent.type) {\n        listener.fn(routerEvent)\n      }\n    })\n  }\n\n  parseLocation: ParseLocationFn<TRouteTree> = (\n    previousLocation,\n    locationToParse,\n  ) => {\n    const parse = ({\n      pathname,\n      search,\n      hash,\n      state,\n    }: HistoryLocation): ParsedLocation<FullSearchSchema<TRouteTree>> => {\n      const parsedSearch = this.options.parseSearch(search)\n      const searchStr = this.options.stringifySearch(parsedSearch)\n\n      return {\n        pathname,\n        searchStr,\n        search: replaceEqualDeep(previousLocation?.search, parsedSearch) as any,\n        hash: hash.split('#').reverse()[0] ?? '',\n        href: `${pathname}${searchStr}${hash}`,\n        state: replaceEqualDeep(previousLocation?.state, state),\n      }\n    }\n\n    const location = parse(locationToParse ?? this.history.location)\n\n    const { __tempLocation, __tempKey } = location.state\n\n    if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {\n      // Sync up the location keys\n      const parsedTempLocation = parse(__tempLocation) as any\n      parsedTempLocation.state.key = location.state.key\n\n      delete parsedTempLocation.state.__tempLocation\n\n      return {\n        ...parsedTempLocation,\n        maskedLocation: location,\n      }\n    }\n\n    return location\n  }\n\n  resolvePathWithBase = (from: string, path: string) => {\n    const resolvedPath = resolvePath({\n      basepath: this.basepath,\n      base: from,\n      to: cleanPath(path),\n      trailingSlash: this.options.trailingSlash,\n      caseSensitive: this.options.caseSensitive,\n    })\n    return resolvedPath\n  }\n\n  get looseRoutesById() {\n    return this.routesById as Record<string, AnyRoute>\n  }\n\n  /**\n  @deprecated use the following signature instead\n  ```ts\n  matchRoutes (\n    next: ParsedLocation,\n    opts?: { preload?: boolean; throwOnError?: boolean },\n  ): Array<AnyRouteMatch>;\n  ```\n*/\n  matchRoutes: MatchRoutesFn = (\n    pathnameOrNext: string | ParsedLocation,\n    locationSearchOrOpts?: AnySchema | MatchRoutesOpts,\n    opts?: MatchRoutesOpts,\n  ) => {\n    if (typeof pathnameOrNext === 'string') {\n      return this.matchRoutesInternal(\n        {\n          pathname: pathnameOrNext,\n          search: locationSearchOrOpts,\n        } as ParsedLocation,\n        opts,\n      )\n    } else {\n      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts)\n    }\n  }\n\n  private matchRoutesInternal(\n    next: ParsedLocation,\n    opts?: MatchRoutesOpts,\n  ): Array<AnyRouteMatch> {\n    const { foundRoute, matchedRoutes, routeParams } = this.getMatchedRoutes(\n      next,\n      opts?.dest,\n    )\n    let isGlobalNotFound = false\n\n    // Check to see if the route needs a 404 entry\n    if (\n      // If we found a route, and it's not an index route and we have left over path\n      foundRoute\n        ? foundRoute.path !== '/' && routeParams['**']\n        : // Or if we didn't find a route and we have left over path\n          trimPathRight(next.pathname)\n    ) {\n      // If the user has defined an (old) 404 route, use it\n      if (this.options.notFoundRoute) {\n        matchedRoutes.push(this.options.notFoundRoute)\n      } else {\n        // If there is no routes found during path matching\n        isGlobalNotFound = true\n      }\n    }\n\n    const globalNotFoundRouteId = (() => {\n      if (!isGlobalNotFound) {\n        return undefined\n      }\n\n      if (this.options.notFoundMode !== 'root') {\n        for (let i = matchedRoutes.length - 1; i >= 0; i--) {\n          const route = matchedRoutes[i]!\n          if (route.children) {\n            return route.id\n          }\n        }\n      }\n\n      return rootRouteId\n    })()\n\n    const parseErrors = matchedRoutes.map((route) => {\n      let parsedParamsError\n\n      const parseParams =\n        route.options.params?.parse ?? route.options.parseParams\n\n      if (parseParams) {\n        try {\n          const parsedParams = parseParams(routeParams)\n          // Add the parsed params to the accumulated params bag\n          Object.assign(routeParams, parsedParams)\n        } catch (err: any) {\n          parsedParamsError = new PathParamError(err.message, {\n            cause: err,\n          })\n\n          if (opts?.throwOnError) {\n            throw parsedParamsError\n          }\n\n          return parsedParamsError\n        }\n      }\n\n      return\n    })\n\n    const matches: Array<AnyRouteMatch> = []\n\n    const getParentContext = (parentMatch?: AnyRouteMatch) => {\n      const parentMatchId = parentMatch?.id\n\n      const parentContext = !parentMatchId\n        ? ((this.options.context as any) ?? {})\n        : (parentMatch.context ?? this.options.context ?? {})\n\n      return parentContext\n    }\n\n    matchedRoutes.forEach((route, index) => {\n      // Take each matched route and resolve + validate its search params\n      // This has to happen serially because each route's search params\n      // can depend on the parent route's search params\n      // It must also happen before we create the match so that we can\n      // pass the search params to the route's potential key function\n      // which is used to uniquely identify the route match in state\n\n      const parentMatch = matches[index - 1]\n\n      const [preMatchSearch, strictMatchSearch, searchError]: [\n        Record<string, any>,\n        Record<string, any>,\n        any,\n      ] = (() => {\n        // Validate the search params and stabilize them\n        const parentSearch = parentMatch?.search ?? next.search\n        const parentStrictSearch = parentMatch?._strictSearch ?? {}\n\n        try {\n          const strictSearch =\n            validateSearch(route.options.validateSearch, { ...parentSearch }) ??\n            {}\n\n          return [\n            {\n              ...parentSearch,\n              ...strictSearch,\n            },\n            { ...parentStrictSearch, ...strictSearch },\n            undefined,\n          ]\n        } catch (err: any) {\n          let searchParamError = err\n          if (!(err instanceof SearchParamError)) {\n            searchParamError = new SearchParamError(err.message, {\n              cause: err,\n            })\n          }\n\n          if (opts?.throwOnError) {\n            throw searchParamError\n          }\n\n          return [parentSearch, {}, searchParamError]\n        }\n      })()\n\n      // This is where we need to call route.options.loaderDeps() to get any additional\n      // deps that the route's loader function might need to run. We need to do this\n      // before we create the match so that we can pass the deps to the route's\n      // potential key function which is used to uniquely identify the route match in state\n\n      const loaderDeps =\n        route.options.loaderDeps?.({\n          search: preMatchSearch,\n        }) ?? ''\n\n      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : ''\n\n      const { usedParams, interpolatedPath } = interpolatePath({\n        path: route.fullPath,\n        params: routeParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      })\n\n      const matchId =\n        interpolatePath({\n          path: route.id,\n          params: routeParams,\n          leaveWildcards: true,\n          decodeCharMap: this.pathParamsDecodeCharMap,\n        }).interpolatedPath + loaderDepsHash\n\n      // Waste not, want not. If we already have a match for this route,\n      // reuse it. This is important for layout routes, which might stick\n      // around between navigation actions that only change leaf routes.\n\n      // Existing matches are matches that are already loaded along with\n      // pending matches that are still loading\n      const existingMatch = this.getMatch(matchId)\n\n      const previousMatch = this.state.matches.find(\n        (d) => d.routeId === route.id,\n      )\n\n      const cause = previousMatch ? 'stay' : 'enter'\n\n      let match: AnyRouteMatch\n\n      if (existingMatch) {\n        match = {\n          ...existingMatch,\n          cause,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: usedParams,\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : replaceEqualDeep(existingMatch.search, preMatchSearch),\n          _strictSearch: strictMatchSearch,\n        }\n      } else {\n        const status =\n          route.options.loader ||\n          route.options.beforeLoad ||\n          route.lazyFn ||\n          routeNeedsPreload(route)\n            ? 'pending'\n            : 'success'\n\n        match = {\n          id: matchId,\n          index,\n          routeId: route.id,\n          params: previousMatch\n            ? replaceEqualDeep(previousMatch.params, routeParams)\n            : routeParams,\n          _strictParams: usedParams,\n          pathname: joinPaths([this.basepath, interpolatedPath]),\n          updatedAt: Date.now(),\n          search: previousMatch\n            ? replaceEqualDeep(previousMatch.search, preMatchSearch)\n            : preMatchSearch,\n          _strictSearch: strictMatchSearch,\n          searchError: undefined,\n          status,\n          isFetching: false,\n          error: undefined,\n          paramsError: parseErrors[index],\n          __routeContext: {},\n          __beforeLoadContext: {},\n          context: {},\n          abortController: new AbortController(),\n          fetchCount: 0,\n          cause,\n          loaderDeps: previousMatch\n            ? replaceEqualDeep(previousMatch.loaderDeps, loaderDeps)\n            : loaderDeps,\n          invalid: false,\n          preload: false,\n          links: undefined,\n          scripts: undefined,\n          headScripts: undefined,\n          meta: undefined,\n          staticData: route.options.staticData || {},\n          loadPromise: createControlledPromise(),\n          fullPath: route.fullPath,\n        }\n      }\n\n      if (!opts?.preload) {\n        // If we have a global not found, mark the right match as global not found\n        match.globalNotFound = globalNotFoundRouteId === route.id\n      }\n\n      // update the searchError if there is one\n      match.searchError = searchError\n\n      const parentContext = getParentContext(parentMatch)\n\n      match.context = {\n        ...parentContext,\n        ...match.__routeContext,\n        ...match.__beforeLoadContext,\n      }\n\n      matches.push(match)\n    })\n\n    matches.forEach((match, index) => {\n      const route = this.looseRoutesById[match.routeId]!\n      const existingMatch = this.getMatch(match.id)\n\n      // only execute `context` if we are not just building a location\n      if (!existingMatch && opts?._buildLocation !== true) {\n        const parentMatch = matches[index - 1]\n        const parentContext = getParentContext(parentMatch)\n\n        // Update the match's context\n        const contextFnContext: RouteContextOptions<any, any, any, any> = {\n          deps: match.loaderDeps,\n          params: match.params,\n          context: parentContext,\n          location: next,\n          navigate: (opts: any) =>\n            this.navigate({ ...opts, _fromLocation: next }),\n          buildLocation: this.buildLocation,\n          cause: match.cause,\n          abortController: match.abortController,\n          preload: !!match.preload,\n          matches,\n        }\n\n        // Get the route context\n        match.__routeContext = route.options.context?.(contextFnContext) ?? {}\n\n        match.context = {\n          ...parentContext,\n          ...match.__routeContext,\n          ...match.__beforeLoadContext,\n        }\n      }\n\n      // If it's already a success, update headers and head content\n      // These may get updated again if the match is refreshed\n      // due to being stale\n      if (match.status === 'success') {\n        match.headers = route.options.headers?.({\n          loaderData: match.loaderData,\n        })\n        const assetContext = {\n          matches,\n          match,\n          params: match.params,\n          loaderData: match.loaderData,\n        }\n        const headFnContent = route.options.head?.(assetContext)\n        match.links = headFnContent?.links\n        match.headScripts = headFnContent?.scripts\n        match.meta = headFnContent?.meta\n        match.scripts = route.options.scripts?.(assetContext)\n      }\n    })\n\n    return matches\n  }\n\n  getMatchedRoutes: GetMatchRoutesFn = (next, dest) => {\n    let routeParams: Record<string, string> = {}\n    const trimmedPath = trimPathRight(next.pathname)\n    const getMatchedParams = (route: AnyRoute) => {\n      const result = matchPathname(this.basepath, trimmedPath, {\n        to: route.fullPath,\n        caseSensitive:\n          route.options.caseSensitive ?? this.options.caseSensitive,\n        fuzzy: true,\n      })\n      return result\n    }\n\n    let foundRoute: AnyRoute | undefined =\n      dest?.to !== undefined ? this.routesByPath[dest.to!] : undefined\n    if (foundRoute) {\n      routeParams = getMatchedParams(foundRoute)!\n    } else {\n      foundRoute = this.flatRoutes.find((route) => {\n        const matchedParams = getMatchedParams(route)\n\n        if (matchedParams) {\n          routeParams = matchedParams\n          return true\n        }\n\n        return false\n      })\n    }\n\n    let routeCursor: AnyRoute =\n      foundRoute || (this.routesById as any)[rootRouteId]\n\n    const matchedRoutes: Array<AnyRoute> = [routeCursor]\n\n    while (routeCursor.parentRoute) {\n      routeCursor = routeCursor.parentRoute\n      matchedRoutes.unshift(routeCursor)\n    }\n\n    return { matchedRoutes, routeParams, foundRoute }\n  }\n\n  cancelMatch = (id: string) => {\n    const match = this.getMatch(id)\n\n    if (!match) return\n\n    match.abortController.abort()\n    clearTimeout(match.pendingTimeout)\n  }\n\n  cancelMatches = () => {\n    this.state.pendingMatches?.forEach((match) => {\n      this.cancelMatch(match.id)\n    })\n  }\n\n  buildLocation: BuildLocationFn = (opts) => {\n    const build = (\n      dest: BuildNextOptions & {\n        unmaskOnReload?: boolean\n      } = {},\n      matchedRoutesResult?: MatchedRoutesResult,\n    ): ParsedLocation => {\n      const fromMatches = dest._fromLocation\n        ? this.matchRoutes(dest._fromLocation, { _buildLocation: true })\n        : this.state.matches\n\n      const fromMatch =\n        dest.from != null\n          ? fromMatches.find((d) =>\n              matchPathname(this.basepath, trimPathRight(d.pathname), {\n                to: dest.from,\n                caseSensitive: false,\n                fuzzy: false,\n              }),\n            )\n          : undefined\n\n      const fromPath = fromMatch?.pathname || this.latestLocation.pathname\n\n      invariant(\n        dest.from == null || fromMatch != null,\n        'Could not find match for from: ' + dest.from,\n      )\n\n      const fromSearch = this.state.pendingMatches?.length\n        ? last(this.state.pendingMatches)?.search\n        : last(fromMatches)?.search || this.latestLocation.search\n\n      const stayingMatches = matchedRoutesResult?.matchedRoutes.filter((d) =>\n        fromMatches.find((e) => e.routeId === d.id),\n      )\n      let pathname: string\n      if (dest.to) {\n        const resolvePathTo =\n          fromMatch?.fullPath ||\n          last(fromMatches)?.fullPath ||\n          this.latestLocation.pathname\n        pathname = this.resolvePathWithBase(resolvePathTo, `${dest.to}`)\n      } else {\n        const fromRouteByFromPathRouteId =\n          this.routesById[\n            stayingMatches?.find((route) => {\n              const interpolatedPath = interpolatePath({\n                path: route.fullPath,\n                params: matchedRoutesResult?.routeParams ?? {},\n                decodeCharMap: this.pathParamsDecodeCharMap,\n              }).interpolatedPath\n              const pathname = joinPaths([this.basepath, interpolatedPath])\n              return pathname === fromPath\n            })?.id as keyof this['routesById']\n          ]\n        pathname = this.resolvePathWithBase(\n          fromPath,\n          fromRouteByFromPathRouteId?.to ?? fromPath,\n        )\n      }\n\n      const prevParams = { ...last(fromMatches)?.params }\n\n      let nextParams =\n        (dest.params ?? true) === true\n          ? prevParams\n          : {\n              ...prevParams,\n              ...functionalUpdate(dest.params as any, prevParams),\n            }\n\n      if (Object.keys(nextParams).length > 0) {\n        matchedRoutesResult?.matchedRoutes\n          .map((route) => {\n            return (\n              route.options.params?.stringify ?? route.options.stringifyParams\n            )\n          })\n          .filter(Boolean)\n          .forEach((fn) => {\n            nextParams = { ...nextParams!, ...fn!(nextParams) }\n          })\n      }\n\n      pathname = interpolatePath({\n        path: pathname,\n        params: nextParams ?? {},\n        leaveWildcards: false,\n        leaveParams: opts.leaveParams,\n        decodeCharMap: this.pathParamsDecodeCharMap,\n      }).interpolatedPath\n\n      let search = fromSearch\n      if (opts._includeValidateSearch && this.options.search?.strict) {\n        let validatedSearch = {}\n        matchedRoutesResult?.matchedRoutes.forEach((route) => {\n          try {\n            if (route.options.validateSearch) {\n              validatedSearch = {\n                ...validatedSearch,\n                ...(validateSearch(route.options.validateSearch, {\n                  ...validatedSearch,\n                  ...search,\n                }) ?? {}),\n              }\n            }\n          } catch {\n            // ignore errors here because they are already handled in matchRoutes\n          }\n        })\n        search = validatedSearch\n      }\n\n      const applyMiddlewares = (search: any) => {\n        const allMiddlewares =\n          matchedRoutesResult?.matchedRoutes.reduce(\n            (acc, route) => {\n              const middlewares: Array<SearchMiddleware<any>> = []\n              if ('search' in route.options) {\n                if (route.options.search?.middlewares) {\n                  middlewares.push(...route.options.search.middlewares)\n                }\n              }\n              // TODO remove preSearchFilters and postSearchFilters in v2\n              else if (\n                route.options.preSearchFilters ||\n                route.options.postSearchFilters\n              ) {\n                const legacyMiddleware: SearchMiddleware<any> = ({\n                  search,\n                  next,\n                }) => {\n                  let nextSearch = search\n                  if (\n                    'preSearchFilters' in route.options &&\n                    route.options.preSearchFilters\n                  ) {\n                    nextSearch = route.options.preSearchFilters.reduce(\n                      (prev, next) => next(prev),\n                      search,\n                    )\n                  }\n                  const result = next(nextSearch)\n                  if (\n                    'postSearchFilters' in route.options &&\n                    route.options.postSearchFilters\n                  ) {\n                    return route.options.postSearchFilters.reduce(\n                      (prev, next) => next(prev),\n                      result,\n                    )\n                  }\n                  return result\n                }\n                middlewares.push(legacyMiddleware)\n              }\n              if (opts._includeValidateSearch && route.options.validateSearch) {\n                const validate: SearchMiddleware<any> = ({ search, next }) => {\n                  const result = next(search)\n                  try {\n                    const validatedSearch = {\n                      ...result,\n                      ...(validateSearch(\n                        route.options.validateSearch,\n                        result,\n                      ) ?? {}),\n                    }\n                    return validatedSearch\n                  } catch {\n                    // ignore errors here because they are already handled in matchRoutes\n                    return result\n                  }\n                }\n                middlewares.push(validate)\n              }\n              return acc.concat(middlewares)\n            },\n            [] as Array<SearchMiddleware<any>>,\n          ) ?? []\n\n        // the chain ends here since `next` is not called\n        const final: SearchMiddleware<any> = ({ search }) => {\n          if (!dest.search) {\n            return {}\n          }\n          if (dest.search === true) {\n            return search\n          }\n          return functionalUpdate(dest.search, search)\n        }\n        allMiddlewares.push(final)\n\n        const applyNext = (index: number, currentSearch: any): any => {\n          // no more middlewares left, return the current search\n          if (index >= allMiddlewares.length) {\n            return currentSearch\n          }\n\n          const middleware = allMiddlewares[index]!\n\n          const next = (newSearch: any): any => {\n            return applyNext(index + 1, newSearch)\n          }\n\n          return middleware({ search: currentSearch, next })\n        }\n\n        // Start applying middlewares\n        return applyNext(0, search)\n      }\n\n      search = applyMiddlewares(search)\n\n      search = replaceEqualDeep(fromSearch, search)\n      const searchStr = this.options.stringifySearch(search)\n\n      const hash =\n        dest.hash === true\n          ? this.latestLocation.hash\n          : dest.hash\n            ? functionalUpdate(dest.hash, this.latestLocation.hash)\n            : undefined\n\n      const hashStr = hash ? `#${hash}` : ''\n\n      let nextState =\n        dest.state === true\n          ? this.latestLocation.state\n          : dest.state\n            ? functionalUpdate(dest.state, this.latestLocation.state)\n            : {}\n\n      nextState = replaceEqualDeep(this.latestLocation.state, nextState)\n\n      return {\n        pathname,\n        search,\n        searchStr,\n        state: nextState as any,\n        hash: hash ?? '',\n        href: `${pathname}${searchStr}${hashStr}`,\n        unmaskOnReload: dest.unmaskOnReload,\n      }\n    }\n\n    const buildWithMatches = (\n      dest: BuildNextOptions = {},\n      maskedDest?: BuildNextOptions,\n    ) => {\n      const next = build(dest)\n      let maskedNext = maskedDest ? build(maskedDest) : undefined\n\n      if (!maskedNext) {\n        let params = {}\n\n        const foundMask = this.options.routeMasks?.find((d) => {\n          const match = matchPathname(this.basepath, next.pathname, {\n            to: d.from,\n            caseSensitive: false,\n            fuzzy: false,\n          })\n\n          if (match) {\n            params = match\n            return true\n          }\n\n          return false\n        })\n\n        if (foundMask) {\n          const { from: _from, ...maskProps } = foundMask\n          maskedDest = {\n            ...pick(opts, ['from']),\n            ...maskProps,\n            params,\n          }\n          maskedNext = build(maskedDest)\n        }\n      }\n\n      const nextMatches = this.getMatchedRoutes(next, dest)\n      const final = build(dest, nextMatches)\n\n      if (maskedNext) {\n        const maskedMatches = this.getMatchedRoutes(maskedNext, maskedDest)\n        const maskedFinal = build(maskedDest, maskedMatches)\n        final.maskedLocation = maskedFinal\n      }\n\n      return final\n    }\n\n    if (opts.mask) {\n      return buildWithMatches(opts, {\n        ...pick(opts, ['from']),\n        ...opts.mask,\n      })\n    }\n\n    return buildWithMatches(opts)\n  }\n\n  commitLocationPromise: undefined | ControlledPromise<void>\n\n  commitLocation: CommitLocationFn = ({\n    viewTransition,\n    ignoreBlocker,\n    ...next\n  }) => {\n    const isSameState = () => {\n      // the following props are ignored but may still be provided when navigating,\n      // temporarily add the previous values to the next state so they don't affect\n      // the comparison\n      const ignoredProps = [\n        'key',\n        '__TSR_index',\n        '__hashScrollIntoViewOptions',\n      ] as const\n      ignoredProps.forEach((prop) => {\n        ;(next.state as any)[prop] = this.latestLocation.state[prop]\n      })\n      const isEqual = deepEqual(next.state, this.latestLocation.state)\n      ignoredProps.forEach((prop) => {\n        delete next.state[prop]\n      })\n      return isEqual\n    }\n\n    const isSameUrl = this.latestLocation.href === next.href\n\n    const previousCommitPromise = this.commitLocationPromise\n    this.commitLocationPromise = createControlledPromise<void>(() => {\n      previousCommitPromise?.resolve()\n    })\n\n    // Don't commit to history if nothing changed\n    if (isSameUrl && isSameState()) {\n      this.load()\n    } else {\n      // eslint-disable-next-line prefer-const\n      let { maskedLocation, hashScrollIntoView, ...nextHistory } = next\n\n      if (maskedLocation) {\n        nextHistory = {\n          ...maskedLocation,\n          state: {\n            ...maskedLocation.state,\n            __tempKey: undefined,\n            __tempLocation: {\n              ...nextHistory,\n              search: nextHistory.searchStr,\n              state: {\n                ...nextHistory.state,\n                __tempKey: undefined!,\n                __tempLocation: undefined!,\n                key: undefined!,\n              },\n            },\n          },\n        }\n\n        if (\n          nextHistory.unmaskOnReload ??\n          this.options.unmaskOnReload ??\n          false\n        ) {\n          nextHistory.state.__tempKey = this.tempLocationKey\n        }\n      }\n\n      nextHistory.state.__hashScrollIntoViewOptions =\n        hashScrollIntoView ?? this.options.defaultHashScrollIntoView ?? true\n\n      this.shouldViewTransition = viewTransition\n\n      this.history[next.replace ? 'replace' : 'push'](\n        nextHistory.href,\n        nextHistory.state,\n        { ignoreBlocker },\n      )\n    }\n\n    this.resetNextScroll = next.resetScroll ?? true\n\n    if (!this.history.subscribers.size) {\n      this.load()\n    }\n\n    return this.commitLocationPromise\n  }\n\n  buildAndCommitLocation = ({\n    replace,\n    resetScroll,\n    hashScrollIntoView,\n    viewTransition,\n    ignoreBlocker,\n    href,\n    ...rest\n  }: BuildNextOptions & CommitLocationOptions = {}) => {\n    if (href) {\n      const currentIndex = this.history.location.state.__TSR_index\n      const parsed = parseHref(href, {\n        __TSR_index: replace ? currentIndex : currentIndex + 1,\n      })\n      rest.to = parsed.pathname\n      rest.search = this.options.parseSearch(parsed.search)\n      // remove the leading `#` from the hash\n      rest.hash = parsed.hash.slice(1)\n    }\n\n    const location = this.buildLocation({\n      ...(rest as any),\n      _includeValidateSearch: true,\n    })\n    return this.commitLocation({\n      ...location,\n      viewTransition,\n      replace,\n      resetScroll,\n      hashScrollIntoView,\n      ignoreBlocker,\n    })\n  }\n\n  navigate: NavigateFn = ({ to, reloadDocument, href, ...rest }) => {\n    if (reloadDocument) {\n      if (!href) {\n        const location = this.buildLocation({ to, ...rest } as any)\n        href = this.history.createHref(location.href)\n      }\n      if (rest.replace) {\n        window.location.replace(href)\n      } else {\n        window.location.href = href\n      }\n      return\n    }\n\n    return this.buildAndCommitLocation({\n      ...rest,\n      href,\n      to: to as string,\n    })\n  }\n\n  latestLoadPromise: undefined | Promise<void>\n\n  load: LoadFn = async (opts?: { sync?: boolean }): Promise<void> => {\n    this.latestLocation = this.parseLocation(this.latestLocation)\n\n    let redirect: ResolvedRedirect | undefined\n    let notFound: NotFoundError | undefined\n\n    let loadPromise: Promise<void>\n\n    // eslint-disable-next-line prefer-const\n    loadPromise = new Promise<void>((resolve) => {\n      this.startTransition(async () => {\n        try {\n          const next = this.latestLocation\n          const prevLocation = this.state.resolvedLocation\n\n          // Cancel any pending matches\n          this.cancelMatches()\n\n          let pendingMatches!: Array<AnyRouteMatch>\n\n          batch(() => {\n            // this call breaks a route context of destination route after a redirect\n            // we should be fine not eagerly calling this since we call it later\n            // this.clearExpiredCache()\n\n            // Match the routes\n            pendingMatches = this.matchRoutes(next)\n\n            // Ingest the new matches\n            this.__store.setState((s) => ({\n              ...s,\n              status: 'pending',\n              isLoading: true,\n              location: next,\n              pendingMatches,\n              // If a cached moved to pendingMatches, remove it from cachedMatches\n              cachedMatches: s.cachedMatches.filter((d) => {\n                return !pendingMatches.find((e) => e.id === d.id)\n              }),\n            }))\n          })\n\n          if (!this.state.redirect) {\n            this.emit({\n              type: 'onBeforeNavigate',\n              ...getLocationChangeInfo({\n                resolvedLocation: prevLocation,\n                location: next,\n              }),\n            })\n          }\n\n          this.emit({\n            type: 'onBeforeLoad',\n            ...getLocationChangeInfo({\n              resolvedLocation: prevLocation,\n              location: next,\n            }),\n          })\n\n          await this.loadMatches({\n            sync: opts?.sync,\n            matches: pendingMatches,\n            location: next,\n            // eslint-disable-next-line @typescript-eslint/require-await\n            onReady: async () => {\n              // eslint-disable-next-line @typescript-eslint/require-await\n              this.startViewTransition(async () => {\n                // this.viewTransitionPromise = createControlledPromise<true>()\n\n                // Commit the pending matches. If a previous match was\n                // removed, place it in the cachedMatches\n                let exitingMatches!: Array<AnyRouteMatch>\n                let enteringMatches!: Array<AnyRouteMatch>\n                let stayingMatches!: Array<AnyRouteMatch>\n\n                batch(() => {\n                  this.__store.setState((s) => {\n                    const previousMatches = s.matches\n                    const newMatches = s.pendingMatches || s.matches\n\n                    exitingMatches = previousMatches.filter(\n                      (match) => !newMatches.find((d) => d.id === match.id),\n                    )\n                    enteringMatches = newMatches.filter(\n                      (match) =>\n                        !previousMatches.find((d) => d.id === match.id),\n                    )\n                    stayingMatches = previousMatches.filter((match) =>\n                      newMatches.find((d) => d.id === match.id),\n                    )\n\n                    return {\n                      ...s,\n                      isLoading: false,\n                      loadedAt: Date.now(),\n                      matches: newMatches,\n                      pendingMatches: undefined,\n                      cachedMatches: [\n                        ...s.cachedMatches,\n                        ...exitingMatches.filter((d) => d.status !== 'error'),\n                      ],\n                    }\n                  })\n                  this.clearExpiredCache()\n                })\n\n                //\n                ;(\n                  [\n                    [exitingMatches, 'onLeave'],\n                    [enteringMatches, 'onEnter'],\n                    [stayingMatches, 'onStay'],\n                  ] as const\n                ).forEach(([matches, hook]) => {\n                  matches.forEach((match) => {\n                    this.looseRoutesById[match.routeId]!.options[hook]?.(match)\n                  })\n                })\n              })\n            },\n          })\n        } catch (err) {\n          if (isResolvedRedirect(err)) {\n            redirect = err\n            if (!this.isServer) {\n              this.navigate({\n                ...redirect,\n                replace: true,\n                ignoreBlocker: true,\n              })\n            }\n          } else if (isNotFound(err)) {\n            notFound = err\n          }\n\n          this.__store.setState((s) => ({\n            ...s,\n            statusCode: redirect\n              ? redirect.statusCode\n              : notFound\n                ? 404\n                : s.matches.some((d) => d.status === 'error')\n                  ? 500\n                  : 200,\n            redirect,\n          }))\n        }\n\n        if (this.latestLoadPromise === loadPromise) {\n          this.commitLocationPromise?.resolve()\n          this.latestLoadPromise = undefined\n          this.commitLocationPromise = undefined\n        }\n        resolve()\n      })\n    })\n\n    this.latestLoadPromise = loadPromise\n\n    await loadPromise\n\n    while (\n      (this.latestLoadPromise as any) &&\n      loadPromise !== this.latestLoadPromise\n    ) {\n      await this.latestLoadPromise\n    }\n\n    if (this.hasNotFoundMatch()) {\n      this.__store.setState((s) => ({\n        ...s,\n        statusCode: 404,\n      }))\n    }\n  }\n\n  startViewTransition = (fn: () => Promise<void>) => {\n    // Determine if we should start a view transition from the navigation\n    // or from the router default\n    const shouldViewTransition =\n      this.shouldViewTransition ?? this.options.defaultViewTransition\n\n    // Reset the view transition flag\n    delete this.shouldViewTransition\n    // Attempt to start a view transition (or just apply the changes if we can't)\n    if (\n      shouldViewTransition &&\n      typeof document !== 'undefined' &&\n      'startViewTransition' in document &&\n      typeof document.startViewTransition === 'function'\n    ) {\n      // lib.dom.ts doesn't support viewTransition types variant yet.\n      // TODO: Fix this when dom types are updated\n      let startViewTransitionParams: any\n\n      if (\n        typeof shouldViewTransition === 'object' &&\n        this.isViewTransitionTypesSupported\n      ) {\n        const next = this.latestLocation\n        const prevLocation = this.state.resolvedLocation\n\n        const resolvedViewTransitionTypes =\n          typeof shouldViewTransition.types === 'function'\n            ? shouldViewTransition.types(\n                getLocationChangeInfo({\n                  resolvedLocation: prevLocation,\n                  location: next,\n                }),\n              )\n            : shouldViewTransition.types\n\n        startViewTransitionParams = {\n          update: fn,\n          types: resolvedViewTransitionTypes,\n        }\n      } else {\n        startViewTransitionParams = fn\n      }\n\n      document.startViewTransition(startViewTransitionParams)\n    } else {\n      fn()\n    }\n  }\n\n  updateMatch: UpdateMatchFn = (id, updater) => {\n    let updated!: AnyRouteMatch\n    const isPending = this.state.pendingMatches?.find((d) => d.id === id)\n    const isMatched = this.state.matches.find((d) => d.id === id)\n    const isCached = this.state.cachedMatches.find((d) => d.id === id)\n\n    const matchesKey = isPending\n      ? 'pendingMatches'\n      : isMatched\n        ? 'matches'\n        : isCached\n          ? 'cachedMatches'\n          : ''\n\n    if (matchesKey) {\n      this.__store.setState((s) => ({\n        ...s,\n        [matchesKey]: s[matchesKey]?.map((d) =>\n          d.id === id ? (updated = updater(d)) : d,\n        ),\n      }))\n    }\n\n    return updated\n  }\n\n  getMatch: GetMatchFn = (matchId: string) => {\n    return [\n      ...this.state.cachedMatches,\n      ...(this.state.pendingMatches ?? []),\n      ...this.state.matches,\n    ].find((d) => d.id === matchId)\n  }\n\n  loadMatches = async ({\n    location,\n    matches,\n    preload: allPreload,\n    onReady,\n    updateMatch = this.updateMatch,\n    sync,\n  }: {\n    location: ParsedLocation\n    matches: Array<AnyRouteMatch>\n    preload?: boolean\n    onReady?: () => Promise<void>\n    updateMatch?: (\n      id: string,\n      updater: (match: AnyRouteMatch) => AnyRouteMatch,\n    ) => void\n    getMatch?: (matchId: string) => AnyRouteMatch | undefined\n    sync?: boolean\n  }): Promise<Array<MakeRouteMatch>> => {\n    let firstBadMatchIndex: number | undefined\n    let rendered = false\n\n    const triggerOnReady = async () => {\n      if (!rendered) {\n        rendered = true\n        await onReady?.()\n      }\n    }\n\n    const resolvePreload = (matchId: string) => {\n      return !!(allPreload && !this.state.matches.find((d) => d.id === matchId))\n    }\n\n    const handleRedirectAndNotFound = (match: AnyRouteMatch, err: any) => {\n      if (isResolvedRedirect(err)) {\n        if (!err.reloadDocument) {\n          throw err\n        }\n      }\n\n      if (isRedirect(err) || isNotFound(err)) {\n        updateMatch(match.id, (prev) => ({\n          ...prev,\n          status: isRedirect(err)\n            ? 'redirected'\n            : isNotFound(err)\n              ? 'notFound'\n              : 'error',\n          isFetching: false,\n          error: err,\n          beforeLoadPromise: undefined,\n          loaderPromise: undefined,\n        }))\n\n        if (!(err as any).routeId) {\n          ;(err as any).routeId = match.routeId\n        }\n\n        match.beforeLoadPromise?.resolve()\n        match.loaderPromise?.resolve()\n        match.loadPromise?.resolve()\n\n        if (isRedirect(err)) {\n          rendered = true\n          err = this.resolveRedirect({ ...err, _fromLocation: location })\n          throw err\n        } else if (isNotFound(err)) {\n          this._handleNotFound(matches, err, {\n            updateMatch,\n          })\n          this.serverSsr?.onMatchSettled({\n            router: this,\n            match: this.getMatch(match.id)!,\n          })\n          throw err\n        }\n      }\n    }\n\n    try {\n      await new Promise<void>((resolveAll, rejectAll) => {\n        ;(async () => {\n          try {\n            const handleSerialError = (\n              index: number,\n              err: any,\n              routerCode: string,\n            ) => {\n              const { id: matchId, routeId } = matches[index]!\n              const route = this.looseRoutesById[routeId]!\n\n              // Much like suspense, we use a promise here to know if\n              // we've been outdated by a new loadMatches call and\n              // should abort the current async operation\n              if (err instanceof Promise) {\n                throw err\n              }\n\n              err.routerCode = routerCode\n              firstBadMatchIndex = firstBadMatchIndex ?? index\n              handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n\n              try {\n                route.options.onError?.(err)\n              } catch (errorHandlerErr) {\n                err = errorHandlerErr\n                handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n              }\n\n              updateMatch(matchId, (prev) => {\n                prev.beforeLoadPromise?.resolve()\n                prev.loadPromise?.resolve()\n\n                return {\n                  ...prev,\n                  error: err,\n                  status: 'error',\n                  isFetching: false,\n                  updatedAt: Date.now(),\n                  abortController: new AbortController(),\n                  beforeLoadPromise: undefined,\n                }\n              })\n            }\n\n            for (const [index, { id: matchId, routeId }] of matches.entries()) {\n              const existingMatch = this.getMatch(matchId)!\n              const parentMatchId = matches[index - 1]?.id\n\n              const route = this.looseRoutesById[routeId]!\n\n              const pendingMs =\n                route.options.pendingMs ?? this.options.defaultPendingMs\n\n              const shouldPending = !!(\n                onReady &&\n                !this.isServer &&\n                !resolvePreload(matchId) &&\n                (route.options.loader ||\n                  route.options.beforeLoad ||\n                  routeNeedsPreload(route)) &&\n                typeof pendingMs === 'number' &&\n                pendingMs !== Infinity &&\n                (route.options.pendingComponent ??\n                  (this.options as any)?.defaultPendingComponent)\n              )\n\n              let executeBeforeLoad = true\n              if (\n                // If we are in the middle of a load, either of these will be present\n                // (not to be confused with `loadPromise`, which is always defined)\n                existingMatch.beforeLoadPromise ||\n                existingMatch.loaderPromise\n              ) {\n                if (shouldPending) {\n                  setTimeout(() => {\n                    try {\n                      // Update the match and prematurely resolve the loadMatches promise so that\n                      // the pending component can start rendering\n                      triggerOnReady()\n                    } catch {}\n                  }, pendingMs)\n                }\n\n                // Wait for the beforeLoad to resolve before we continue\n                await existingMatch.beforeLoadPromise\n                executeBeforeLoad = this.getMatch(matchId)!.status !== 'success'\n              }\n              if (executeBeforeLoad) {\n                // If we are not in the middle of a load OR the previous load failed, start it\n                try {\n                  updateMatch(matchId, (prev) => {\n                    // explicitly capture the previous loadPromise\n                    const prevLoadPromise = prev.loadPromise\n                    return {\n                      ...prev,\n                      loadPromise: createControlledPromise<void>(() => {\n                        prevLoadPromise?.resolve()\n                      }),\n                      beforeLoadPromise: createControlledPromise<void>(),\n                    }\n                  })\n                  const abortController = new AbortController()\n\n                  let pendingTimeout: ReturnType<typeof setTimeout>\n\n                  if (shouldPending) {\n                    // If we might show a pending component, we need to wait for the\n                    // pending promise to resolve before we start showing that state\n                    pendingTimeout = setTimeout(() => {\n                      try {\n                        // Update the match and prematurely resolve the loadMatches promise so that\n                        // the pending component can start rendering\n                        triggerOnReady()\n                      } catch {}\n                    }, pendingMs)\n                  }\n\n                  const { paramsError, searchError } = this.getMatch(matchId)!\n\n                  if (paramsError) {\n                    handleSerialError(index, paramsError, 'PARSE_PARAMS')\n                  }\n\n                  if (searchError) {\n                    handleSerialError(index, searchError, 'VALIDATE_SEARCH')\n                  }\n\n                  const getParentMatchContext = () =>\n                    parentMatchId\n                      ? this.getMatch(parentMatchId)!.context\n                      : (this.options.context ?? {})\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: 'beforeLoad',\n                    fetchCount: prev.fetchCount + 1,\n                    abortController,\n                    pendingTimeout,\n                    context: {\n                      ...getParentMatchContext(),\n                      ...prev.__routeContext,\n                    },\n                  }))\n\n                  const { search, params, context, cause } =\n                    this.getMatch(matchId)!\n\n                  const preload = resolvePreload(matchId)\n\n                  const beforeLoadFnContext: BeforeLoadContextOptions<\n                    any,\n                    any,\n                    any,\n                    any,\n                    any\n                  > = {\n                    search,\n                    abortController,\n                    params,\n                    preload,\n                    context,\n                    location,\n                    navigate: (opts: any) =>\n                      this.navigate({ ...opts, _fromLocation: location }),\n                    buildLocation: this.buildLocation,\n                    cause: preload ? 'preload' : cause,\n                    matches,\n                  }\n\n                  const beforeLoadContext =\n                    (await route.options.beforeLoad?.(beforeLoadFnContext)) ??\n                    {}\n\n                  if (\n                    isRedirect(beforeLoadContext) ||\n                    isNotFound(beforeLoadContext)\n                  ) {\n                    handleSerialError(index, beforeLoadContext, 'BEFORE_LOAD')\n                  }\n\n                  updateMatch(matchId, (prev) => {\n                    return {\n                      ...prev,\n                      __beforeLoadContext: beforeLoadContext,\n                      context: {\n                        ...getParentMatchContext(),\n                        ...prev.__routeContext,\n                        ...beforeLoadContext,\n                      },\n                      abortController,\n                    }\n                  })\n                } catch (err) {\n                  handleSerialError(index, err, 'BEFORE_LOAD')\n                }\n\n                updateMatch(matchId, (prev) => {\n                  prev.beforeLoadPromise?.resolve()\n\n                  return {\n                    ...prev,\n                    beforeLoadPromise: undefined,\n                    isFetching: false,\n                  }\n                })\n              }\n            }\n\n            const validResolvedMatches = matches.slice(0, firstBadMatchIndex)\n            const matchPromises: Array<Promise<AnyRouteMatch>> = []\n\n            validResolvedMatches.forEach(({ id: matchId, routeId }, index) => {\n              matchPromises.push(\n                (async () => {\n                  const { loaderPromise: prevLoaderPromise } =\n                    this.getMatch(matchId)!\n\n                  let loaderShouldRunAsync = false\n                  let loaderIsRunningAsync = false\n\n                  if (prevLoaderPromise) {\n                    await prevLoaderPromise\n                    const match = this.getMatch(matchId)!\n                    if (match.error) {\n                      handleRedirectAndNotFound(match, match.error)\n                    }\n                  } else {\n                    const parentMatchPromise = matchPromises[index - 1] as any\n                    const route = this.looseRoutesById[routeId]!\n\n                    const getLoaderContext = (): LoaderFnContext => {\n                      const {\n                        params,\n                        loaderDeps,\n                        abortController,\n                        context,\n                        cause,\n                      } = this.getMatch(matchId)!\n\n                      const preload = resolvePreload(matchId)\n\n                      return {\n                        params,\n                        deps: loaderDeps,\n                        preload: !!preload,\n                        parentMatchPromise,\n                        abortController: abortController,\n                        context,\n                        location,\n                        navigate: (opts) =>\n                          this.navigate({ ...opts, _fromLocation: location }),\n                        cause: preload ? 'preload' : cause,\n                        route,\n                      }\n                    }\n\n                    // This is where all of the stale-while-revalidate magic happens\n                    const age = Date.now() - this.getMatch(matchId)!.updatedAt\n\n                    const preload = resolvePreload(matchId)\n\n                    const staleAge = preload\n                      ? (route.options.preloadStaleTime ??\n                        this.options.defaultPreloadStaleTime ??\n                        30_000) // 30 seconds for preloads by default\n                      : (route.options.staleTime ??\n                        this.options.defaultStaleTime ??\n                        0)\n\n                    const shouldReloadOption = route.options.shouldReload\n\n                    // Default to reloading the route all the time\n                    // Allow shouldReload to get the last say,\n                    // if provided.\n                    const shouldReload =\n                      typeof shouldReloadOption === 'function'\n                        ? shouldReloadOption(getLoaderContext())\n                        : shouldReloadOption\n\n                    updateMatch(matchId, (prev) => ({\n                      ...prev,\n                      loaderPromise: createControlledPromise<void>(),\n                      preload:\n                        !!preload &&\n                        !this.state.matches.find((d) => d.id === matchId),\n                    }))\n\n                    const runLoader = async () => {\n                      try {\n                        // If the Matches component rendered\n                        // the pending component and needs to show it for\n                        // a minimum duration, we''ll wait for it to resolve\n                        // before committing to the match and resolving\n                        // the loadPromise\n                        const potentialPendingMinPromise = async () => {\n                          const latestMatch = this.getMatch(matchId)!\n\n                          if (latestMatch.minPendingPromise) {\n                            await latestMatch.minPendingPromise\n                          }\n                        }\n\n                        // Actually run the loader and handle the result\n                        try {\n                          this.loadRouteChunk(route)\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            isFetching: 'loader',\n                          }))\n\n                          // Kick off the loader!\n                          const loaderData =\n                            await route.options.loader?.(getLoaderContext())\n\n                          handleRedirectAndNotFound(\n                            this.getMatch(matchId)!,\n                            loaderData,\n                          )\n\n                          // Lazy option can modify the route options,\n                          // so we need to wait for it to resolve before\n                          // we can use the options\n                          await route._lazyPromise\n\n                          await potentialPendingMinPromise()\n\n                          const assetContext = {\n                            matches,\n                            match: this.getMatch(matchId)!,\n                            params: this.getMatch(matchId)!.params,\n                            loaderData,\n                          }\n                          const headFnContent =\n                            route.options.head?.(assetContext)\n                          const meta = headFnContent?.meta\n                          const links = headFnContent?.links\n                          const headScripts = headFnContent?.scripts\n\n                          const scripts = route.options.scripts?.(assetContext)\n                          const headers = route.options.headers?.({\n                            loaderData,\n                          })\n\n                          // Last but not least, wait for the the components\n                          // to be preloaded before we resolve the match\n                          await route._componentsPromise\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error: undefined,\n                            status: 'success',\n                            isFetching: false,\n                            updatedAt: Date.now(),\n                            loaderData,\n                            meta,\n                            links,\n                            headScripts,\n                            headers,\n                            scripts,\n                          }))\n                        } catch (e) {\n                          let error = e\n\n                          await potentialPendingMinPromise()\n\n                          handleRedirectAndNotFound(this.getMatch(matchId)!, e)\n\n                          try {\n                            route.options.onError?.(e)\n                          } catch (onErrorError) {\n                            error = onErrorError\n                            handleRedirectAndNotFound(\n                              this.getMatch(matchId)!,\n                              onErrorError,\n                            )\n                          }\n\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            error,\n                            status: 'error',\n                            isFetching: false,\n                          }))\n                        }\n\n                        this.serverSsr?.onMatchSettled({\n                          router: this,\n                          match: this.getMatch(matchId)!,\n                        })\n                      } catch (err) {\n                        updateMatch(matchId, (prev) => ({\n                          ...prev,\n                          loaderPromise: undefined,\n                        }))\n                        handleRedirectAndNotFound(this.getMatch(matchId)!, err)\n                      }\n                    }\n\n                    // If the route is successful and still fresh, just resolve\n                    const { status, invalid } = this.getMatch(matchId)!\n                    loaderShouldRunAsync =\n                      status === 'success' &&\n                      (invalid || (shouldReload ?? age > staleAge))\n                    if (preload && route.options.preload === false) {\n                      // Do nothing\n                    } else if (loaderShouldRunAsync && !sync) {\n                      loaderIsRunningAsync = true\n                      ;(async () => {\n                        try {\n                          await runLoader()\n                          const { loaderPromise, loadPromise } =\n                            this.getMatch(matchId)!\n                          loaderPromise?.resolve()\n                          loadPromise?.resolve()\n                          updateMatch(matchId, (prev) => ({\n                            ...prev,\n                            loaderPromise: undefined,\n                          }))\n                        } catch (err) {\n                          if (isResolvedRedirect(err)) {\n                            await this.navigate(err)\n                          }\n                        }\n                      })()\n                    } else if (\n                      status !== 'success' ||\n                      (loaderShouldRunAsync && sync)\n                    ) {\n                      await runLoader()\n                    }\n                  }\n                  if (!loaderIsRunningAsync) {\n                    const { loaderPromise, loadPromise } =\n                      this.getMatch(matchId)!\n                    loaderPromise?.resolve()\n                    loadPromise?.resolve()\n                  }\n\n                  updateMatch(matchId, (prev) => ({\n                    ...prev,\n                    isFetching: loaderIsRunningAsync ? prev.isFetching : false,\n                    loaderPromise: loaderIsRunningAsync\n                      ? prev.loaderPromise\n                      : undefined,\n                    invalid: false,\n                  }))\n                  return this.getMatch(matchId)!\n                })(),\n              )\n            })\n\n            await Promise.all(matchPromises)\n\n            resolveAll()\n          } catch (err) {\n            rejectAll(err)\n          }\n        })()\n      })\n      await triggerOnReady()\n    } catch (err) {\n      if (isRedirect(err) || isNotFound(err)) {\n        if (isNotFound(err) && !allPreload) {\n          await triggerOnReady()\n        }\n\n        throw err\n      }\n    }\n\n    return matches\n  }\n\n  invalidate: InvalidateFn<\n    RouterCore<\n      TRouteTree,\n      TTrailingSlashOption,\n      TDefaultStructuralSharingOption,\n      TRouterHistory,\n      TDehydrated\n    >\n  > = (opts) => {\n    const invalidate = (d: MakeRouteMatch<TRouteTree>) => {\n      if (opts?.filter?.(d as MakeRouteMatchUnion<this>) ?? true) {\n        return {\n          ...d,\n          invalid: true,\n          ...(d.status === 'error'\n            ? ({ status: 'pending', error: undefined } as const)\n            : {}),\n        }\n      }\n      return d\n    }\n\n    this.__store.setState((s) => ({\n      ...s,\n      matches: s.matches.map(invalidate),\n      cachedMatches: s.cachedMatches.map(invalidate),\n      pendingMatches: s.pendingMatches?.map(invalidate),\n    }))\n\n    return this.load({ sync: opts?.sync })\n  }\n\n  resolveRedirect = (err: AnyRedirect): ResolvedRedirect => {\n    const redirect = err as ResolvedRedirect\n\n    if (!redirect.href) {\n      redirect.href = this.buildLocation(redirect as any).href\n    }\n\n    return redirect\n  }\n\n  clearCache: ClearCacheFn<this> = (opts) => {\n    const filter = opts?.filter\n    if (filter !== undefined) {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: s.cachedMatches.filter(\n            (m) => !filter(m as MakeRouteMatchUnion<this>),\n          ),\n        }\n      })\n    } else {\n      this.__store.setState((s) => {\n        return {\n          ...s,\n          cachedMatches: [],\n        }\n      })\n    }\n  }\n\n  clearExpiredCache = () => {\n    // This is where all of the garbage collection magic happens\n    const filter = (d: MakeRouteMatch<TRouteTree>) => {\n      const route = this.looseRoutesById[d.routeId]!\n\n      if (!route.options.loader) {\n        return true\n      }\n\n      // If the route was preloaded, use the preloadGcTime\n      // otherwise, use the gcTime\n      const gcTime =\n        (d.preload\n          ? (route.options.preloadGcTime ?? this.options.defaultPreloadGcTime)\n          : (route.options.gcTime ?? this.options.defaultGcTime)) ??\n        5 * 60 * 1000\n\n      return !(d.status !== 'error' && Date.now() - d.updatedAt < gcTime)\n    }\n    this.clearCache({ filter })\n  }\n\n  loadRouteChunk = (route: AnyRoute) => {\n    if (route._lazyPromise === undefined) {\n      if (route.lazyFn) {\n        route._lazyPromise = route.lazyFn().then((lazyRoute) => {\n          // explicitly don't copy over the lazy route's id\n          const { id: _id, ...options } = lazyRoute.options\n          Object.assign(route.options, options)\n        })\n      } else {\n        route._lazyPromise = Promise.resolve()\n      }\n    }\n\n    // If for some reason lazy resolves more lazy components...\n    // We'll wait for that before pre attempt to preload any\n    // components themselves.\n    if (route._componentsPromise === undefined) {\n      route._componentsPromise = route._lazyPromise.then(() =>\n        Promise.all(\n          componentTypes.map(async (type) => {\n            const component = route.options[type]\n            if ((component as any)?.preload) {\n              await (component as any).preload()\n            }\n          }),\n        ),\n      )\n    }\n    return route._componentsPromise\n  }\n\n  preloadRoute: PreloadRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = async (opts) => {\n    const next = this.buildLocation(opts as any)\n\n    let matches = this.matchRoutes(next, {\n      throwOnError: true,\n      preload: true,\n      dest: opts,\n    })\n\n    const activeMatchIds = new Set(\n      [...this.state.matches, ...(this.state.pendingMatches ?? [])].map(\n        (d) => d.id,\n      ),\n    )\n\n    const loadedMatchIds = new Set([\n      ...activeMatchIds,\n      ...this.state.cachedMatches.map((d) => d.id),\n    ])\n\n    // If the matches are already loaded, we need to add them to the cachedMatches\n    batch(() => {\n      matches.forEach((match) => {\n        if (!loadedMatchIds.has(match.id)) {\n          this.__store.setState((s) => ({\n            ...s,\n            cachedMatches: [...(s.cachedMatches as any), match],\n          }))\n        }\n      })\n    })\n\n    try {\n      matches = await this.loadMatches({\n        matches,\n        location: next,\n        preload: true,\n        updateMatch: (id, updater) => {\n          // Don't update the match if it's currently loaded\n          if (activeMatchIds.has(id)) {\n            matches = matches.map((d) => (d.id === id ? updater(d) : d))\n          } else {\n            this.updateMatch(id, updater)\n          }\n        },\n      })\n\n      return matches\n    } catch (err) {\n      if (isRedirect(err)) {\n        if (err.reloadDocument) {\n          return undefined\n        }\n        return await this.preloadRoute({\n          ...(err as any),\n          _fromLocation: next,\n        })\n      }\n      if (!isNotFound(err)) {\n        // Preload errors are not fatal, but we should still log them\n        console.error(err)\n      }\n      return undefined\n    }\n  }\n\n  matchRoute: MatchRouteFn<\n    TRouteTree,\n    TTrailingSlashOption,\n    TDefaultStructuralSharingOption,\n    TRouterHistory\n  > = (location, opts) => {\n    const matchLocation = {\n      ...location,\n      to: location.to\n        ? this.resolvePathWithBase(\n            (location.from || '') as string,\n            location.to as string,\n          )\n        : undefined,\n      params: location.params || {},\n      leaveParams: true,\n    }\n    const next = this.buildLocation(matchLocation as any)\n\n    if (opts?.pending && this.state.status !== 'pending') {\n      return false\n    }\n\n    const pending =\n      opts?.pending === undefined ? !this.state.isLoading : opts.pending\n\n    const baseLocation = pending\n      ? this.latestLocation\n      : this.state.resolvedLocation || this.state.location\n\n    const match = matchPathname(this.basepath, baseLocation.pathname, {\n      ...opts,\n      to: next.pathname,\n    }) as any\n\n    if (!match) {\n      return false\n    }\n    if (location.params) {\n      if (!deepEqual(match, location.params, { partial: true })) {\n        return false\n      }\n    }\n\n    if (match && (opts?.includeSearch ?? true)) {\n      return deepEqual(baseLocation.search, next.search, { partial: true })\n        ? match\n        : false\n    }\n\n    return match\n  }\n\n  ssr?: {\n    manifest: Manifest | undefined\n    serializer: StartSerializer\n  }\n\n  serverSsr?: {\n    injectedHtml: Array<InjectedHtmlEntry>\n    injectHtml: (getHtml: () => string | Promise<string>) => Promise<void>\n    injectScript: (\n      getScript: () => string | Promise<string>,\n      opts?: { logScript?: boolean },\n    ) => Promise<void>\n    streamValue: (key: string, value: any) => void\n    streamedKeys: Set<string>\n    onMatchSettled: (opts: { router: AnyRouter; match: AnyRouteMatch }) => any\n  }\n\n  clientSsr?: {\n    getStreamedValue: <T>(key: string) => T | undefined\n  }\n\n  _handleNotFound = (\n    matches: Array<AnyRouteMatch>,\n    err: NotFoundError,\n    {\n      updateMatch = this.updateMatch,\n    }: {\n      updateMatch?: (\n        id: string,\n        updater: (match: AnyRouteMatch) => AnyRouteMatch,\n      ) => void\n    } = {},\n  ) => {\n    // Find the route that should handle the not found error\n    // First check if a specific route is requested to show the error\n    const routeCursor = this.routesById[err.routeId ?? ''] ?? this.routeTree\n    const matchesByRouteId: Record<string, AnyRouteMatch> = {}\n\n    // Setup routesByRouteId object for quick access\n    for (const match of matches) {\n      matchesByRouteId[match.routeId] = match\n    }\n\n    // Ensure a NotFoundComponent exists on the route\n    if (\n      !routeCursor.options.notFoundComponent &&\n      (this.options as any)?.defaultNotFoundComponent\n    ) {\n      routeCursor.options.notFoundComponent = (\n        this.options as any\n      ).defaultNotFoundComponent\n    }\n\n    // Ensure we have a notFoundComponent\n    invariant(\n      routeCursor.options.notFoundComponent,\n      'No notFoundComponent found. Please set a notFoundComponent on your route or provide a defaultNotFoundComponent to the router.',\n    )\n\n    // Find the match for this route\n    const matchForRoute = matchesByRouteId[routeCursor.id]\n\n    invariant(\n      matchForRoute,\n      'Could not find match for route: ' + routeCursor.id,\n    )\n\n    // Assign the error to the match - using non-null assertion since we've checked with invariant\n    updateMatch(matchForRoute.id, (prev) => ({\n      ...prev,\n      status: 'notFound',\n      error: err,\n      isFetching: false,\n    }))\n\n    if ((err as any).routerCode === 'BEFORE_LOAD' && routeCursor.parentRoute) {\n      err.routeId = routeCursor.parentRoute.id\n      this._handleNotFound(matches, err, {\n        updateMatch,\n      })\n    }\n  }\n\n  hasNotFoundMatch = () => {\n    return this.__store.state.matches.some(\n      (d) => d.status === 'notFound' || d.globalNotFound,\n    )\n  }\n}\n\nexport class SearchParamError extends Error {}\n\nexport class PathParamError extends Error {}\n\n// A function that takes an import() argument which is a function and returns a new function that will\n// proxy arguments from the caller to the imported function, retaining all type\n// information along the way\nexport function lazyFn<\n  T extends Record<string, (...args: Array<any>) => any>,\n  TKey extends keyof T = 'default',\n>(fn: () => Promise<T>, key?: TKey) {\n  return async (\n    ...args: Parameters<T[TKey]>\n  ): Promise<Awaited<ReturnType<T[TKey]>>> => {\n    const imported = await fn()\n    return imported[key || 'default'](...args)\n  }\n}\n\nexport function getInitialRouterState(\n  location: ParsedLocation,\n): RouterState<any> {\n  return {\n    loadedAt: 0,\n    isLoading: false,\n    isTransitioning: false,\n    status: 'idle',\n    resolvedLocation: undefined,\n    location,\n    matches: [],\n    pendingMatches: [],\n    cachedMatches: [],\n    statusCode: 200,\n  }\n}\n\nfunction validateSearch(validateSearch: AnyValidator, input: unknown): unknown {\n  if (validateSearch == null) return {}\n\n  if ('~standard' in validateSearch) {\n    const result = validateSearch['~standard'].validate(input)\n\n    if (result instanceof Promise)\n      throw new SearchParamError('Async validation not supported')\n\n    if (result.issues)\n      throw new SearchParamError(JSON.stringify(result.issues, undefined, 2), {\n        cause: result,\n      })\n\n    return result.value\n  }\n\n  if ('parse' in validateSearch) {\n    return validateSearch.parse(input)\n  }\n\n  if (typeof validateSearch === 'function') {\n    return validateSearch(input)\n  }\n\n  return {}\n}\n\nexport const componentTypes = [\n  'component',\n  'errorComponent',\n  'pendingComponent',\n  'notFoundComponent',\n] as const\n\nfunction routeNeedsPreload(route: AnyRoute) {\n  for (const componentType of componentTypes) {\n    if ((route.options[componentType] as any)?.preload) {\n      return true\n    }\n  }\n  return false\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}