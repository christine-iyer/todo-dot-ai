{"ast":null,"code":"const stateIndexKey = \"__TSR_index\";\nconst popStateEvent = \"popstate\";\nconst beforeUnloadEvent = \"beforeunload\";\nfunction createHistory(opts) {\n  let location = opts.getLocation();\n  const subscribers = /* @__PURE__ */new Set();\n  const notify = action => {\n    location = opts.getLocation();\n    subscribers.forEach(subscriber => subscriber({\n      location,\n      action\n    }));\n  };\n  const handleIndexChange = action => {\n    if (opts.notifyOnIndexChange ?? true) notify(action);else location = opts.getLocation();\n  };\n  const tryNavigation = async ({\n    task,\n    navigateOpts,\n    ...actionInfo\n  }) => {\n    var _a, _b;\n    const ignoreBlocker = (navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false;\n    if (ignoreBlocker) {\n      task();\n      return;\n    }\n    const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [];\n    const isPushOrReplace = actionInfo.type === \"PUSH\" || actionInfo.type === \"REPLACE\";\n    if (typeof document !== \"undefined\" && blockers.length && isPushOrReplace) {\n      for (const blocker of blockers) {\n        const nextLocation = parseHref(actionInfo.path, actionInfo.state);\n        const isBlocked = await blocker.blockerFn({\n          currentLocation: location,\n          nextLocation,\n          action: actionInfo.type\n        });\n        if (isBlocked) {\n          (_b = opts.onBlocked) == null ? void 0 : _b.call(opts);\n          return;\n        }\n      }\n    }\n    task();\n  };\n  return {\n    get location() {\n      return location;\n    },\n    get length() {\n      return opts.getLength();\n    },\n    subscribers,\n    subscribe: cb => {\n      subscribers.add(cb);\n      return () => {\n        subscribers.delete(cb);\n      };\n    },\n    push: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex + 1, state);\n      tryNavigation({\n        task: () => {\n          opts.pushState(path, state);\n          notify({\n            type: \"PUSH\"\n          });\n        },\n        navigateOpts,\n        type: \"PUSH\",\n        path,\n        state\n      });\n    },\n    replace: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey];\n      state = assignKeyAndIndex(currentIndex, state);\n      tryNavigation({\n        task: () => {\n          opts.replaceState(path, state);\n          notify({\n            type: \"REPLACE\"\n          });\n        },\n        navigateOpts,\n        type: \"REPLACE\",\n        path,\n        state\n      });\n    },\n    go: (index, navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.go(index);\n          handleIndexChange({\n            type: \"GO\",\n            index\n          });\n        },\n        navigateOpts,\n        type: \"GO\"\n      });\n    },\n    back: navigateOpts => {\n      tryNavigation({\n        task: () => {\n          opts.back((navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false);\n          handleIndexChange({\n            type: \"BACK\"\n          });\n        },\n        navigateOpts,\n        type: \"BACK\"\n      });\n    },\n    forward: navigateOpts => {\n      tryNavigation({\n        task: () => {\n          opts.forward((navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false);\n          handleIndexChange({\n            type: \"FORWARD\"\n          });\n        },\n        navigateOpts,\n        type: \"FORWARD\"\n      });\n    },\n    canGoBack: () => location.state[stateIndexKey] !== 0,\n    createHref: str => opts.createHref(str),\n    block: blocker => {\n      var _a;\n      if (!opts.setBlockers) return () => {};\n      const blockers = ((_a = opts.getBlockers) == null ? void 0 : _a.call(opts)) ?? [];\n      opts.setBlockers([...blockers, blocker]);\n      return () => {\n        var _a2, _b;\n        const blockers2 = ((_a2 = opts.getBlockers) == null ? void 0 : _a2.call(opts)) ?? [];\n        (_b = opts.setBlockers) == null ? void 0 : _b.call(opts, blockers2.filter(b => b !== blocker));\n      };\n    },\n    flush: () => {\n      var _a;\n      return (_a = opts.flush) == null ? void 0 : _a.call(opts);\n    },\n    destroy: () => {\n      var _a;\n      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);\n    },\n    notify\n  };\n}\nfunction assignKeyAndIndex(index, state) {\n  if (!state) {\n    state = {};\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n    [stateIndexKey]: index\n  };\n}\nfunction createBrowserHistory(opts) {\n  var _a;\n  const win = (opts == null ? void 0 : opts.window) ?? (typeof document !== \"undefined\" ? window : void 0);\n  const originalPushState = win.history.pushState;\n  const originalReplaceState = win.history.replaceState;\n  let blockers = [];\n  const _getBlockers = () => blockers;\n  const _setBlockers = newBlockers => blockers = newBlockers;\n  const createHref = (opts == null ? void 0 : opts.createHref) ?? (path => path);\n  const parseLocation = (opts == null ? void 0 : opts.parseLocation) ?? (() => parseHref(`${win.location.pathname}${win.location.search}${win.location.hash}`, win.history.state));\n  if (!((_a = win.history.state) == null ? void 0 : _a.key)) {\n    win.history.replaceState({\n      [stateIndexKey]: 0,\n      key: createRandomKey()\n    }, \"\");\n  }\n  let currentLocation = parseLocation();\n  let rollbackLocation;\n  let nextPopIsGo = false;\n  let ignoreNextPop = false;\n  let skipBlockerNextPop = false;\n  let ignoreNextBeforeUnload = false;\n  const getLocation = () => currentLocation;\n  let next;\n  let scheduled;\n  const flush = () => {\n    if (!next) {\n      return;\n    }\n    history._ignoreSubscribers = true;\n    (next.isPush ? win.history.pushState : win.history.replaceState)(next.state, \"\", next.href);\n    history._ignoreSubscribers = false;\n    next = void 0;\n    scheduled = void 0;\n    rollbackLocation = void 0;\n  };\n  const queueHistoryAction = (type, destHref, state) => {\n    const href = createHref(destHref);\n    if (!scheduled) {\n      rollbackLocation = currentLocation;\n    }\n    currentLocation = parseHref(destHref, state);\n    next = {\n      href,\n      state,\n      isPush: (next == null ? void 0 : next.isPush) || type === \"push\"\n    };\n    if (!scheduled) {\n      scheduled = Promise.resolve().then(() => flush());\n    }\n  };\n  const onPushPop = type => {\n    currentLocation = parseLocation();\n    history.notify({\n      type\n    });\n  };\n  const onPushPopEvent = async () => {\n    if (ignoreNextPop) {\n      ignoreNextPop = false;\n      return;\n    }\n    const nextLocation = parseLocation();\n    const delta = nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey];\n    const isForward = delta === 1;\n    const isBack = delta === -1;\n    const isGo = !isForward && !isBack || nextPopIsGo;\n    nextPopIsGo = false;\n    const action = isGo ? \"GO\" : isBack ? \"BACK\" : \"FORWARD\";\n    const notify = isGo ? {\n      type: \"GO\",\n      index: delta\n    } : {\n      type: isBack ? \"BACK\" : \"FORWARD\"\n    };\n    if (skipBlockerNextPop) {\n      skipBlockerNextPop = false;\n    } else {\n      const blockers2 = _getBlockers();\n      if (typeof document !== \"undefined\" && blockers2.length) {\n        for (const blocker of blockers2) {\n          const isBlocked = await blocker.blockerFn({\n            currentLocation,\n            nextLocation,\n            action\n          });\n          if (isBlocked) {\n            ignoreNextPop = true;\n            win.history.go(1);\n            history.notify(notify);\n            return;\n          }\n        }\n      }\n    }\n    currentLocation = parseLocation();\n    history.notify(notify);\n  };\n  const onBeforeUnload = e => {\n    if (ignoreNextBeforeUnload) {\n      ignoreNextBeforeUnload = false;\n      return;\n    }\n    let shouldBlock = false;\n    const blockers2 = _getBlockers();\n    if (typeof document !== \"undefined\" && blockers2.length) {\n      for (const blocker of blockers2) {\n        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true;\n        if (shouldHaveBeforeUnload === true) {\n          shouldBlock = true;\n          break;\n        }\n        if (typeof shouldHaveBeforeUnload === \"function\" && shouldHaveBeforeUnload() === true) {\n          shouldBlock = true;\n          break;\n        }\n      }\n    }\n    if (shouldBlock) {\n      e.preventDefault();\n      return e.returnValue = \"\";\n    }\n    return;\n  };\n  const history = createHistory({\n    getLocation,\n    getLength: () => win.history.length,\n    pushState: (href, state) => queueHistoryAction(\"push\", href, state),\n    replaceState: (href, state) => queueHistoryAction(\"replace\", href, state),\n    back: ignoreBlocker => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      return win.history.back();\n    },\n    forward: ignoreBlocker => {\n      if (ignoreBlocker) skipBlockerNextPop = true;\n      ignoreNextBeforeUnload = true;\n      win.history.forward();\n    },\n    go: n => {\n      nextPopIsGo = true;\n      win.history.go(n);\n    },\n    createHref: href => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState;\n      win.history.replaceState = originalReplaceState;\n      win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {\n        capture: true\n      });\n      win.removeEventListener(popStateEvent, onPushPopEvent);\n    },\n    onBlocked: () => {\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation;\n      }\n    },\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers,\n    notifyOnIndexChange: false\n  });\n  win.addEventListener(beforeUnloadEvent, onBeforeUnload, {\n    capture: true\n  });\n  win.addEventListener(popStateEvent, onPushPopEvent);\n  win.history.pushState = function (...args) {\n    const res = originalPushState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"PUSH\");\n    return res;\n  };\n  win.history.replaceState = function (...args) {\n    const res = originalReplaceState.apply(win.history, args);\n    if (!history._ignoreSubscribers) onPushPop(\"REPLACE\");\n    return res;\n  };\n  return history;\n}\nfunction createHashHistory(opts) {\n  const win = (opts == null ? void 0 : opts.window) ?? (typeof document !== \"undefined\" ? window : void 0);\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashSplit = win.location.hash.split(\"#\").slice(1);\n      const pathPart = hashSplit[0] ?? \"/\";\n      const searchPart = win.location.search;\n      const hashEntries = hashSplit.slice(1);\n      const hashPart = hashEntries.length === 0 ? \"\" : `#${hashEntries.join(\"#\")}`;\n      const hashHref = `${pathPart}${searchPart}${hashPart}`;\n      return parseHref(hashHref, win.history.state);\n    },\n    createHref: href => `${win.location.pathname}${win.location.search}#${href}`\n  });\n}\nfunction createMemoryHistory(opts = {\n  initialEntries: [\"/\"]\n}) {\n  const entries = opts.initialEntries;\n  let index = opts.initialIndex ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1) : entries.length - 1;\n  const states = entries.map((_entry, index2) => assignKeyAndIndex(index2, void 0));\n  const getLocation = () => parseHref(entries[index], states[index]);\n  return createHistory({\n    getLocation,\n    getLength: () => entries.length,\n    pushState: (path, state) => {\n      if (index < entries.length - 1) {\n        entries.splice(index + 1);\n        states.splice(index + 1);\n      }\n      states.push(state);\n      entries.push(path);\n      index = Math.max(entries.length - 1, 0);\n    },\n    replaceState: (path, state) => {\n      states[index] = state;\n      entries[index] = path;\n    },\n    back: () => {\n      index = Math.max(index - 1, 0);\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1);\n    },\n    go: n => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1);\n    },\n    createHref: path => path\n  });\n}\nfunction parseHref(href, state) {\n  const hashIndex = href.indexOf(\"#\");\n  const searchIndex = href.indexOf(\"?\");\n  return {\n    href,\n    pathname: href.substring(0, hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : \"\",\n    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : \"\",\n    state: state || {\n      [stateIndexKey]: 0,\n      key: createRandomKey()\n    }\n  };\n}\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7);\n}\nexport { createBrowserHistory, createHashHistory, createHistory, createMemoryHistory, parseHref };","map":{"version":3,"names":["stateIndexKey","popStateEvent","beforeUnloadEvent","createHistory","opts","location","getLocation","subscribers","Set","notify","action","forEach","subscriber","handleIndexChange","notifyOnIndexChange","tryNavigation","task","navigateOpts","actionInfo","_a","_b","ignoreBlocker","blockers","getBlockers","call","isPushOrReplace","type","document","length","blocker","nextLocation","parseHref","path","state","isBlocked","blockerFn","currentLocation","onBlocked","getLength","subscribe","cb","add","delete","push","currentIndex","assignKeyAndIndex","pushState","replace","replaceState","go","index","back","forward","canGoBack","createHref","str","block","setBlockers","_a2","blockers2","filter","b","flush","destroy","key","createRandomKey","createBrowserHistory","win","window","originalPushState","history","originalReplaceState","_getBlockers","_setBlockers","newBlockers","parseLocation","pathname","search","hash","rollbackLocation","nextPopIsGo","ignoreNextPop","skipBlockerNextPop","ignoreNextBeforeUnload","next","scheduled","_ignoreSubscribers","isPush","href","queueHistoryAction","destHref","Promise","resolve","then","onPushPop","onPushPopEvent","delta","isForward","isBack","isGo","onBeforeUnload","e","shouldBlock","shouldHaveBeforeUnload","enableBeforeUnload","preventDefault","returnValue","n","removeEventListener","capture","addEventListener","args","res","apply","createHashHistory","hashSplit","split","slice","pathPart","searchPart","hashEntries","hashPart","join","hashHref","createMemoryHistory","initialEntries","entries","initialIndex","Math","min","max","states","map","_entry","index2","splice","hashIndex","indexOf","searchIndex","substring","random","toString"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/history/src/index.ts"],"sourcesContent":["// While the public API was clearly inspired by the \"history\" npm package,\n// This implementation attempts to be more lightweight by\n// making assumptions about the way TanStack Router works\n\nexport interface NavigateOptions {\n  ignoreBlocker?: boolean\n}\n\ntype SubscriberHistoryAction =\n  | {\n      type: Exclude<HistoryAction, 'GO'>\n    }\n  | {\n      type: 'GO'\n      index: number\n    }\n\ntype SubscriberArgs = {\n  location: HistoryLocation\n  action: SubscriberHistoryAction\n}\n\nexport interface RouterHistory {\n  location: HistoryLocation\n  length: number\n  subscribers: Set<(opts: SubscriberArgs) => void>\n  subscribe: (cb: (opts: SubscriberArgs) => void) => () => void\n  push: (path: string, state?: any, navigateOpts?: NavigateOptions) => void\n  replace: (path: string, state?: any, navigateOpts?: NavigateOptions) => void\n  go: (index: number, navigateOpts?: NavigateOptions) => void\n  back: (navigateOpts?: NavigateOptions) => void\n  forward: (navigateOpts?: NavigateOptions) => void\n  canGoBack: () => boolean\n  createHref: (href: string) => string\n  block: (blocker: NavigationBlocker) => () => void\n  flush: () => void\n  destroy: () => void\n  notify: (action: SubscriberHistoryAction) => void\n  _ignoreSubscribers?: boolean\n}\n\nexport interface HistoryLocation extends ParsedPath {\n  state: ParsedHistoryState\n}\n\nexport interface ParsedPath {\n  href: string\n  pathname: string\n  search: string\n  hash: string\n}\n\nexport interface HistoryState {}\n\nexport type ParsedHistoryState = HistoryState & {\n  key?: string\n  __TSR_index: number\n}\n\ntype ShouldAllowNavigation = any\n\nexport type HistoryAction = 'PUSH' | 'REPLACE' | 'FORWARD' | 'BACK' | 'GO'\n\nexport type BlockerFnArgs = {\n  currentLocation: HistoryLocation\n  nextLocation: HistoryLocation\n  action: HistoryAction\n}\n\nexport type BlockerFn = (\n  args: BlockerFnArgs,\n) => Promise<ShouldAllowNavigation> | ShouldAllowNavigation\n\nexport type NavigationBlocker = {\n  blockerFn: BlockerFn\n  enableBeforeUnload?: (() => boolean) | boolean\n}\n\ntype TryNavigateArgs = {\n  task: () => void\n  type: 'PUSH' | 'REPLACE' | 'BACK' | 'FORWARD' | 'GO'\n  navigateOpts?: NavigateOptions\n} & (\n  | {\n      type: 'PUSH' | 'REPLACE'\n      path: string\n      state: any\n    }\n  | {\n      type: 'BACK' | 'FORWARD' | 'GO'\n    }\n)\n\nconst stateIndexKey = '__TSR_index'\nconst popStateEvent = 'popstate'\nconst beforeUnloadEvent = 'beforeunload'\n\nexport function createHistory(opts: {\n  getLocation: () => HistoryLocation\n  getLength: () => number\n  pushState: (path: string, state: any) => void\n  replaceState: (path: string, state: any) => void\n  go: (n: number) => void\n  back: (ignoreBlocker: boolean) => void\n  forward: (ignoreBlocker: boolean) => void\n  createHref: (path: string) => string\n  flush?: () => void\n  destroy?: () => void\n  onBlocked?: () => void\n  getBlockers?: () => Array<NavigationBlocker>\n  setBlockers?: (blockers: Array<NavigationBlocker>) => void\n  // Avoid notifying on forward/back/go, used for browser history as we already get notified by the popstate event\n  notifyOnIndexChange?: boolean\n}): RouterHistory {\n  let location = opts.getLocation()\n  const subscribers = new Set<(opts: SubscriberArgs) => void>()\n\n  const notify = (action: SubscriberHistoryAction) => {\n    location = opts.getLocation()\n    subscribers.forEach((subscriber) => subscriber({ location, action }))\n  }\n\n  const handleIndexChange = (action: SubscriberHistoryAction) => {\n    if (opts.notifyOnIndexChange ?? true) notify(action)\n    else location = opts.getLocation()\n  }\n\n  const tryNavigation = async ({\n    task,\n    navigateOpts,\n    ...actionInfo\n  }: TryNavigateArgs) => {\n    const ignoreBlocker = navigateOpts?.ignoreBlocker ?? false\n    if (ignoreBlocker) {\n      task()\n      return\n    }\n\n    const blockers = opts.getBlockers?.() ?? []\n    const isPushOrReplace =\n      actionInfo.type === 'PUSH' || actionInfo.type === 'REPLACE'\n    if (typeof document !== 'undefined' && blockers.length && isPushOrReplace) {\n      for (const blocker of blockers) {\n        const nextLocation = parseHref(actionInfo.path, actionInfo.state)\n        const isBlocked = await blocker.blockerFn({\n          currentLocation: location,\n          nextLocation,\n          action: actionInfo.type,\n        })\n        if (isBlocked) {\n          opts.onBlocked?.()\n          return\n        }\n      }\n    }\n\n    task()\n  }\n\n  return {\n    get location() {\n      return location\n    },\n    get length() {\n      return opts.getLength()\n    },\n    subscribers,\n    subscribe: (cb: (opts: SubscriberArgs) => void) => {\n      subscribers.add(cb)\n\n      return () => {\n        subscribers.delete(cb)\n      }\n    },\n    push: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey]\n      state = assignKeyAndIndex(currentIndex + 1, state)\n      tryNavigation({\n        task: () => {\n          opts.pushState(path, state)\n          notify({ type: 'PUSH' })\n        },\n        navigateOpts,\n        type: 'PUSH',\n        path,\n        state,\n      })\n    },\n    replace: (path, state, navigateOpts) => {\n      const currentIndex = location.state[stateIndexKey]\n      state = assignKeyAndIndex(currentIndex, state)\n      tryNavigation({\n        task: () => {\n          opts.replaceState(path, state)\n          notify({ type: 'REPLACE' })\n        },\n        navigateOpts,\n        type: 'REPLACE',\n        path,\n        state,\n      })\n    },\n    go: (index, navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.go(index)\n          handleIndexChange({ type: 'GO', index })\n        },\n        navigateOpts,\n        type: 'GO',\n      })\n    },\n    back: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.back(navigateOpts?.ignoreBlocker ?? false)\n          handleIndexChange({ type: 'BACK' })\n        },\n        navigateOpts,\n        type: 'BACK',\n      })\n    },\n    forward: (navigateOpts) => {\n      tryNavigation({\n        task: () => {\n          opts.forward(navigateOpts?.ignoreBlocker ?? false)\n          handleIndexChange({ type: 'FORWARD' })\n        },\n        navigateOpts,\n        type: 'FORWARD',\n      })\n    },\n    canGoBack: () => location.state[stateIndexKey] !== 0,\n    createHref: (str) => opts.createHref(str),\n    block: (blocker) => {\n      if (!opts.setBlockers) return () => {}\n      const blockers = opts.getBlockers?.() ?? []\n      opts.setBlockers([...blockers, blocker])\n\n      return () => {\n        const blockers = opts.getBlockers?.() ?? []\n        opts.setBlockers?.(blockers.filter((b) => b !== blocker))\n      }\n    },\n    flush: () => opts.flush?.(),\n    destroy: () => opts.destroy?.(),\n    notify,\n  }\n}\n\nfunction assignKeyAndIndex(index: number, state: HistoryState | undefined) {\n  if (!state) {\n    state = {} as HistoryState\n  }\n  return {\n    ...state,\n    key: createRandomKey(),\n    [stateIndexKey]: index,\n  } as ParsedHistoryState\n}\n\n/**\n * Creates a history object that can be used to interact with the browser's\n * navigation. This is a lightweight API wrapping the browser's native methods.\n * It is designed to work with TanStack Router, but could be used as a standalone API as well.\n * IMPORTANT: This API implements history throttling via a microtask to prevent\n * excessive calls to the history API. In some browsers, calling history.pushState or\n * history.replaceState in quick succession can cause the browser to ignore subsequent\n * calls. This API smooths out those differences and ensures that your application\n * state will *eventually* match the browser state. In most cases, this is not a problem,\n * but if you need to ensure that the browser state is up to date, you can use the\n * `history.flush` method to immediately flush all pending state changes to the browser URL.\n * @param opts\n * @param opts.getHref A function that returns the current href (path + search + hash)\n * @param opts.createHref A function that takes a path and returns a href (path + search + hash)\n * @returns A history instance\n */\nexport function createBrowserHistory(opts?: {\n  parseLocation?: () => HistoryLocation\n  createHref?: (path: string) => string\n  window?: any\n}): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n\n  const originalPushState = win.history.pushState\n  const originalReplaceState = win.history.replaceState\n\n  let blockers: Array<NavigationBlocker> = []\n  const _getBlockers = () => blockers\n  const _setBlockers = (newBlockers: Array<NavigationBlocker>) =>\n    (blockers = newBlockers)\n\n  const createHref = opts?.createHref ?? ((path) => path)\n  const parseLocation =\n    opts?.parseLocation ??\n    (() =>\n      parseHref(\n        `${win.location.pathname}${win.location.search}${win.location.hash}`,\n        win.history.state,\n      ))\n\n  // Ensure there is always a key to start\n  if (!win.history.state?.key) {\n    win.history.replaceState(\n      {\n        [stateIndexKey]: 0,\n        key: createRandomKey(),\n      },\n      '',\n    )\n  }\n\n  let currentLocation = parseLocation()\n  let rollbackLocation: HistoryLocation | undefined\n\n  let nextPopIsGo = false\n  let ignoreNextPop = false\n  let skipBlockerNextPop = false\n  let ignoreNextBeforeUnload = false\n\n  const getLocation = () => currentLocation\n\n  let next:\n    | undefined\n    | {\n        // This is the latest location that we were attempting to push/replace\n        href: string\n        // This is the latest state that we were attempting to push/replace\n        state: any\n        // This is the latest type that we were attempting to push/replace\n        isPush: boolean\n      }\n\n  // We need to track the current scheduled update to prevent\n  // multiple updates from being scheduled at the same time.\n  let scheduled: Promise<void> | undefined\n\n  // This function flushes the next update to the browser history\n  const flush = () => {\n    if (!next) {\n      return\n    }\n\n    // We need to ignore any updates to the subscribers while we update the browser history\n    history._ignoreSubscribers = true\n\n    // Update the browser history\n    ;(next.isPush ? win.history.pushState : win.history.replaceState)(\n      next.state,\n      '',\n      next.href,\n    )\n\n    // Stop ignoring subscriber updates\n    history._ignoreSubscribers = false\n\n    // Reset the nextIsPush flag and clear the scheduled update\n    next = undefined\n    scheduled = undefined\n    rollbackLocation = undefined\n  }\n\n  // This function queues up a call to update the browser history\n  const queueHistoryAction = (\n    type: 'push' | 'replace',\n    destHref: string,\n    state: any,\n  ) => {\n    const href = createHref(destHref)\n\n    if (!scheduled) {\n      rollbackLocation = currentLocation\n    }\n\n    // Update the location in memory\n    currentLocation = parseHref(destHref, state)\n\n    // Keep track of the next location we need to flush to the URL\n    next = {\n      href,\n      state,\n      isPush: next?.isPush || type === 'push',\n    }\n\n    if (!scheduled) {\n      // Schedule an update to the browser history\n      scheduled = Promise.resolve().then(() => flush())\n    }\n  }\n\n  // NOTE: this function can probably be removed\n  const onPushPop = (type: 'PUSH' | 'REPLACE') => {\n    currentLocation = parseLocation()\n    history.notify({ type })\n  }\n\n  const onPushPopEvent = async () => {\n    if (ignoreNextPop) {\n      ignoreNextPop = false\n      return\n    }\n\n    const nextLocation = parseLocation()\n    const delta =\n      nextLocation.state[stateIndexKey] - currentLocation.state[stateIndexKey]\n    const isForward = delta === 1\n    const isBack = delta === -1\n    const isGo = (!isForward && !isBack) || nextPopIsGo\n    nextPopIsGo = false\n\n    const action = isGo ? 'GO' : isBack ? 'BACK' : 'FORWARD'\n    const notify: SubscriberHistoryAction = isGo\n      ? {\n          type: 'GO',\n          index: delta,\n        }\n      : {\n          type: isBack ? 'BACK' : 'FORWARD',\n        }\n\n    if (skipBlockerNextPop) {\n      skipBlockerNextPop = false\n    } else {\n      const blockers = _getBlockers()\n      if (typeof document !== 'undefined' && blockers.length) {\n        for (const blocker of blockers) {\n          const isBlocked = await blocker.blockerFn({\n            currentLocation,\n            nextLocation,\n            action,\n          })\n          if (isBlocked) {\n            ignoreNextPop = true\n            win.history.go(1)\n            history.notify(notify)\n            return\n          }\n        }\n      }\n    }\n\n    currentLocation = parseLocation()\n    history.notify(notify)\n  }\n\n  const onBeforeUnload = (e: BeforeUnloadEvent) => {\n    if (ignoreNextBeforeUnload) {\n      ignoreNextBeforeUnload = false\n      return\n    }\n\n    let shouldBlock = false\n\n    // If one blocker has a non-disabled beforeUnload, we should block\n    const blockers = _getBlockers()\n    if (typeof document !== 'undefined' && blockers.length) {\n      for (const blocker of blockers) {\n        const shouldHaveBeforeUnload = blocker.enableBeforeUnload ?? true\n        if (shouldHaveBeforeUnload === true) {\n          shouldBlock = true\n          break\n        }\n\n        if (\n          typeof shouldHaveBeforeUnload === 'function' &&\n          shouldHaveBeforeUnload() === true\n        ) {\n          shouldBlock = true\n          break\n        }\n      }\n    }\n\n    if (shouldBlock) {\n      e.preventDefault()\n      return (e.returnValue = '')\n    }\n    return\n  }\n\n  const history = createHistory({\n    getLocation,\n    getLength: () => win.history.length,\n    pushState: (href, state) => queueHistoryAction('push', href, state),\n    replaceState: (href, state) => queueHistoryAction('replace', href, state),\n    back: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true\n      ignoreNextBeforeUnload = true\n      return win.history.back()\n    },\n    forward: (ignoreBlocker) => {\n      if (ignoreBlocker) skipBlockerNextPop = true\n      ignoreNextBeforeUnload = true\n      win.history.forward()\n    },\n    go: (n) => {\n      nextPopIsGo = true\n      win.history.go(n)\n    },\n    createHref: (href) => createHref(href),\n    flush,\n    destroy: () => {\n      win.history.pushState = originalPushState\n      win.history.replaceState = originalReplaceState\n      win.removeEventListener(beforeUnloadEvent, onBeforeUnload, {\n        capture: true,\n      })\n      win.removeEventListener(popStateEvent, onPushPopEvent)\n    },\n    onBlocked: () => {\n      // If a navigation is blocked, we need to rollback the location\n      // that we optimistically updated in memory.\n      if (rollbackLocation && currentLocation !== rollbackLocation) {\n        currentLocation = rollbackLocation\n      }\n    },\n    getBlockers: _getBlockers,\n    setBlockers: _setBlockers,\n    notifyOnIndexChange: false,\n  })\n\n  win.addEventListener(beforeUnloadEvent, onBeforeUnload, { capture: true })\n  win.addEventListener(popStateEvent, onPushPopEvent)\n\n  win.history.pushState = function (...args: Array<any>) {\n    const res = originalPushState.apply(win.history, args as any)\n    if (!history._ignoreSubscribers) onPushPop('PUSH')\n    return res\n  }\n\n  win.history.replaceState = function (...args: Array<any>) {\n    const res = originalReplaceState.apply(win.history, args as any)\n    if (!history._ignoreSubscribers) onPushPop('REPLACE')\n    return res\n  }\n\n  return history\n}\n\nexport function createHashHistory(opts?: { window?: any }): RouterHistory {\n  const win =\n    opts?.window ??\n    (typeof document !== 'undefined' ? window : (undefined as any))\n  return createBrowserHistory({\n    window: win,\n    parseLocation: () => {\n      const hashSplit = win.location.hash.split('#').slice(1)\n      const pathPart = hashSplit[0] ?? '/'\n      const searchPart = win.location.search\n      const hashEntries = hashSplit.slice(1)\n      const hashPart =\n        hashEntries.length === 0 ? '' : `#${hashEntries.join('#')}`\n      const hashHref = `${pathPart}${searchPart}${hashPart}`\n      return parseHref(hashHref, win.history.state)\n    },\n    createHref: (href) =>\n      `${win.location.pathname}${win.location.search}#${href}`,\n  })\n}\n\nexport function createMemoryHistory(\n  opts: {\n    initialEntries: Array<string>\n    initialIndex?: number\n  } = {\n    initialEntries: ['/'],\n  },\n): RouterHistory {\n  const entries = opts.initialEntries\n  let index = opts.initialIndex\n    ? Math.min(Math.max(opts.initialIndex, 0), entries.length - 1)\n    : entries.length - 1\n  const states = entries.map((_entry, index) =>\n    assignKeyAndIndex(index, undefined),\n  )\n\n  const getLocation = () => parseHref(entries[index]!, states[index])\n\n  return createHistory({\n    getLocation,\n    getLength: () => entries.length,\n    pushState: (path, state) => {\n      // Removes all subsequent entries after the current index to start a new branch\n      if (index < entries.length - 1) {\n        entries.splice(index + 1)\n        states.splice(index + 1)\n      }\n      states.push(state)\n      entries.push(path)\n      index = Math.max(entries.length - 1, 0)\n    },\n    replaceState: (path, state) => {\n      states[index] = state\n      entries[index] = path\n    },\n    back: () => {\n      index = Math.max(index - 1, 0)\n    },\n    forward: () => {\n      index = Math.min(index + 1, entries.length - 1)\n    },\n    go: (n) => {\n      index = Math.min(Math.max(index + n, 0), entries.length - 1)\n    },\n    createHref: (path) => path,\n  })\n}\n\nexport function parseHref(\n  href: string,\n  state: ParsedHistoryState | undefined,\n): HistoryLocation {\n  const hashIndex = href.indexOf('#')\n  const searchIndex = href.indexOf('?')\n\n  return {\n    href,\n    pathname: href.substring(\n      0,\n      hashIndex > 0\n        ? searchIndex > 0\n          ? Math.min(hashIndex, searchIndex)\n          : hashIndex\n        : searchIndex > 0\n          ? searchIndex\n          : href.length,\n    ),\n    hash: hashIndex > -1 ? href.substring(hashIndex) : '',\n    search:\n      searchIndex > -1\n        ? href.slice(searchIndex, hashIndex === -1 ? undefined : hashIndex)\n        : '',\n    state: state || { [stateIndexKey]: 0, key: createRandomKey() },\n  }\n}\n\n// Thanks co-pilot!\nfunction createRandomKey() {\n  return (Math.random() + 1).toString(36).substring(7)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}