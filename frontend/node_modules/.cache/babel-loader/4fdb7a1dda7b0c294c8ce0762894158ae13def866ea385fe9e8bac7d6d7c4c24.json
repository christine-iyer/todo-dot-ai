{"ast":null,"code":"import { jsx } from \"react/jsx-runtime\";\nimport { isNotFound } from \"@tanstack/router-core\";\nimport { CatchBoundary } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nfunction CatchNotFound(props) {\n  const resetKey = useRouterState({\n    select: s => `not-found-${s.location.pathname}-${s.status}`\n  });\n  return /* @__PURE__ */jsx(CatchBoundary, {\n    getResetKey: () => resetKey,\n    onCatch: (error, errorInfo) => {\n      var _a;\n      if (isNotFound(error)) {\n        (_a = props.onCatch) == null ? void 0 : _a.call(props, error, errorInfo);\n      } else {\n        throw error;\n      }\n    },\n    errorComponent: ({\n      error\n    }) => {\n      var _a;\n      if (isNotFound(error)) {\n        return (_a = props.fallback) == null ? void 0 : _a.call(props, error);\n      } else {\n        throw error;\n      }\n    },\n    children: props.children\n  });\n}\nfunction DefaultGlobalNotFound() {\n  return /* @__PURE__ */jsx(\"p\", {\n    children: \"Not Found\"\n  });\n}\nexport { CatchNotFound, DefaultGlobalNotFound };","map":{"version":3,"names":["CatchNotFound","props","resetKey","useRouterState","select","s","location","pathname","status","jsx","CatchBoundary","getResetKey","onCatch","error","errorInfo","isNotFound","_a","call","errorComponent","fallback","children","DefaultGlobalNotFound"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/not-found.tsx"],"sourcesContent":["import * as React from 'react'\nimport { isNotFound } from '@tanstack/router-core'\nimport { CatchBoundary } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport type { ErrorInfo } from 'react'\nimport type { NotFoundError } from '@tanstack/router-core'\n\nexport function CatchNotFound(props: {\n  fallback?: (error: NotFoundError) => React.ReactElement\n  onCatch?: (error: Error, errorInfo: ErrorInfo) => void\n  children: React.ReactNode\n}) {\n  // TODO: Some way for the user to programmatically reset the not-found boundary?\n  const resetKey = useRouterState({\n    select: (s) => `not-found-${s.location.pathname}-${s.status}`,\n  })\n\n  return (\n    <CatchBoundary\n      getResetKey={() => resetKey}\n      onCatch={(error, errorInfo) => {\n        if (isNotFound(error)) {\n          props.onCatch?.(error, errorInfo)\n        } else {\n          throw error\n        }\n      }}\n      errorComponent={({ error }: { error: Error }) => {\n        if (isNotFound(error)) {\n          return props.fallback?.(error)\n        } else {\n          throw error\n        }\n      }}\n    >\n      {props.children}\n    </CatchBoundary>\n  )\n}\n\nexport function DefaultGlobalNotFound() {\n  return <p>Not Found</p>\n}\n"],"mappings":";;;;AAOO,SAASA,cAAcC,KAAA,EAI3B;EAED,MAAMC,QAAA,GAAWC,cAAA,CAAe;IAC9BC,MAAA,EAASC,CAAA,IAAM,aAAaA,CAAA,CAAEC,QAAA,CAASC,QAAQ,IAAIF,CAAA,CAAEG,MAAM;EAAA,CAC5D;EAGC,sBAAAC,GAAA,CAACC,aAAA;IACCC,WAAA,EAAaA,CAAA,KAAMT,QAAA;IACnBU,OAAA,EAASA,CAACC,KAAA,EAAOC,SAAA,KAAc;;MACzB,IAAAC,UAAA,CAAWF,KAAK,GAAG;QACf,CAAAG,EAAA,GAAAf,KAAA,CAAAW,OAAA,qBAAAI,EAAA,CAAAC,IAAA,CAAAhB,KAAA,EAAUY,KAAA,EAAOC,SAAA;MAAS,OAC3B;QACC,MAAAD,KAAA;MAAA;IAEV;IACAK,cAAA,EAAgBA,CAAC;MAAEL;IAAA,MAA8B;;MAC3C,IAAAE,UAAA,CAAWF,KAAK,GAAG;QACd,QAAAG,EAAA,GAAAf,KAAA,CAAMkB,QAAA,KAAN,gBAAAH,EAAA,CAAAC,IAAA,CAAAhB,KAAA,EAAiBY,KAAA;MAAK,OACxB;QACC,MAAAA,KAAA;MAAA;IAEV;IAECO,QAAA,EAAMnB,KAAA,CAAAmB;EAAA,CACT;AAEJ;AAEO,SAASC,sBAAA,EAAwB;EAC/B,sBAAAZ,GAAA,CAAC;IAAEW,QAAA,EAAS;EAAA;AACrB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}