{"ast":null,"code":"import { hasUriEncodedChars } from \"./utils.js\";\nfunction encode(obj, pfx) {\n  const normalizedObject = Object.entries(obj).flatMap(([key, value]) => {\n    if (Array.isArray(value)) {\n      return value.map(v => [key, String(v)]);\n    } else {\n      return [[key, String(value)]];\n    }\n  });\n  const searchParams = new URLSearchParams(normalizedObject);\n  return (pfx || \"\") + searchParams.toString();\n}\nfunction toValue(mix) {\n  if (!mix) return \"\";\n  const str = hasUriEncodedChars(mix) ? decodeURIComponent(mix) : decodeURIComponent(encodeURIComponent(mix));\n  if (str === \"false\") return false;\n  if (str === \"true\") return true;\n  return +str * 0 === 0 && +str + \"\" === str ? +str : str;\n}\nfunction decode(str, pfx) {\n  const searchParamsPart = pfx ? str.slice(pfx.length) : str;\n  const searchParams = new URLSearchParams(searchParamsPart);\n  const entries = [...searchParams.entries()];\n  return entries.reduce((acc, [key, value]) => {\n    const previousValue = acc[key];\n    if (previousValue == null) {\n      acc[key] = toValue(value);\n    } else {\n      acc[key] = Array.isArray(previousValue) ? [...previousValue, toValue(value)] : [previousValue, toValue(value)];\n    }\n    return acc;\n  }, {});\n}\nexport { decode, encode };","map":{"version":3,"names":["encode","obj","pfx","normalizedObject","Object","entries","flatMap","key","value","Array","isArray","map","v","String","searchParams","URLSearchParams","toString","toValue","mix","str","hasUriEncodedChars","decodeURIComponent","encodeURIComponent","decode","searchParamsPart","slice","length","reduce","acc","previousValue"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/router-core/src/qss.ts"],"sourcesContent":["/**\n * Program is a reimplementation of the `qss` package:\n * Copyright (c) Luke Edwards luke.edwards05@gmail.com, MIT License\n * https://github.com/lukeed/qss/blob/master/license.md\n *\n * This reimplementation uses modern browser APIs\n * (namely URLSearchParams) and TypeScript while still\n * maintaining the original functionality and interface.\n */\nimport { hasUriEncodedChars } from './utils'\n\n/**\n * Encodes an object into a query string.\n * @param obj - The object to encode into a query string.\n * @param [pfx] - An optional prefix to add before the query string.\n * @returns The encoded query string.\n * @example\n * ```\n * // Example input: encode({ token: 'foo', key: 'value' })\n * // Expected output: \"token=foo&key=value\"\n * ```\n */\nexport function encode(obj: any, pfx?: string) {\n  const normalizedObject = Object.entries(obj).flatMap(([key, value]) => {\n    if (Array.isArray(value)) {\n      return value.map((v) => [key, String(v)])\n    } else {\n      return [[key, String(value)]]\n    }\n  })\n\n  const searchParams = new URLSearchParams(normalizedObject)\n\n  return (pfx || '') + searchParams.toString()\n}\n\n/**\n * Converts a string value to its appropriate type (string, number, boolean).\n * @param mix - The string value to convert.\n * @returns The converted value.\n * @example\n * // Example input: toValue(\"123\")\n * // Expected output: 123\n */\nfunction toValue(mix: any) {\n  if (!mix) return ''\n  const str = hasUriEncodedChars(mix)\n    ? decodeURIComponent(mix)\n    : decodeURIComponent(encodeURIComponent(mix))\n\n  if (str === 'false') return false\n  if (str === 'true') return true\n  return +str * 0 === 0 && +str + '' === str ? +str : str\n}\n\n/**\n * Decodes a query string into an object.\n * @param str - The query string to decode.\n * @param [pfx] - An optional prefix to filter out from the query string.\n * @returns The decoded key-value pairs in an object format.\n * @example\n * // Example input: decode(\"token=foo&key=value\")\n * // Expected output: { \"token\": \"foo\", \"key\": \"value\" }\n */\nexport function decode(str: any, pfx?: string): any {\n  const searchParamsPart = pfx ? str.slice(pfx.length) : str\n  const searchParams = new URLSearchParams(searchParamsPart)\n\n  const entries = [...searchParams.entries()]\n\n  return entries.reduce<Record<string, unknown>>((acc, [key, value]) => {\n    const previousValue = acc[key]\n    if (previousValue == null) {\n      acc[key] = toValue(value)\n    } else {\n      acc[key] = Array.isArray(previousValue)\n        ? [...previousValue, toValue(value)]\n        : [previousValue, toValue(value)]\n    }\n\n    return acc\n  }, {})\n}\n"],"mappings":";AAsBgB,SAAAA,OAAOC,GAAA,EAAUC,GAAA,EAAc;EACvC,MAAAC,gBAAA,GAAmBC,MAAA,CAAOC,OAAA,CAAQJ,GAAG,EAAEK,OAAA,CAAQ,CAAC,CAACC,GAAA,EAAKC,KAAK,MAAM;IACjE,IAAAC,KAAA,CAAMC,OAAA,CAAQF,KAAK,GAAG;MACjB,OAAAA,KAAA,CAAMG,GAAA,CAAKC,CAAA,IAAM,CAACL,GAAA,EAAKM,MAAA,CAAOD,CAAC,CAAC,CAAC;IAAA,OACnC;MACL,OAAO,CAAC,CAACL,GAAA,EAAKM,MAAA,CAAOL,KAAK,CAAC,CAAC;IAAA;EAC9B,CACD;EAEK,MAAAM,YAAA,GAAe,IAAIC,eAAA,CAAgBZ,gBAAgB;EAEjD,QAAAD,GAAA,IAAO,MAAMY,YAAA,CAAaE,QAAA,CAAS;AAC7C;AAUA,SAASC,QAAQC,GAAA,EAAU;EACrB,KAACA,GAAA,EAAY;EACX,MAAAC,GAAA,GAAMC,kBAAA,CAAmBF,GAAG,IAC9BG,kBAAA,CAAmBH,GAAG,IACtBG,kBAAA,CAAmBC,kBAAA,CAAmBJ,GAAG,CAAC;EAE1C,IAAAC,GAAA,KAAQ,SAAgB;EACxB,IAAAA,GAAA,KAAQ,QAAe;EACpB,QAACA,GAAA,GAAM,MAAM,KAAK,CAACA,GAAA,GAAM,OAAOA,GAAA,GAAM,CAACA,GAAA,GAAMA,GAAA;AACtD;AAWgB,SAAAI,OAAOJ,GAAA,EAAUjB,GAAA,EAAmB;EAClD,MAAMsB,gBAAA,GAAmBtB,GAAA,GAAMiB,GAAA,CAAIM,KAAA,CAAMvB,GAAA,CAAIwB,MAAM,IAAIP,GAAA;EACjD,MAAAL,YAAA,GAAe,IAAIC,eAAA,CAAgBS,gBAAgB;EAEzD,MAAMnB,OAAA,GAAU,CAAC,GAAGS,YAAA,CAAaT,OAAA,EAAS;EAE1C,OAAOA,OAAA,CAAQsB,MAAA,CAAgC,CAACC,GAAA,EAAK,CAACrB,GAAA,EAAKC,KAAK,MAAM;IAC9D,MAAAqB,aAAA,GAAgBD,GAAA,CAAIrB,GAAG;IAC7B,IAAIsB,aAAA,IAAiB,MAAM;MACrBD,GAAA,CAAArB,GAAG,IAAIU,OAAA,CAAQT,KAAK;IAAA,OACnB;MACLoB,GAAA,CAAIrB,GAAG,IAAIE,KAAA,CAAMC,OAAA,CAAQmB,aAAa,IAClC,CAAC,GAAGA,aAAA,EAAeZ,OAAA,CAAQT,KAAK,CAAC,IACjC,CAACqB,aAAA,EAAeZ,OAAA,CAAQT,KAAK,CAAC;IAAA;IAG7B,OAAAoB,GAAA;EACT,GAAG,EAAE;AACP","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}