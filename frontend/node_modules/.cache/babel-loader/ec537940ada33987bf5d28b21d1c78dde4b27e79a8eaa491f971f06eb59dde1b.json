{"ast":null,"code":"import * as React from \"react\";\nimport { useRouter } from \"./useRouter.js\";\nfunction _resolveBlockerOpts(opts, condition) {\n  if (opts === void 0) {\n    return {\n      shouldBlockFn: () => true,\n      withResolver: false\n    };\n  }\n  if (\"shouldBlockFn\" in opts) {\n    return opts;\n  }\n  if (typeof opts === \"function\") {\n    const shouldBlock2 = Boolean(condition ?? true);\n    const _customBlockerFn2 = async () => {\n      if (shouldBlock2) return await opts();\n      return false;\n    };\n    return {\n      shouldBlockFn: _customBlockerFn2,\n      enableBeforeUnload: shouldBlock2,\n      withResolver: false\n    };\n  }\n  const shouldBlock = Boolean(opts.condition ?? true);\n  const fn = opts.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n}\nfunction useBlocker(opts, condition) {\n  const {\n    shouldBlockFn,\n    enableBeforeUnload = true,\n    disabled = false,\n    withResolver = false\n  } = _resolveBlockerOpts(opts, condition);\n  const router = useRouter();\n  const {\n    history\n  } = router;\n  const [resolver, setResolver] = React.useState({\n    status: \"idle\",\n    current: void 0,\n    next: void 0,\n    action: void 0,\n    proceed: void 0,\n    reset: void 0\n  });\n  React.useEffect(() => {\n    const blockerFnComposed = async blockerFnArgs => {\n      function getLocation(location) {\n        const parsedLocation = router.parseLocation(void 0, location);\n        const matchedRoutes = router.getMatchedRoutes(parsedLocation);\n        if (matchedRoutes.foundRoute === void 0) {\n          throw new Error(`No route found for location ${location.href}`);\n        }\n        return {\n          routeId: matchedRoutes.foundRoute.id,\n          fullPath: matchedRoutes.foundRoute.fullPath,\n          pathname: parsedLocation.pathname,\n          params: matchedRoutes.routeParams,\n          search: parsedLocation.search\n        };\n      }\n      const current = getLocation(blockerFnArgs.currentLocation);\n      const next = getLocation(blockerFnArgs.nextLocation);\n      const shouldBlock = await shouldBlockFn({\n        action: blockerFnArgs.action,\n        current,\n        next\n      });\n      if (!withResolver) {\n        return shouldBlock;\n      }\n      if (!shouldBlock) {\n        return false;\n      }\n      const promise = new Promise(resolve => {\n        setResolver({\n          status: \"blocked\",\n          current,\n          next,\n          action: blockerFnArgs.action,\n          proceed: () => resolve(false),\n          reset: () => resolve(true)\n        });\n      });\n      const canNavigateAsync = await promise;\n      setResolver({\n        status: \"idle\",\n        current: void 0,\n        next: void 0,\n        action: void 0,\n        proceed: void 0,\n        reset: void 0\n      });\n      return canNavigateAsync;\n    };\n    return disabled ? void 0 : history.block({\n      blockerFn: blockerFnComposed,\n      enableBeforeUnload\n    });\n  }, [shouldBlockFn, enableBeforeUnload, disabled, withResolver, history, router]);\n  return resolver;\n}\nconst _resolvePromptBlockerArgs = props => {\n  if (\"shouldBlockFn\" in props) {\n    return {\n      ...props\n    };\n  }\n  const shouldBlock = Boolean(props.condition ?? true);\n  const fn = props.blockerFn;\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== void 0) {\n      return await fn();\n    }\n    return shouldBlock;\n  };\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === void 0\n  };\n};\nfunction Block(opts) {\n  const {\n    children,\n    ...rest\n  } = opts;\n  const args = _resolvePromptBlockerArgs(rest);\n  const resolver = useBlocker(args);\n  return children ? typeof children === \"function\" ? children(resolver) : children : null;\n}\nexport { Block, useBlocker };","map":{"version":3,"names":["_resolveBlockerOpts","opts","condition","shouldBlockFn","withResolver","shouldBlock2","Boolean","_customBlockerFn2","_customBlockerFn","enableBeforeUnload","shouldBlock","fn","blockerFn","useBlocker","disabled","router","useRouter","history","resolver","setResolver","React","useState","status","current","next","action","proceed","reset","useEffect","blockerFnComposed","blockerFnArgs","getLocation","location","parsedLocation","parseLocation","matchedRoutes","getMatchedRoutes","foundRoute","Error","href","routeId","id","fullPath","pathname","params","routeParams","search","currentLocation","nextLocation","promise","Promise","resolve","canNavigateAsync","block","_resolvePromptBlockerArgs","props","Block","children","rest","args"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/useBlocker.tsx"],"sourcesContent":["import * as React from 'react'\nimport { useRouter } from './useRouter'\nimport type {\n  BlockerFnArgs,\n  HistoryAction,\n  HistoryLocation,\n} from '@tanstack/history'\nimport type {\n  AnyRoute,\n  AnyRouter,\n  ParseRoute,\n  RegisteredRouter,\n} from '@tanstack/router-core'\n\ninterface ShouldBlockFnLocation<\n  out TRouteId,\n  out TFullPath,\n  out TAllParams,\n  out TFullSearchSchema,\n> {\n  routeId: TRouteId\n  fullPath: TFullPath\n  pathname: string\n  params: TAllParams\n  search: TFullSearchSchema\n}\n\ntype AnyShouldBlockFnLocation = ShouldBlockFnLocation<any, any, any, any>\ntype MakeShouldBlockFnLocationUnion<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TRoute extends AnyRoute = ParseRoute<TRouter['routeTree']>,\n> = TRoute extends any\n  ? ShouldBlockFnLocation<\n      TRoute['id'],\n      TRoute['fullPath'],\n      TRoute['types']['allParams'],\n      TRoute['types']['fullSearchSchema']\n    >\n  : never\n\ntype BlockerResolver<TRouter extends AnyRouter = RegisteredRouter> =\n  | {\n      status: 'blocked'\n      current: MakeShouldBlockFnLocationUnion<TRouter>\n      next: MakeShouldBlockFnLocationUnion<TRouter>\n      action: HistoryAction\n      proceed: () => void\n      reset: () => void\n    }\n  | {\n      status: 'idle'\n      current: undefined\n      next: undefined\n      action: undefined\n      proceed: undefined\n      reset: undefined\n    }\n\ntype ShouldBlockFnArgs<TRouter extends AnyRouter = RegisteredRouter> = {\n  current: MakeShouldBlockFnLocationUnion<TRouter>\n  next: MakeShouldBlockFnLocationUnion<TRouter>\n  action: HistoryAction\n}\n\nexport type ShouldBlockFn<TRouter extends AnyRouter = RegisteredRouter> = (\n  args: ShouldBlockFnArgs<TRouter>,\n) => boolean | Promise<boolean>\nexport type UseBlockerOpts<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n> = {\n  shouldBlockFn: ShouldBlockFn<TRouter>\n  enableBeforeUnload?: boolean | (() => boolean)\n  disabled?: boolean\n  withResolver?: TWithResolver\n}\n\ntype LegacyBlockerFn = () => Promise<any> | any\ntype LegacyBlockerOpts = {\n  blockerFn?: LegacyBlockerFn\n  condition?: boolean | any\n}\n\nfunction _resolveBlockerOpts(\n  opts?: UseBlockerOpts | LegacyBlockerOpts | LegacyBlockerFn,\n  condition?: boolean | any,\n): UseBlockerOpts {\n  if (opts === undefined) {\n    return {\n      shouldBlockFn: () => true,\n      withResolver: false,\n    }\n  }\n\n  if ('shouldBlockFn' in opts) {\n    return opts\n  }\n\n  if (typeof opts === 'function') {\n    const shouldBlock = Boolean(condition ?? true)\n\n    const _customBlockerFn = async () => {\n      if (shouldBlock) return await opts()\n      return false\n    }\n\n    return {\n      shouldBlockFn: _customBlockerFn,\n      enableBeforeUnload: shouldBlock,\n      withResolver: false,\n    }\n  }\n\n  const shouldBlock = Boolean(opts.condition ?? true)\n  const fn = opts.blockerFn\n\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== undefined) {\n      return await fn()\n    }\n    return shouldBlock\n  }\n\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === undefined,\n  }\n}\n\nexport function useBlocker<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = false,\n>(\n  opts: UseBlockerOpts<TRouter, TWithResolver>,\n): TWithResolver extends true ? BlockerResolver<TRouter> : void\n\n/**\n * @deprecated Use the shouldBlockFn property instead\n */\nexport function useBlocker(blockerFnOrOpts?: LegacyBlockerOpts): BlockerResolver\n\n/**\n * @deprecated Use the UseBlockerOpts object syntax instead\n */\nexport function useBlocker(\n  blockerFn?: LegacyBlockerFn,\n  condition?: boolean | any,\n): BlockerResolver\n\nexport function useBlocker(\n  opts?: UseBlockerOpts | LegacyBlockerOpts | LegacyBlockerFn,\n  condition?: boolean | any,\n): BlockerResolver | void {\n  const {\n    shouldBlockFn,\n    enableBeforeUnload = true,\n    disabled = false,\n    withResolver = false,\n  } = _resolveBlockerOpts(opts, condition)\n\n  const router = useRouter()\n  const { history } = router\n\n  const [resolver, setResolver] = React.useState<BlockerResolver>({\n    status: 'idle',\n    current: undefined,\n    next: undefined,\n    action: undefined,\n    proceed: undefined,\n    reset: undefined,\n  })\n\n  React.useEffect(() => {\n    const blockerFnComposed = async (blockerFnArgs: BlockerFnArgs) => {\n      function getLocation(\n        location: HistoryLocation,\n      ): AnyShouldBlockFnLocation {\n        const parsedLocation = router.parseLocation(undefined, location)\n        const matchedRoutes = router.getMatchedRoutes(parsedLocation)\n        if (matchedRoutes.foundRoute === undefined) {\n          throw new Error(`No route found for location ${location.href}`)\n        }\n        return {\n          routeId: matchedRoutes.foundRoute.id,\n          fullPath: matchedRoutes.foundRoute.fullPath,\n          pathname: parsedLocation.pathname,\n          params: matchedRoutes.routeParams,\n          search: parsedLocation.search,\n        }\n      }\n\n      const current = getLocation(blockerFnArgs.currentLocation)\n      const next = getLocation(blockerFnArgs.nextLocation)\n\n      const shouldBlock = await shouldBlockFn({\n        action: blockerFnArgs.action,\n        current,\n        next,\n      })\n      if (!withResolver) {\n        return shouldBlock\n      }\n\n      if (!shouldBlock) {\n        return false\n      }\n\n      const promise = new Promise<boolean>((resolve) => {\n        setResolver({\n          status: 'blocked',\n          current,\n          next,\n          action: blockerFnArgs.action,\n          proceed: () => resolve(false),\n          reset: () => resolve(true),\n        })\n      })\n\n      const canNavigateAsync = await promise\n      setResolver({\n        status: 'idle',\n        current: undefined,\n        next: undefined,\n        action: undefined,\n        proceed: undefined,\n        reset: undefined,\n      })\n\n      return canNavigateAsync\n    }\n\n    return disabled\n      ? undefined\n      : history.block({ blockerFn: blockerFnComposed, enableBeforeUnload })\n  }, [\n    shouldBlockFn,\n    enableBeforeUnload,\n    disabled,\n    withResolver,\n    history,\n    router,\n  ])\n\n  return resolver\n}\n\nconst _resolvePromptBlockerArgs = (\n  props: PromptProps | LegacyPromptProps,\n): UseBlockerOpts => {\n  if ('shouldBlockFn' in props) {\n    return { ...props }\n  }\n\n  const shouldBlock = Boolean(props.condition ?? true)\n  const fn = props.blockerFn\n\n  const _customBlockerFn = async () => {\n    if (shouldBlock && fn !== undefined) {\n      return await fn()\n    }\n    return shouldBlock\n  }\n\n  return {\n    shouldBlockFn: _customBlockerFn,\n    enableBeforeUnload: shouldBlock,\n    withResolver: fn === undefined,\n  }\n}\n\nexport function Block<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n>(opts: PromptProps<TRouter, TWithResolver>): React.ReactNode\n\n/**\n *  @deprecated Use the UseBlockerOpts property instead\n */\nexport function Block(opts: LegacyPromptProps): React.ReactNode\n\nexport function Block(opts: PromptProps | LegacyPromptProps): React.ReactNode {\n  const { children, ...rest } = opts\n  const args = _resolvePromptBlockerArgs(rest)\n\n  const resolver = useBlocker(args)\n  return children\n    ? typeof children === 'function'\n      ? children(resolver as any)\n      : children\n    : null\n}\n\ntype LegacyPromptProps = {\n  blockerFn?: LegacyBlockerFn\n  condition?: boolean | any\n  children?: React.ReactNode | ((params: BlockerResolver) => React.ReactNode)\n}\n\ntype PromptProps<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TWithResolver extends boolean = boolean,\n  TParams = TWithResolver extends true ? BlockerResolver<TRouter> : void,\n> = UseBlockerOpts<TRouter, TWithResolver> & {\n  children?: React.ReactNode | ((params: TParams) => React.ReactNode)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}