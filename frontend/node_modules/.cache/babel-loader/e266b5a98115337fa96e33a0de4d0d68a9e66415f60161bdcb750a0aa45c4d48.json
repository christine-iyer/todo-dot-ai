{"ast":null,"code":"import { functionalUpdate } from \"./utils.js\";\nconst storageKey = \"tsr-scroll-restoration-v1_3\";\nlet sessionsStorage = false;\ntry {\n  sessionsStorage = typeof window !== \"undefined\" && typeof window.sessionStorage === \"object\";\n} catch {}\nconst throttle = (fn, wait) => {\n  let timeout;\n  return (...args) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args);\n        timeout = null;\n      }, wait);\n    }\n  };\n};\nconst scrollRestorationCache = sessionsStorage ? (() => {\n  const state = JSON.parse(window.sessionStorage.getItem(storageKey) || \"null\") || {};\n  return {\n    state,\n    // This setter is simply to make sure that we set the sessionStorage right\n    // after the state is updated. It doesn't necessarily need to be a functional\n    // update.\n    set: updater => (scrollRestorationCache.state = functionalUpdate(updater, scrollRestorationCache.state) || scrollRestorationCache.state, window.sessionStorage.setItem(storageKey, JSON.stringify(scrollRestorationCache.state)))\n  };\n})() : void 0;\nconst defaultGetScrollRestorationKey = location => {\n  return location.state.key || location.href;\n};\nfunction getCssSelector(el) {\n  const path = [];\n  let parent;\n  while (parent = el.parentNode) {\n    path.unshift(`${el.tagName}:nth-child(${[].indexOf.call(parent.children, el) + 1})`);\n    el = parent;\n  }\n  return `${path.join(\" > \")}`.toLowerCase();\n}\nlet ignoreScroll = false;\nfunction restoreScroll(storageKey2, key, behavior, shouldScrollRestoration, scrollToTopSelectors) {\n  var _a;\n  let byKey;\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey2) || \"{}\");\n  } catch (error) {\n    console.error(error);\n    return;\n  }\n  const resolvedKey = key || ((_a = window.history.state) == null ? void 0 : _a.key);\n  const elementEntries = byKey[resolvedKey];\n  ignoreScroll = true;\n  (() => {\n    if (shouldScrollRestoration && elementEntries) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector];\n        if (elementSelector === \"window\") {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior\n          });\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector);\n          if (element) {\n            element.scrollLeft = entry.scrollX;\n            element.scrollTop = entry.scrollY;\n          }\n        }\n      }\n      return;\n    }\n    const hash = window.location.hash.split(\"#\")[1];\n    if (hash) {\n      const hashScrollIntoViewOptions = (window.history.state || {}).__hashScrollIntoViewOptions ?? true;\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash);\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions);\n        }\n      }\n      return;\n    }\n    [\"window\", ...((scrollToTopSelectors == null ? void 0 : scrollToTopSelectors.filter(d => d !== \"window\")) ?? [])].forEach(selector => {\n      const element = selector === \"window\" ? window : document.querySelector(selector);\n      if (element) {\n        element.scrollTo({\n          top: 0,\n          left: 0,\n          behavior\n        });\n      }\n    });\n  })();\n  ignoreScroll = false;\n}\nfunction setupScrollRestoration(router, force) {\n  const shouldScrollRestoration = force ?? router.options.scrollRestoration ?? false;\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true;\n  }\n  if (typeof document === \"undefined\" || router.isScrollRestorationSetup) {\n    return;\n  }\n  router.isScrollRestorationSetup = true;\n  ignoreScroll = false;\n  const getKey = router.options.getScrollRestorationKey || defaultGetScrollRestorationKey;\n  window.history.scrollRestoration = \"manual\";\n  const onScroll = event => {\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return;\n    }\n    let elementSelector = \"\";\n    if (event.target === document || event.target === window) {\n      elementSelector = \"window\";\n    } else {\n      const attrId = event.target.getAttribute(\"data-scroll-restoration-id\");\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`;\n      } else {\n        elementSelector = getCssSelector(event.target);\n      }\n    }\n    const restoreKey = getKey(router.state.location);\n    scrollRestorationCache.set(state => {\n      const keyEntry = state[restoreKey] = state[restoreKey] || {};\n      const elementEntry = keyEntry[elementSelector] = keyEntry[elementSelector] || {};\n      if (elementSelector === \"window\") {\n        elementEntry.scrollX = window.scrollX || 0;\n        elementEntry.scrollY = window.scrollY || 0;\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector);\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0;\n          elementEntry.scrollY = element.scrollTop || 0;\n        }\n      }\n      return state;\n    });\n  };\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"scroll\", throttle(onScroll, 100), true);\n  }\n  router.subscribe(\"onRendered\", event => {\n    const cacheKey = getKey(event.toLocation);\n    if (!router.resetNextScroll) {\n      router.resetNextScroll = true;\n      return;\n    }\n    restoreScroll(storageKey, cacheKey, router.options.scrollRestorationBehavior || void 0, router.isScrollRestoring || void 0, router.options.scrollToTopSelectors || void 0);\n    if (router.isScrollRestoring) {\n      scrollRestorationCache.set(state => {\n        state[cacheKey] = state[cacheKey] || {};\n        return state;\n      });\n    }\n  });\n}\nfunction handleHashScroll(router) {\n  if (typeof document !== \"undefined\" && document.querySelector) {\n    const hashScrollIntoViewOptions = router.state.location.state.__hashScrollIntoViewOptions ?? true;\n    if (hashScrollIntoViewOptions && router.state.location.hash !== \"\") {\n      const el = document.getElementById(router.state.location.hash);\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions);\n      }\n    }\n  }\n}\nexport { defaultGetScrollRestorationKey, getCssSelector, handleHashScroll, restoreScroll, scrollRestorationCache, setupScrollRestoration, storageKey };","map":{"version":3,"names":["storageKey","sessionsStorage","window","sessionStorage","throttle","fn","wait","timeout","args","setTimeout","scrollRestorationCache","state","JSON","parse","getItem","set","updater","functionalUpdate","setItem","stringify","defaultGetScrollRestorationKey","location","key","href","getCssSelector","el","path","parent","parentNode","unshift","tagName","indexOf","call","children","join","toLowerCase","ignoreScroll","restoreScroll","storageKey2","behavior","shouldScrollRestoration","scrollToTopSelectors","byKey","error","console","resolvedKey","_a","history","elementEntries","elementSelector","entry","scrollTo","top","scrollY","left","scrollX","element","document","querySelector","scrollLeft","scrollTop","hash","split","hashScrollIntoViewOptions","__hashScrollIntoViewOptions","getElementById","scrollIntoView","filter","d","forEach","selector","setupScrollRestoration","router","force","options","scrollRestoration","isScrollRestoring","isScrollRestorationSetup","getKey","getScrollRestorationKey","onScroll","event","target","attrId","getAttribute","restoreKey","keyEntry","elementEntry","addEventListener","subscribe","cacheKey","toLocation","resetNextScroll","scrollRestorationBehavior","handleHashScroll"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/router-core/src/scroll-restoration.ts"],"sourcesContent":["import { functionalUpdate } from './utils'\nimport type { AnyRouter } from './router'\nimport type { ParsedLocation } from './location'\nimport type { NonNullableUpdater } from './utils'\n\nexport type ScrollRestorationEntry = { scrollX: number; scrollY: number }\n\nexport type ScrollRestorationByElement = Record<string, ScrollRestorationEntry>\n\nexport type ScrollRestorationByKey = Record<string, ScrollRestorationByElement>\n\nexport type ScrollRestorationCache = {\n  state: ScrollRestorationByKey\n  set: (updater: NonNullableUpdater<ScrollRestorationByKey>) => void\n}\nexport type ScrollRestorationOptions = {\n  getKey?: (location: ParsedLocation) => string\n  scrollBehavior?: ScrollToOptions['behavior']\n}\n\nexport const storageKey = 'tsr-scroll-restoration-v1_3'\nlet sessionsStorage = false\ntry {\n  sessionsStorage =\n    typeof window !== 'undefined' && typeof window.sessionStorage === 'object'\n} catch {}\nconst throttle = (fn: (...args: Array<any>) => void, wait: number) => {\n  let timeout: any\n  return (...args: Array<any>) => {\n    if (!timeout) {\n      timeout = setTimeout(() => {\n        fn(...args)\n        timeout = null\n      }, wait)\n    }\n  }\n}\nexport const scrollRestorationCache: ScrollRestorationCache = sessionsStorage\n  ? (() => {\n      const state: ScrollRestorationByKey =\n        JSON.parse(window.sessionStorage.getItem(storageKey) || 'null') || {}\n\n      return {\n        state,\n        // This setter is simply to make sure that we set the sessionStorage right\n        // after the state is updated. It doesn't necessarily need to be a functional\n        // update.\n        set: (updater) => (\n          (scrollRestorationCache.state =\n            functionalUpdate(updater, scrollRestorationCache.state) ||\n            scrollRestorationCache.state),\n          window.sessionStorage.setItem(\n            storageKey,\n            JSON.stringify(scrollRestorationCache.state),\n          )\n        ),\n      }\n    })()\n  : (undefined as any)\n/**\n * The default `getKey` function for `useScrollRestoration`.\n * It returns the `key` from the location state or the `href` of the location.\n *\n * The `location.href` is used as a fallback to support the use case where the location state is not available like the initial render.\n */\n\nexport const defaultGetScrollRestorationKey = (location: ParsedLocation) => {\n  return location.state.key! || location.href\n}\n\nexport function getCssSelector(el: any): string {\n  const path = []\n  let parent\n  while ((parent = el.parentNode)) {\n    path.unshift(\n      `${el.tagName}:nth-child(${([].indexOf as any).call(parent.children, el) + 1})`,\n    )\n    el = parent\n  }\n  return `${path.join(' > ')}`.toLowerCase()\n}\n\nlet ignoreScroll = false\n\n// NOTE: This function must remain pure and not use any outside variables\n// unless they are passed in as arguments. Why? Because we need to be able to\n// toString() it into a script tag to execute as early as possible in the browser\n// during SSR. Additionally, we also call it from within the router lifecycle\nexport function restoreScroll(\n  storageKey: string,\n  key: string | undefined,\n  behavior: ScrollToOptions['behavior'] | undefined,\n  shouldScrollRestoration: boolean | undefined,\n  scrollToTopSelectors: Array<string> | undefined,\n) {\n  let byKey: ScrollRestorationByKey\n\n  try {\n    byKey = JSON.parse(sessionStorage.getItem(storageKey) || '{}')\n  } catch (error: any) {\n    console.error(error)\n    return\n  }\n\n  const resolvedKey = key || window.history.state?.key\n  const elementEntries = byKey[resolvedKey]\n\n  //\n  ignoreScroll = true\n\n  //\n  ;(() => {\n    // If we have a cached entry for this location state,\n    // we always need to prefer that over the hash scroll.\n    if (shouldScrollRestoration && elementEntries) {\n      for (const elementSelector in elementEntries) {\n        const entry = elementEntries[elementSelector]!\n        if (elementSelector === 'window') {\n          window.scrollTo({\n            top: entry.scrollY,\n            left: entry.scrollX,\n            behavior,\n          })\n        } else if (elementSelector) {\n          const element = document.querySelector(elementSelector)\n          if (element) {\n            element.scrollLeft = entry.scrollX\n            element.scrollTop = entry.scrollY\n          }\n        }\n      }\n\n      return\n    }\n\n    // If we don't have a cached entry for the hash,\n    // Which means we've never seen this location before,\n    // we need to check if there is a hash in the URL.\n    // If there is, we need to scroll it's ID into view.\n    const hash = window.location.hash.split('#')[1]\n\n    if (hash) {\n      const hashScrollIntoViewOptions =\n        (window.history.state || {}).__hashScrollIntoViewOptions ?? true\n\n      if (hashScrollIntoViewOptions) {\n        const el = document.getElementById(hash)\n        if (el) {\n          el.scrollIntoView(hashScrollIntoViewOptions)\n        }\n      }\n\n      return\n    }\n\n    // If there is no cached entry for the hash and there is no hash in the URL,\n    // we need to scroll to the top of the page for every scrollToTop element\n    ;[\n      'window',\n      ...(scrollToTopSelectors?.filter((d) => d !== 'window') ?? []),\n    ].forEach((selector) => {\n      const element =\n        selector === 'window' ? window : document.querySelector(selector)\n      if (element) {\n        element.scrollTo({\n          top: 0,\n          left: 0,\n          behavior,\n        })\n      }\n    })\n  })()\n\n  //\n  ignoreScroll = false\n}\n\nexport function setupScrollRestoration(router: AnyRouter, force?: boolean) {\n  const shouldScrollRestoration =\n    force ?? router.options.scrollRestoration ?? false\n\n  if (shouldScrollRestoration) {\n    router.isScrollRestoring = true\n  }\n\n  if (typeof document === 'undefined' || router.isScrollRestorationSetup) {\n    return\n  }\n\n  router.isScrollRestorationSetup = true\n\n  //\n  ignoreScroll = false\n\n  const getKey =\n    router.options.getScrollRestorationKey || defaultGetScrollRestorationKey\n\n  window.history.scrollRestoration = 'manual'\n\n  // // Create a MutationObserver to monitor DOM changes\n  // const mutationObserver = new MutationObserver(() => {\n  //   ;ignoreScroll = true\n  //   requestAnimationFrame(() => {\n  //     ;ignoreScroll = false\n\n  //     // Attempt to restore scroll position on each dom\n  //     // mutation until the user scrolls. We do this\n  //     // because dynamic content may come in at different\n  //     // ticks after the initial render and we want to\n  //     // keep up with that content as much as possible.\n  //     // As soon as the user scrolls, we no longer need\n  //     // to attempt router.\n  //     // console.log('mutation observer restoreScroll')\n  //     restoreScroll(\n  //       storageKey,\n  //       getKey(router.state.location),\n  //       router.options.scrollRestorationBehavior,\n  //     )\n  //   })\n  // })\n\n  // const observeDom = () => {\n  //   // Observe changes to the entire document\n  //   mutationObserver.observe(document, {\n  //     childList: true, // Detect added or removed child nodes\n  //     subtree: true, // Monitor all descendants\n  //     characterData: true, // Detect text content changes\n  //   })\n  // }\n\n  // const unobserveDom = () => {\n  //   mutationObserver.disconnect()\n  // }\n\n  // observeDom()\n\n  const onScroll = (event: Event) => {\n    // unobserveDom()\n\n    if (ignoreScroll || !router.isScrollRestoring) {\n      return\n    }\n\n    let elementSelector = ''\n\n    if (event.target === document || event.target === window) {\n      elementSelector = 'window'\n    } else {\n      const attrId = (event.target as Element).getAttribute(\n        'data-scroll-restoration-id',\n      )\n\n      if (attrId) {\n        elementSelector = `[data-scroll-restoration-id=\"${attrId}\"]`\n      } else {\n        elementSelector = getCssSelector(event.target)\n      }\n    }\n\n    const restoreKey = getKey(router.state.location)\n\n    scrollRestorationCache.set((state) => {\n      const keyEntry = (state[restoreKey] =\n        state[restoreKey] || ({} as ScrollRestorationByElement))\n\n      const elementEntry = (keyEntry[elementSelector] =\n        keyEntry[elementSelector] || ({} as ScrollRestorationEntry))\n\n      if (elementSelector === 'window') {\n        elementEntry.scrollX = window.scrollX || 0\n        elementEntry.scrollY = window.scrollY || 0\n      } else if (elementSelector) {\n        const element = document.querySelector(elementSelector)\n        if (element) {\n          elementEntry.scrollX = element.scrollLeft || 0\n          elementEntry.scrollY = element.scrollTop || 0\n        }\n      }\n\n      return state\n    })\n  }\n\n  // Throttle the scroll event to avoid excessive updates\n  if (typeof document !== 'undefined') {\n    document.addEventListener('scroll', throttle(onScroll, 100), true)\n  }\n\n  router.subscribe('onRendered', (event) => {\n    // unobserveDom()\n\n    const cacheKey = getKey(event.toLocation)\n\n    // If the user doesn't want to restore the scroll position,\n    // we don't need to do anything.\n    if (!router.resetNextScroll) {\n      router.resetNextScroll = true\n      return\n    }\n\n    restoreScroll(\n      storageKey,\n      cacheKey,\n      router.options.scrollRestorationBehavior || undefined,\n      router.isScrollRestoring || undefined,\n      router.options.scrollToTopSelectors || undefined,\n    )\n\n    if (router.isScrollRestoring) {\n      // Mark the location as having been seen\n      scrollRestorationCache.set((state) => {\n        state[cacheKey] = state[cacheKey] || ({} as ScrollRestorationByElement)\n\n        return state\n      })\n    }\n  })\n}\n\n/**\n * @internal\n * Handles hash-based scrolling after navigation completes.\n * To be used in framework-specific <Transitioner> components during the onResolved event.\n *\n * Provides hash scrolling for programmatic navigation when default browser handling is prevented.\n * @param router The router instance containing current location and state\n */\nexport function handleHashScroll(router: AnyRouter) {\n  if (typeof document !== 'undefined' && (document as any).querySelector) {\n    const hashScrollIntoViewOptions =\n      router.state.location.state.__hashScrollIntoViewOptions ?? true\n\n    if (hashScrollIntoViewOptions && router.state.location.hash !== '') {\n      const el = document.getElementById(router.state.location.hash)\n      if (el) {\n        el.scrollIntoView(hashScrollIntoViewOptions)\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}