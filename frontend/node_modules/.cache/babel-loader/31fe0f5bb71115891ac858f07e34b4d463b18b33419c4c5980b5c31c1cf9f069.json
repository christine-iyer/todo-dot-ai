{"ast":null,"code":"import { jsx, jsxs } from \"react/jsx-runtime\";\nimport * as React from \"react\";\nimport warning from \"tiny-warning\";\nimport { CatchBoundary, ErrorComponent } from \"./CatchBoundary.js\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { useRouter } from \"./useRouter.js\";\nimport { Transitioner } from \"./Transitioner.js\";\nimport { matchContext } from \"./matchContext.js\";\nimport { Match } from \"./Match.js\";\nimport { SafeFragment } from \"./SafeFragment.js\";\nfunction Matches() {\n  const router = useRouter();\n  const pendingElement = router.options.defaultPendingComponent ? /* @__PURE__ */jsx(router.options.defaultPendingComponent, {}) : null;\n  const ResolvedSuspense = router.isServer || typeof document !== \"undefined\" && router.clientSsr ? SafeFragment : React.Suspense;\n  const inner = /* @__PURE__ */jsxs(ResolvedSuspense, {\n    fallback: pendingElement,\n    children: [/* @__PURE__ */jsx(Transitioner, {}), /* @__PURE__ */jsx(MatchesInner, {})]\n  });\n  return router.options.InnerWrap ? /* @__PURE__ */jsx(router.options.InnerWrap, {\n    children: inner\n  }) : inner;\n}\nfunction MatchesInner() {\n  const matchId = useRouterState({\n    select: s => {\n      var _a;\n      return (_a = s.matches[0]) == null ? void 0 : _a.id;\n    }\n  });\n  const resetKey = useRouterState({\n    select: s => s.loadedAt\n  });\n  return /* @__PURE__ */jsx(matchContext.Provider, {\n    value: matchId,\n    children: /* @__PURE__ */jsx(CatchBoundary, {\n      getResetKey: () => resetKey,\n      errorComponent: ErrorComponent,\n      onCatch: error => {\n        warning(false, `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`);\n        warning(false, error.message || error.toString());\n      },\n      children: matchId ? /* @__PURE__ */jsx(Match, {\n        matchId\n      }) : null\n    })\n  });\n}\nfunction useMatchRoute() {\n  const router = useRouter();\n  useRouterState({\n    select: s => {\n      var _a;\n      return [s.location.href, (_a = s.resolvedLocation) == null ? void 0 : _a.href, s.status];\n    },\n    structuralSharing: true\n  });\n  return React.useCallback(opts => {\n    const {\n      pending,\n      caseSensitive,\n      fuzzy,\n      includeSearch,\n      ...rest\n    } = opts;\n    return router.matchRoute(rest, {\n      pending,\n      caseSensitive,\n      fuzzy,\n      includeSearch\n    });\n  }, [router]);\n}\nfunction MatchRoute(props) {\n  const matchRoute = useMatchRoute();\n  const params = matchRoute(props);\n  if (typeof props.children === \"function\") {\n    return props.children(params);\n  }\n  return params ? props.children : null;\n}\nfunction useMatches(opts) {\n  return useRouterState({\n    select: state => {\n      const matches = state.matches;\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts == null ? void 0 : opts.structuralSharing\n  });\n}\nfunction useParentMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: matches => {\n      matches = matches.slice(0, matches.findIndex(d => d.id === contextMatchId));\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts == null ? void 0 : opts.structuralSharing\n  });\n}\nfunction useChildMatches(opts) {\n  const contextMatchId = React.useContext(matchContext);\n  return useMatches({\n    select: matches => {\n      matches = matches.slice(matches.findIndex(d => d.id === contextMatchId) + 1);\n      return (opts == null ? void 0 : opts.select) ? opts.select(matches) : matches;\n    },\n    structuralSharing: opts == null ? void 0 : opts.structuralSharing\n  });\n}\nexport { MatchRoute, Matches, useChildMatches, useMatchRoute, useMatches, useParentMatches };","map":{"version":3,"names":["Matches","router","useRouter","pendingElement","options","defaultPendingComponent","jsx","ResolvedSuspense","isServer","document","clientSsr","SafeFragment","React","Suspense","inner","jsxs","fallback","children","Transitioner","MatchesInner","InnerWrap","matchId","useRouterState","select","s","_a","matches","id","resetKey","loadedAt","matchContext","Provider","value","CatchBoundary","getResetKey","errorComponent","ErrorComponent","onCatch","error","warning","message","toString","Match","useMatchRoute","location","href","resolvedLocation","status","structuralSharing","useCallback","opts","pending","caseSensitive","fuzzy","includeSearch","rest","matchRoute","MatchRoute","props","params","useMatches","state","useParentMatches","contextMatchId","useContext","slice","findIndex","d","useChildMatches"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/Matches.tsx"],"sourcesContent":["import * as React from 'react'\nimport warning from 'tiny-warning'\nimport { CatchBoundary, ErrorComponent } from './CatchBoundary'\nimport { useRouterState } from './useRouterState'\nimport { useRouter } from './useRouter'\nimport { Transitioner } from './Transitioner'\nimport { matchContext } from './matchContext'\nimport { Match } from './Match'\nimport { SafeFragment } from './SafeFragment'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type { ReactNode } from './route'\nimport type {\n  AnyRouter,\n  DeepPartial,\n  MakeOptionalPathParams,\n  MakeOptionalSearchParams,\n  MakeRouteMatchUnion,\n  MaskOptions,\n  MatchRouteOptions,\n  NoInfer,\n  RegisteredRouter,\n  ResolveRelativePath,\n  ResolveRoute,\n  RouteByPath,\n  RouterState,\n  ToSubOptionsProps,\n} from '@tanstack/router-core'\n\ndeclare module '@tanstack/router-core' {\n  export interface RouteMatchExtensions {\n    meta?: Array<React.JSX.IntrinsicElements['meta'] | undefined>\n    links?: Array<React.JSX.IntrinsicElements['link'] | undefined>\n    scripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>\n    headScripts?: Array<React.JSX.IntrinsicElements['script'] | undefined>\n  }\n}\n\nexport function Matches() {\n  const router = useRouter()\n\n  const pendingElement = router.options.defaultPendingComponent ? (\n    <router.options.defaultPendingComponent />\n  ) : null\n\n  // Do not render a root Suspense during SSR or hydrating from SSR\n  const ResolvedSuspense =\n    router.isServer || (typeof document !== 'undefined' && router.clientSsr)\n      ? SafeFragment\n      : React.Suspense\n\n  const inner = (\n    <ResolvedSuspense fallback={pendingElement}>\n      <Transitioner />\n      <MatchesInner />\n    </ResolvedSuspense>\n  )\n\n  return router.options.InnerWrap ? (\n    <router.options.InnerWrap>{inner}</router.options.InnerWrap>\n  ) : (\n    inner\n  )\n}\n\nfunction MatchesInner() {\n  const matchId = useRouterState({\n    select: (s) => {\n      return s.matches[0]?.id\n    },\n  })\n\n  const resetKey = useRouterState({\n    select: (s) => s.loadedAt,\n  })\n\n  return (\n    <matchContext.Provider value={matchId}>\n      <CatchBoundary\n        getResetKey={() => resetKey}\n        errorComponent={ErrorComponent}\n        onCatch={(error) => {\n          warning(\n            false,\n            `The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!`,\n          )\n          warning(false, error.message || error.toString())\n        }}\n      >\n        {matchId ? <Match matchId={matchId} /> : null}\n      </CatchBoundary>\n    </matchContext.Provider>\n  )\n}\n\nexport type UseMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = ToSubOptionsProps<TRouter, TFrom, TTo> &\n  DeepPartial<MakeOptionalSearchParams<TRouter, TFrom, TTo>> &\n  DeepPartial<MakeOptionalPathParams<TRouter, TFrom, TTo>> &\n  MaskOptions<TRouter, TMaskFrom, TMaskTo> &\n  MatchRouteOptions\n\nexport function useMatchRoute<TRouter extends AnyRouter = RegisteredRouter>() {\n  const router = useRouter()\n\n  useRouterState({\n    select: (s) => [s.location.href, s.resolvedLocation?.href, s.status],\n    structuralSharing: true as any,\n  })\n\n  return React.useCallback(\n    <\n      const TFrom extends string = string,\n      const TTo extends string | undefined = undefined,\n      const TMaskFrom extends string = TFrom,\n      const TMaskTo extends string = '',\n    >(\n      opts: UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>,\n    ): false | ResolveRoute<TRouter, TFrom, TTo>['types']['allParams'] => {\n      const { pending, caseSensitive, fuzzy, includeSearch, ...rest } = opts\n\n      return router.matchRoute(rest as any, {\n        pending,\n        caseSensitive,\n        fuzzy,\n        includeSearch,\n      })\n    },\n    [router],\n  )\n}\n\nexport type MakeMatchRouteOptions<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TFrom extends string = string,\n  TTo extends string | undefined = undefined,\n  TMaskFrom extends string = TFrom,\n  TMaskTo extends string = '',\n> = UseMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo> & {\n  // If a function is passed as a child, it will be given the `isActive` boolean to aid in further styling on the element it returns\n  children?:\n    | ((\n        params?: RouteByPath<\n          TRouter['routeTree'],\n          ResolveRelativePath<TFrom, NoInfer<TTo>>\n        >['types']['allParams'],\n      ) => ReactNode)\n    | React.ReactNode\n}\n\nexport function MatchRoute<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string = string,\n  const TTo extends string | undefined = undefined,\n  const TMaskFrom extends string = TFrom,\n  const TMaskTo extends string = '',\n>(props: MakeMatchRouteOptions<TRouter, TFrom, TTo, TMaskFrom, TMaskTo>): any {\n  const matchRoute = useMatchRoute()\n  const params = matchRoute(props as any) as boolean\n\n  if (typeof props.children === 'function') {\n    return (props.children as any)(params)\n  }\n\n  return params ? props.children : null\n}\n\nexport interface UseMatchesBaseOptions<\n  TRouter extends AnyRouter,\n  TSelected,\n  TStructuralSharing,\n> {\n  select?: (\n    matches: Array<MakeRouteMatchUnion<TRouter>>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n}\n\nexport type UseMatchesResult<\n  TRouter extends AnyRouter,\n  TSelected,\n> = unknown extends TSelected ? Array<MakeRouteMatchUnion<TRouter>> : TSelected\n\nexport function useMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  return useRouterState({\n    select: (state: RouterState<TRouter['routeTree']>) => {\n      const matches = state.matches\n      return opts?.select\n        ? opts.select(matches as Array<MakeRouteMatchUnion<TRouter>>)\n        : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any) as UseMatchesResult<TRouter, TSelected>\n}\n\nexport function useParentMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        0,\n        matches.findIndex((d) => d.id === contextMatchId),\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any)\n}\n\nexport function useChildMatches<\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchesBaseOptions<TRouter, TSelected, TStructuralSharing> &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n): UseMatchesResult<TRouter, TSelected> {\n  const contextMatchId = React.useContext(matchContext)\n\n  return useMatches({\n    select: (matches: Array<MakeRouteMatchUnion<TRouter>>) => {\n      matches = matches.slice(\n        matches.findIndex((d) => d.id === contextMatchId) + 1,\n      )\n      return opts?.select ? opts.select(matches) : matches\n    },\n    structuralSharing: opts?.structuralSharing,\n  } as any)\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}