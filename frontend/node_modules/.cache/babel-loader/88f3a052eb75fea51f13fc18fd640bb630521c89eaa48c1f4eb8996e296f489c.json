{"ast":null,"code":"import * as React from \"react\";\nimport invariant from \"tiny-invariant\";\nimport { useRouterState } from \"./useRouterState.js\";\nimport { dummyMatchContext, matchContext } from \"./matchContext.js\";\nfunction useMatch(opts) {\n  const nearestMatchId = React.useContext(opts.from ? dummyMatchContext : matchContext);\n  const matchSelection = useRouterState({\n    select: state => {\n      const match = state.matches.find(d => opts.from ? opts.from === d.routeId : d.id === nearestMatchId);\n      invariant(!((opts.shouldThrow ?? true) && !match), `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : \"a nearest match!\"}`);\n      if (match === void 0) {\n        return void 0;\n      }\n      return opts.select ? opts.select(match) : match;\n    },\n    structuralSharing: opts.structuralSharing\n  });\n  return matchSelection;\n}\nexport { useMatch };","map":{"version":3,"names":["useMatch","opts","nearestMatchId","React","useContext","from","dummyMatchContext","matchContext","matchSelection","useRouterState","select","state","match","matches","find","d","routeId","id","invariant","shouldThrow","structuralSharing"],"sources":["/Users/christineiyer/Documents/tan-stack-learning/todo-dot-ai/frontend/node_modules/@tanstack/react-router/src/useMatch.tsx"],"sourcesContent":["import * as React from 'react'\nimport invariant from 'tiny-invariant'\nimport { useRouterState } from './useRouterState'\nimport { dummyMatchContext, matchContext } from './matchContext'\nimport type {\n  StructuralSharingOption,\n  ValidateSelected,\n} from './structuralSharing'\nimport type {\n  AnyRouter,\n  MakeRouteMatch,\n  MakeRouteMatchUnion,\n  RegisteredRouter,\n  StrictOrFrom,\n  ThrowConstraint,\n  ThrowOrOptional,\n} from '@tanstack/router-core'\n\nexport interface UseMatchBaseOptions<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing extends boolean,\n> {\n  select?: (\n    match: MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>,\n  ) => ValidateSelected<TRouter, TSelected, TStructuralSharing>\n  shouldThrow?: TThrow\n}\n\nexport type UseMatchRoute<out TFrom> = <\n  TRouter extends AnyRouter = RegisteredRouter,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts?: UseMatchBaseOptions<\n    TRouter,\n    TFrom,\n    true,\n    true,\n    TSelected,\n    TStructuralSharing\n  > &\n    StructuralSharingOption<TRouter, TSelected, TStructuralSharing>,\n) => UseMatchResult<TRouter, TFrom, true, TSelected>\n\nexport type UseMatchOptions<\n  TRouter extends AnyRouter,\n  TFrom extends string | undefined,\n  TStrict extends boolean,\n  TThrow extends boolean,\n  TSelected,\n  TStructuralSharing extends boolean,\n> = StrictOrFrom<TRouter, TFrom, TStrict> &\n  UseMatchBaseOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    TThrow,\n    TSelected,\n    TStructuralSharing\n  > &\n  StructuralSharingOption<TRouter, TSelected, TStructuralSharing>\n\nexport type UseMatchResult<\n  TRouter extends AnyRouter,\n  TFrom,\n  TStrict extends boolean,\n  TSelected,\n> = unknown extends TSelected\n  ? TStrict extends true\n    ? MakeRouteMatch<TRouter['routeTree'], TFrom, TStrict>\n    : MakeRouteMatchUnion<TRouter>\n  : TSelected\n\nexport function useMatch<\n  TRouter extends AnyRouter = RegisteredRouter,\n  const TFrom extends string | undefined = undefined,\n  TStrict extends boolean = true,\n  TThrow extends boolean = true,\n  TSelected = unknown,\n  TStructuralSharing extends boolean = boolean,\n>(\n  opts: UseMatchOptions<\n    TRouter,\n    TFrom,\n    TStrict,\n    ThrowConstraint<TStrict, TThrow>,\n    TSelected,\n    TStructuralSharing\n  >,\n): ThrowOrOptional<UseMatchResult<TRouter, TFrom, TStrict, TSelected>, TThrow> {\n  const nearestMatchId = React.useContext(\n    opts.from ? dummyMatchContext : matchContext,\n  )\n\n  const matchSelection = useRouterState({\n    select: (state: any) => {\n      const match = state.matches.find((d: any) =>\n        opts.from ? opts.from === d.routeId : d.id === nearestMatchId,\n      )\n      invariant(\n        !((opts.shouldThrow ?? true) && !match),\n        `Could not find ${opts.from ? `an active match from \"${opts.from}\"` : 'a nearest match!'}`,\n      )\n\n      if (match === undefined) {\n        return undefined\n      }\n\n      return opts.select ? opts.select(match) : match\n    },\n    structuralSharing: opts.structuralSharing,\n  } as any)\n\n  return matchSelection as any\n}\n"],"mappings":";;;;AA6EO,SAASA,SAQdC,IAAA,EAQ6E;EAC7E,MAAMC,cAAA,GAAiBC,KAAA,CAAMC,UAAA,CAC3BH,IAAA,CAAKI,IAAA,GAAOC,iBAAA,GAAoBC,YAClC;EAEA,MAAMC,cAAA,GAAiBC,cAAA,CAAe;IACpCC,MAAA,EAASC,KAAA,IAAe;MAChB,MAAAC,KAAA,GAAQD,KAAA,CAAME,OAAA,CAAQC,IAAA,CAAMC,CAAA,IAChCd,IAAA,CAAKI,IAAA,GAAOJ,IAAA,CAAKI,IAAA,KAASU,CAAA,CAAEC,OAAA,GAAUD,CAAA,CAAEE,EAAA,KAAOf,cACjD;MACAgB,SAAA,CACE,GAAGjB,IAAA,CAAKkB,WAAA,IAAe,SAAS,CAACP,KAAA,GACjC,kBAAkBX,IAAA,CAAKI,IAAA,GAAO,yBAAyBJ,IAAA,CAAKI,IAAI,MAAM,kBAAkB,EAC1F;MAEA,IAAIO,KAAA,KAAU,QAAW;QAChB;MAAA;MAGT,OAAOX,IAAA,CAAKS,MAAA,GAAST,IAAA,CAAKS,MAAA,CAAOE,KAAK,IAAIA,KAAA;IAC5C;IACAQ,iBAAA,EAAmBnB,IAAA,CAAKmB;EAAA,CAClB;EAED,OAAAZ,cAAA;AACT","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}